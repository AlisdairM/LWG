<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>C++ Standard Library Unresolved Issues</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
</style>
</head>
<body>
<p>Revised 2011-03-24 at 17:03:09 UTC</p>
<h2>Unresolved Issues</h2>
<hr>
<h3><a name="964"></a>964. Various threading bugs #14</h3>
<p><b>Section:</b> 30.5.2 [thread.condition.condvarany] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07 <b>Last modified:</b> 2011-02-20</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.condition.condvarany">issues</a> in [thread.condition.condvarany].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The requirements for the constructor for <tt>condition_variable</tt> has several
error conditions, but the requirements for the constructor for
<tt>condition_variable_any</tt> has none. Is this difference intentional?
</p>

<p><i>[
Summit:
]</i></p>


<blockquote><p>
Move to open, pass to Howard. If this is intentional, a note may be
helpful. If the error conditions are to be copied from
<tt>condition_variable</tt>, this depends on LWG <a href="lwg-defects.html#965">965</a>.
</p></blockquote>

<p><i>[
Post Summit Howard adds:
]</i></p>


<blockquote><p>
The original intention 
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2447.htm#ConditionVariablesWording">N2447</a>)
was to let the OS return whatever errors it was going to return, and for
those to be translated into exceptions, for both
<tt>condition_variable</tt> and <tt>condition_variable_any</tt>.  I have not
received any complaints about specific error conditions from vendors on
non-POSIX platforms, but such complaints would not surprise me if they surfaced.
</p></blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
Leave open. Benjamin to provide wording.
</p></blockquote>

<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote>
<p>
We don't have throw clauses for condition variables.
</p>
<p>
This issue may be dependent on LWG <a href="lwg-defects.html#1268">1268</a>.
</p>
<p>
Leave open. Detlef will coordinate with Benjamin.
</p>
<p>
Consider merging LWG 964, <a href="lwg-active.html#966">966</a>, and <a href="lwg-defects.html#1268">1268</a> into a
single paper.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="966"></a>966. Various threading bugs #16</h3>
<p><b>Section:</b> 30.5.1 [thread.condition.condvar] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07 <b>Last modified:</b> 2011-03-06</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.condition.condvar">issues</a> in [thread.condition.condvar].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
30.5.1 [thread.condition.condvar]:
<tt>condition_variable::wait</tt> and
<tt>condition_variable::wait_until</tt> both have a postcondition that
<tt>lock</tt> is locked by the calling thread, and a throws clause that
requires throwing an exception if this postcondition cannot be achieved.
How can the implementation detect that this <tt>lock</tt> can never be
obtained?
</p>

<p><i>[
Summit:
]</i></p>


<blockquote><p>
Move to open. Requires wording. Agreed this is an issue, and the
specification should not require detecting deadlocks.
</p></blockquote>

<p><i>[
2009-08-01 Howard provides wording.
]</i></p>


<blockquote>
<p>
The proposed wording is inspired by the POSIX spec which says:
</p>

<blockquote>
<dl>
<dt>[EINVAL]</dt>
<dd>The value specified by cond or mutex is invalid.</dd>
<dt>[EPERM]</dt>
<dd>The mutex was not owned by the current thread at the time of the call.</dd>
</dl>
</blockquote>

<p>
I do not believe [EINVAL] is possible without memory corruption (which we don't
specify).  [EPERM] is possible if this thread doesn't own the mutex, which is
listed as a precondition.  "May" is used instead of "Shall" because not all
OS's are POSIX.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
Leave open, Detlef to provide improved wording.
</p></blockquote>

<p><i>[
2009-10-23 Detlef Provided wording.
]</i></p>


<blockquote>
<p>
Detlef's wording put in Proposed resolution.  Original wording here:
</p>
<blockquote>
<p>
Change 30.5.1 [thread.condition.condvar] p12, p19 and
30.5.2 [thread.condition.condvarany] p10, p16:
</p>

<blockquote><p>
<i>Throws:</i> <ins>May throw</ins> <tt>std::system_error</tt> 
<ins>
if a precondition is not met.
</ins>
<del>when the effects or postcondition
cannot be achieved.</del>
</p></blockquote>
</blockquote>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote><p>
Leave open, Detlef to provide improved wording.
</p></blockquote>

<p><i>[
2009-11-18 Anthony adds:
]</i></p>


<blockquote>
<p>
<tt>condition_variable::wait</tt> takes a <tt>unique_lock&lt;mutex&gt;</tt>. We
know whether or not a <tt>unique_lock</tt> owns a lock, through use of its
<tt>owns_lock()</tt> member.
</p>

<p>
I would like to propose the following resolution:
</p>

<blockquote>
<p>
Modify the first sentence of 30.5.1 [thread.condition.condvar] p9:
</p>

<blockquote><pre>
void wait(unique_lock&lt;mutex&gt;&amp; lock);
</pre>
<blockquote><p>
9 <i>Precondition:</i> <del><tt>lock</tt> is locked by the calling thread</del>
<ins><tt>lock.owns_lock()</tt> is <tt>true</tt></ins>, and either
</p><p>...</p>
</blockquote>
</blockquote>

<p>
Replace 30.5.1 [thread.condition.condvar] p11-13 with:
</p>

<blockquote><pre>
void wait(unique_lock&lt;mutex&gt;&amp; lock);
</pre>
<blockquote>
<p>...</p>
<p>
11 <i>Postcondition:</i> <del><tt>lock</tt> is locked by the calling
thread</del> <ins><tt>lock.owns_lock()</tt> is <tt>true</tt></ins>.
</p>

<p>
12 <i>Throws:</i> <tt>std::system_error</tt> <del>when the effects or
postcondition cannot be achieved</del> <ins>if the implementation detects that
the preconditions are not met or the effects cannot be achieved. Any exception
thrown by <tt>lock.lock()</tt> or <tt>lock.unlock()</tt></ins>.
</p>

<p>
13 <i>Error Conditions:</i> <ins>The error conditions are implementation
defined.</ins>
</p>

<ul>
<li><del>
equivalent error condition from <tt>lock.lock()</tt> or <tt>lock.unlock()</tt>.
</del></li>
</ul>

</blockquote>
</blockquote>
</blockquote>
</blockquote>

<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote>
<p>
There are heavy conflicts with adopted papers.
</p>
<p>
This issue is dependent on LWG <a href="lwg-defects.html#1268">1268</a>.
</p>
<p>
Leave open pending outstanding edits to the working draft. Detlef will provide
wording.
</p>
<p>
Possibly related to <a href="lwg-active.html#964">964</a>.
</p>

</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Replace 30.5.1 [thread.condition.condvar] p12, p19 and
30.5.2 [thread.condition.condvarany] p10, p16:
</p>

<blockquote>
<p><del>
<i>Throws:</i> <tt>std::system_error</tt> when the effects or
postcondition cannot be achieved.
</del></p>
<p><del>
Error conditions:
</del></p>
<ul>
<li><del>
equivalent error condition from <tt>lock.lock()</tt> or <tt>lock.unlock()</tt>.
</del></li>
</ul>

<p><ins>
<i>Throws:</i> It is implementation-defined whether a <tt>std::system_error</tt>
with implementation-defined error condition is thrown if the
precondition is not met.
</ins></p>
</blockquote>






<hr>
<h3><a name="1169"></a>1169. <tt>num_get</tt> not fully compatible with <tt>strto*</tt></h3>
<p><b>Section:</b> 22.4.2.1.2 [facet.num.get.virtuals] <b>Status:</b> <a href="lwg-active.html#Deferred">Deferred</a>
 <b>Submitter:</b> Cosmin Truta <b>Opened:</b> 2009-07-04 <b>Last modified:</b> 2011-03-24</p>
<p><b>View other</b> <a href="lwg-index-open.html#facet.num.get.virtuals">active issues</a> in [facet.num.get.virtuals].</p>
<p><b>View all other</b> <a href="lwg-index.html#facet.num.get.virtuals">issues</a> in [facet.num.get.virtuals].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Deferred">Deferred</a> status.</p>
<p><b>Discussion:</b></p>
<p>
As specified in the latest draft,
<a 
href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2914.pdf">N2914</a>,
<code>num_get</code> is still not fully compatible with the following C
functions: <code>strtoul</code>, <code>strtoull</code>, 
<code>strtof</code> and
<code>strtod</code>.
</p>
<p>
In C, when conversion of a string to an unsigned integer type falls 
outside the
representable range, <code>strtoul</code> and <code>strtoull</code> return
<code>ULONG_MAX</code> and <code>ULLONG_MAX</code>, respectively, 
regardless
whether the input field represents a positive or a negative value.
On the other hand, the result of <code>num_get</code> conversion of 
negative
values to unsigned integer types is zero. This raises a compatibility 
issue.
</p>
<p>
Moreover, in C, when conversion of a string to a floating-point type falls
outside the representable range, <code>strtof</code>, <code>strtod</code> 
and
<code>strtold</code> return <code>&#xB1HUGE_VALF</code>,
<code>&#xB1HUGE_VAL</code> and <code>&#xB1HUGE_VALL</code>, respectively.
On the other hand, the result of <code>num_get</code> conversion of such
out-of-range floating-point values results in the most positive/negative
representable value.
Although many C library implementations do implement <code>HUGE_VAL</code>
(etc.) as the highest representable (which is, usually, the infinity), 
this isn't required by the C standard. The C library specification makes no
statement regarding the value of <code>HUGE_VAL</code> and friends, which
potentially raises the same compatibility issue as in the above case of
unsigned integers.
In addition, neither C nor C++ define symbolic constants for the maximum
representable floating-point values (they only do so only for the maximum
representable <i>finite</i> floating-point values), which raises a 
usability
issue (it would be hard for the programmer to check the result of
<code>num_get</code> against overflow).
</p>
<p>
As such, we propose to adjust the specification of <code>num_get</code> to
closely follow the behavior of all of its underlying C functions.
</p>



<p><i>[
2010 Rapperswil:
]</i></p>


<blockquote><p>
Some concern that this is changing the specification for an existing C++03 function, but it was 
pointed out that this was underspecified as resolved by issue 23.  This is clean-up for that 
issue in turn. Some concern that we are trying to solve the same problem in both clause 22 and 27.
</p>
<p>
Bill: There's a change here as to whether val is stored to in an error case.
</p>
<p>
Pablo: Don't think this changes whether val is stored to or not, but changes the value that is stored.
</p>
<p>
Bill: Remembers having skirmishes with customers and testers as to whether val is stored to, and the resolution was not to store in error cases.
</p>
<p>
Howard: Believes since C++03 we made a change to always store in overflow.
</p>
<p>
Everyone took some time to review the issue.
</p>
<p>
Pablo: C++98 definitely did not store any value during an error condition.
</p>
<p>
Dietmar: Depends on the question of what is considered an error, and whether overflow is an error or not, which was the crux of LWG 23.
</p>
<p>
Pablo: Yes, but given the "zero, if the conversion function fails to convert the entire field", we are requiring every error condition to store.
</p>
<p>
Bill: When did this happen?
</p>
<p>
Alisdair: One of the last two or three meetings.
</p>
<p>
Dietmar: To store a value in case of failure is a very bad idea.
</p>
<p>
Move to Open, needs more study.
</p>
</blockquote>

<p><i>[2011-03-24 Madrid meeting]</i></p>


<p>Move to deferred</p>


<p><b>Proposed resolution:</b></p>

<p>
Change 22.4.2.1.2 [facet.num.get.virtuals] as follows:
</p>
<blockquote>
<p>
<b>Stage 3:</b>
The sequence of <code>char</code>s accumulated in stage 2 (the field) is
converted to a numeric value by the rules of one of the functions declared in
the header <code>&lt;cstdlib&gt;</code>:
</p>
<ul>
<li>For a signed integer value, the function <code>strtoll</code>.</li>
<li>For an unsigned integer value, the function <code>strtoull</code>.</li>
<li><ins>For a <code>float</code> value, the function
    <code>strtof</code>.</ins></li>
<li><ins>For a <code>double</code> value, the function
    <code>strtod</code>.</ins></li>
<li>For a <del>floating-point</del> <ins><code>long double</code></ins>
    value, the function <code>strtold</code>.</li>
</ul>
<p>
The numeric value to be stored can be one of:
</p>
<ul>
<li>zero, if the conversion function fails to convert the entire field.
    <del><code>ios_base::failbit</code> is assigned to <code>err</code>.</del></li>
<li>the most positive <ins>(or negative)</ins> representable value, if
    the field <ins>to be converted to a signed integer type</ins> represents a
    value too large positive <ins>(or negative)</ins> to be represented in
    <code>val</code>.
    <del><code>ios_base::failbit</code> is assigned to <code>err</code>.</del></li>
<li><del>the most negative representable value or zero for an unsigned integer
    type, if the field represents a value too large negative to be represented
    in <code>val</code>.
    <code>ios_base::failbit</code> is assigned to <code>err</code>.</del></li>
<li><ins>the most positive representable value, if the field to be converted to
    an unsigned integer type represents a value that cannot be represented in
    <code>val</code>.</ins></li>
<li>the converted value, otherwise.</li>
</ul>
<p>
The resultant numeric value is stored in <code>val</code>.
<ins>If the conversion function fails to convert the entire field, or if the
field represents a value outside the range of representable values,
<code>ios_base::failbit</code> is assigned to <code>err</code>.</ins>
</p>
</blockquote>






<hr>
<h3><a name="1175"></a>1175. <tt>unordered</tt> complexity</h3>
<p><b>Section:</b> 23.2.5 [unord.req] <b>Status:</b> <a href="lwg-active.html#Deferred">Deferred</a>
 <b>Submitter:</b> Pablo Halpern <b>Opened:</b> 2009-07-17 <b>Last modified:</b> 2011-03-24</p>
<p><b>View other</b> <a href="lwg-index-open.html#unord.req">active issues</a> in [unord.req].</p>
<p><b>View all other</b> <a href="lwg-index.html#unord.req">issues</a> in [unord.req].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Deferred">Deferred</a> status.</p>
<p><b>Discussion:</b></p>
<p>
When I look at the <tt>unordered_*</tt> constructors, I think the complexity is poorly
described and does not follow the style of the rest of the standard.
</p>

<p>
The complexity for the default constructor is specified as constant.
Actually, it is proportional to <tt>n</tt>, but there are no invocations of
<tt>value_type</tt> constructors or other <tt>value_type</tt> operations.
</p>

<p>
For the iterator-based constructor the complexity should be:
</p>

<blockquote><p>
<i>Complexity:</i> exactly <tt>n</tt> calls to construct <tt>value_type</tt>
from <tt>InputIterator::value_type</tt> (where <tt>n = distance(f,l)</tt>).
The number of calls to <tt>key_equal::operator()</tt> is proportional to
<tt>n</tt> in the average case and <tt>n*n</tt> in the worst case.
</p></blockquote>



<p><i>[
2010 Rapperswil:
]</i></p>


<blockquote><p>
Concern that the current wording may require O(1) where that cannot be delivered.  We need to look at 
both the clause 23 requirements tables and the constructor description of each unordered container to be sure.
</p>
<p>
Howard suggests NAD Editorial as we updated the container requirement tables since this issue was written.
</p>
<p>
Daniel offers to look deeper, and hopefully produce wording addressing any outstanding concerns at the next meeting.
</p>
<p>
Move to Open.
</p>
</blockquote>

<p><i>[2011-02-26: Daniel provides wording]</i></p>


<p>I strongly suggest to clean-up the differences between requirement tables and individual
specifications. In the usual way, the most specific specifications wins, which is in this
case the wrong one. In regard to the concern expressed about missing <tt>DefaultConstructible</tt>
requirements of the value type I disagree: The function argument <tt>n</tt> is no size-control
parameter, but only some effective capacity parameter: No elements will be value-initialized
by these constructors. The necessary requirement for the value type, <tt>EmplaceConstructible</tt>
into <tt>*this</tt>, is already listed in Table 103 &mdash; Unordered associative container requirements.
Another part of the proposed resolution is the fact that there is an inconsistency of the
complexity counting when both a range <strong>and</strong> a bucket count is involved compared
to constructions where only bucket counts are provided: E.g. the construction <tt>X a(n);</tt>
has a complexity of <tt>n</tt> bucket allocations, but this part of the work is omitted for
<tt>X a(i, j, n);</tt>, even though it is considerable larger (in the average case) for 
<tt>n &#8811; distance(i, j)</tt>.
</p>

<p><i>[2011-03-24 Madrid meeting]</i></p>


<p>Move to deferred</p>



<p><b>Proposed resolution:</b></p>
<ol>
<li><p>Modify the following rows in Table 103 &mdash; Unordered associative container requirements to
add the explicit bucket allocation overhead of some constructions. As editorial recommendation it is 
suggested <em>not</em> to shorten the sum <tt>&#x1d4aa;(n) + &#x1d4aa;(<em>N</em>)</tt> to
<tt>&#x1d4aa;(n + <em>N</em>)</tt>, because two different work units are involved.</p>

<blockquote>
<table border="1">
<caption>Table 103 &mdash; Unordered associative container requirements (in addition to container)</caption>

<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&frasl;note pre-&frasl;post-condition</th>
<th>Complexity</th>
</tr>

<tr>
<td colspan="4" style="text-align:center;">&hellip;</td>
</tr>

<tr>
<td><tt>X(i, j, n, hf, eq)</tt><br/>
<tt>X a(i, j, n, hf, eq)</tt>
</td>
<td><tt>X</tt></td>
<td>&hellip;<br/>
<i>Effects</i>: Constructs an empty container with at least <tt>n</tt><br/>
buckets, using <tt>hf</tt> as the hash function and <tt>eq</tt> as the key<br/>
equality predicate, and inserts elements from <tt>[i, j)</tt> into it.
</td>
<td>Average case <ins>&#x1d4aa;(<tt>n</tt>) +</ins> &#x1d4aa;(<tt><i>N</i></tt>) (<tt><i>N</i></tt> is <tt>distance(i, j)</tt>),<br/>
worst case <ins>&#x1d4aa;(<tt>n</tt>) +</ins> &#x1d4aa;(<tt><i>N</i><sup>2</sup></tt>)</td>
</tr>

<tr>
<td><tt>X(i, j, n, hf)</tt><br/>
<tt>X a(i, j, n, hf)</tt>
</td>
<td><tt>X</tt></td>
<td>&hellip;<br/>
<i>Effects</i>: Constructs an empty container with at least <tt>n</tt><br/>
buckets, using <tt>hf</tt> as the hash function and <tt>key_equal()</tt> as the key<br/>
equality predicate, and inserts elements from <tt>[i, j)</tt> into it.
</td>
<td>Average case <ins>&#x1d4aa;(<tt>n</tt>) +</ins> &#x1d4aa;(<tt><i>N</i></tt>) (<tt><i>N</i></tt> is <tt>distance(i, j)</tt>),<br/>
worst case <ins>&#x1d4aa;(<tt>n</tt>) +</ins> &#x1d4aa;(<tt><i>N</i><sup>2</sup></tt>)</td>
</tr>

<tr>
<td><tt>X(i, j, n)</tt><br/>
<tt>X a(i, j, n)</tt>
</td>
<td><tt>X</tt></td>
<td>&hellip;<br/>
<i>Effects</i>: Constructs an empty container with at least <tt>n</tt><br/>
buckets, using <tt>hasher()</tt> as the hash function and <tt>key_equal()</tt> as the key<br/>
equality predicate, and inserts elements from <tt>[i, j)</tt> into it.
</td>
<td>Average case <ins>&#x1d4aa;(<tt>n</tt>) +</ins> &#x1d4aa;(<tt><i>N</i></tt>) (<tt><i>N</i></tt> is <tt>distance(i, j)</tt>),<br/>
worst case <ins>&#x1d4aa;(<tt>n</tt>) +</ins> &#x1d4aa;(<tt><i>N</i><sup>2</sup></tt>)</td>
</tr>

<tr>
<td colspan="4" style="text-align:center;">&hellip;</td>
</tr>

</table>
</blockquote>

</li>

<li><p>Modify 23.5.4.2 [unord.map.cnstr] p. 1-4 as indicated (The edits of p. 1 and p. 3 attempt to fix some
editorial oversight.):</p>

<blockquote><pre>
explicit unordered_map(size_type n = <i>see below</i>,
                       const hasher&amp; hf = hasher(),
                       const key_equal&amp; eql = key_equal(),
                       const allocator_type&amp; a = allocator_type());
</pre><blockquote><p>
1 <i>Effects</i>: Constructs an empty <tt>unordered_map</tt> using the specified hash function, key equality function,
and allocator, and using at least <tt>n</tt> buckets. If <tt>n</tt> is not provided, the number of buckets is 
<ins>implementation-defined</ins><del>impldefdefault number of buckets in <tt>unordered_map</tt></del>. 
<tt>max_load_factor()</tt> returns <tt>1.0</tt>.
</p></blockquote>
<blockquote><p>
2 <i>Complexity</i>: Constant <ins>if <tt>n</tt> is not provided, otherwise linear in <tt>n</tt> to construct the buckets</ins>.
</p></blockquote>
</blockquote>

<blockquote><pre>
template &lt;class InputIterator&gt;
unordered_map(InputIterator f, InputIterator l,
              size_type n = <i>see below</i>,
              const hasher&amp; hf = hasher(),
              const key_equal&amp; eql = key_equal(),
              const allocator_type&amp; a = allocator_type());
</pre><blockquote><p>
3 <i>Effects</i>: Constructs an empty <tt>unordered_map</tt> using the specified hash function, key equality function,
and allocator, and using at least <tt>n</tt> buckets. If <tt>n</tt> is not provided, the number of buckets is 
<ins>implementation-defined</ins><del>impldefdefault number of buckets in <tt>unordered_map</tt></del>.
Then inserts elements from the range <tt>[f, l)</tt>. <tt>max_load_factor()</tt> returns <tt>1.0</tt>.
</p></blockquote>
<blockquote><p>
4 <i>Complexity</i>: <del>Average case linear, worst case quadratic</del><ins>Constant if <tt>n</tt> is not 
provided, else linear in <tt>n</tt> to construct the buckets. In the average case linear in <tt><i>N</i></tt> 
and in the worst case quadratic in <tt><i>N</i></tt> to insert the elements, where <tt><i>N</i></tt> is equal to 
<tt>distance(f, l)</tt></ins>.
</p></blockquote>
</blockquote>
</li>

<li><p>Modify 23.5.5.2 [unord.multimap.cnstr] p. 1-4 as indicated (The edits of p. 1 and p. 3 attempt to fix some
editorial oversight.):</p>

<blockquote><pre>
explicit unordered_multimap(size_type n = <i>see below</i>,
                            const hasher&amp; hf = hasher(),
                            const key_equal&amp; eql = key_equal(),
                            const allocator_type&amp; a = allocator_type());
</pre><blockquote><p>
1 <i>Effects</i>: Constructs an empty <tt>unordered_multimap</tt> using the specified hash function, key equality function,
and allocator, and using at least <tt>n</tt> buckets. If <tt>n</tt> is not provided, the number of buckets is 
<ins>implementation-defined</ins><del>impldefdefault number of buckets in <tt>unordered_multimap</tt></del>. 
<tt>max_load_factor()</tt> returns <tt>1.0</tt>.
</p></blockquote>
<blockquote><p>
2 <i>Complexity</i>: Constant <ins>if <tt>n</tt> is not provided, otherwise linear in <tt>n</tt> to construct the buckets</ins>.
</p></blockquote>
</blockquote>

<blockquote><pre>
template &lt;class InputIterator&gt;
unordered_multimap(InputIterator f, InputIterator l,
                   size_type n = <i>see below</i>,
                   const hasher&amp; hf = hasher(),
                   const key_equal&amp; eql = key_equal(),
                   const allocator_type&amp; a = allocator_type());
</pre><blockquote><p>
3 <i>Effects</i>: Constructs an empty <tt>unordered_multimap</tt> using the specified hash function, key equality function,
and allocator, and using at least <tt>n</tt> buckets. If <tt>n</tt> is not provided, the number of buckets is 
<ins>implementation-defined</ins><del>impldefdefault number of buckets in <tt>unordered_multimap</tt></del>.
Then inserts elements from the range <tt>[f, l)</tt>. <tt>max_load_factor()</tt> returns <tt>1.0</tt>.
</p></blockquote>
<blockquote><p>
4 <i>Complexity</i>: <del>Average case linear, worst case quadratic</del><ins>Constant if <tt>n</tt> is not 
provided, else linear in <tt>n</tt> to construct the buckets. In the average case linear in <tt><i>N</i></tt> 
and in the worst case quadratic in <tt><i>N</i></tt> to insert the elements, where <tt><i>N</i></tt> is equal to 
<tt>distance(f, l)</tt></ins>.
</p></blockquote>
</blockquote>
</li>

<li><p>Modify 23.5.6.2 [unord.set.cnstr] p. 1-4 as indicated (The edits of p. 1 and p. 3 attempt to fix some
editorial oversight.):</p>

<blockquote><pre>
explicit unordered_set(size_type n = <i>see below</i>,
                       const hasher&amp; hf = hasher(),
                       const key_equal&amp; eql = key_equal(),
                       const allocator_type&amp; a = allocator_type());
</pre><blockquote><p>
1 <i>Effects</i>: Constructs an empty <tt>unordered_set</tt> using the specified hash function, key equality function,
and allocator, and using at least <tt>n</tt> buckets. If <tt>n</tt> is not provided, the number of buckets is 
<ins>implementation-defined</ins><del>impldefdefault number of buckets in <tt>unordered_set</tt></del>. 
<tt>max_load_factor()</tt> returns <tt>1.0</tt>.
</p></blockquote>
<blockquote><p>
2 <i>Complexity</i>: Constant <ins>if <tt>n</tt> is not provided, otherwise linear in <tt>n</tt> to construct the buckets</ins>.
</p></blockquote>
</blockquote>

<blockquote><pre>
template &lt;class InputIterator&gt;
unordered_set(InputIterator f, InputIterator l,
              size_type n = <i>see below</i>,
              const hasher&amp; hf = hasher(),
              const key_equal&amp; eql = key_equal(),
              const allocator_type&amp; a = allocator_type());
</pre><blockquote><p>
3 <i>Effects</i>: Constructs an empty <tt>unordered_set</tt> using the specified hash function, key equality function,
and allocator, and using at least <tt>n</tt> buckets. If <tt>n</tt> is not provided, the number of buckets is 
<ins>implementation-defined</ins><del>impldefdefault number of buckets in <tt>unordered_set</tt></del>.
Then inserts elements from the range <tt>[f, l)</tt>. <tt>max_load_factor()</tt> returns <tt>1.0</tt>.
</p></blockquote>
<blockquote><p>
4 <i>Complexity</i>: <del>Average case linear, worst case quadratic</del><ins>Constant if <tt>n</tt> is not 
provided, else linear in <tt>n</tt> to construct the buckets. In the average case linear in <tt><i>N</i></tt> 
and in the worst case quadratic in <tt><i>N</i></tt> to insert the elements, where <tt><i>N</i></tt> is equal to 
<tt>distance(f, l)</tt></ins>.
</p></blockquote>
</blockquote>
</li>

<li><p>Modify 23.5.7.2 [unord.multiset.cnstr] p. 1-4 as indicated (The edits of p. 1 and p. 3 attempt to fix some
editorial oversight.):</p>

<blockquote><pre>
explicit unordered_multiset(size_type n = <i>see below</i>,
                            const hasher&amp; hf = hasher(),
                            const key_equal&amp; eql = key_equal(),
                            const allocator_type&amp; a = allocator_type());
</pre><blockquote><p>
1 <i>Effects</i>: Constructs an empty <tt>unordered_multiset</tt> using the specified hash function, key equality function,
and allocator, and using at least <tt>n</tt> buckets. If <tt>n</tt> is not provided, the number of buckets is 
<ins>implementation-defined</ins><del>impldefdefault number of buckets in <tt>unordered_multiset</tt></del>. 
<tt>max_load_factor()</tt> returns <tt>1.0</tt>.
</p></blockquote>
<blockquote><p>
2 <i>Complexity</i>: Constant <ins>if <tt>n</tt> is not provided, otherwise linear in <tt>n</tt> to construct the buckets</ins>.
</p></blockquote>
</blockquote>

<blockquote><pre>
template &lt;class InputIterator&gt;
unordered_multiset(InputIterator f, InputIterator l,
                   size_type n = <i>see below</i>,
                   const hasher&amp; hf = hasher(),
                   const key_equal&amp; eql = key_equal(),
                   const allocator_type&amp; a = allocator_type());
</pre><blockquote><p>
3 <i>Effects</i>: Constructs an empty <tt>unordered_multiset</tt> using the specified hash function, key equality function,
and allocator, and using at least <tt>n</tt> buckets. If <tt>n</tt> is not provided, the number of buckets is 
<ins>implementation-defined</ins><del>impldefdefault number of buckets in <tt>unordered_multiset</tt></del>.
Then inserts elements from the range <tt>[f, l)</tt>. <tt>max_load_factor()</tt> returns <tt>1.0</tt>.
</p></blockquote>
<blockquote><p>
4 <i>Complexity</i>: <del>Average case linear, worst case quadratic</del><ins>Constant if <tt>n</tt> is not 
provided, else linear in <tt>n</tt> to construct the buckets. In the average case linear in <tt><i>N</i></tt> 
and in the worst case quadratic in <tt><i>N</i></tt> to insert the elements, where <tt><i>N</i></tt> is equal to 
<tt>distance(f, l)</tt></ins>.
</p></blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="1213"></a>1213. Meaning of valid and singular iterator underspecified</h3>
<p><b>Section:</b> 24.2 [iterator.requirements] <b>Status:</b> <a href="lwg-active.html#Deferred">Deferred</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2009-09-19 <b>Last modified:</b> 2011-02-20</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.requirements">issues</a> in [iterator.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Deferred">Deferred</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The terms <em>valid</em> iterator and <em>singular</em> aren't
properly defined. The fuzziness of those terms became even worse
after the resolution of <a href="lwg-defects.html#208">208</a> (including further updates by <a href="lwg-defects.html#278">278</a>). In
24.2 [iterator.requirements] as of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf">N2723</a>
the standard says now:
</p>

<blockquote>
<p>
5 - These values are called past-the-end values. Values of an iterator <tt>i</tt> for
which the expression <tt>*i</tt> is defined are called dereferenceable. The library
never assumes that past-the-end values are dereferenceable. Iterators
can also have singular values that are not associated with any
container. [...] Results of most expressions are undefined for singular
values; the only exceptions are destroying an iterator that holds a
singular value and the assignment of a non-singular value to an iterator
that holds a singular value. [...] Dereferenceable values are always
non-singular.
</p>

<p>
10 - An invalid iterator is an iterator that may be singular.
</p>
</blockquote>

<p>
First, issue <a href="lwg-defects.html#208">208</a> intentionally removed the earlier constraint that past-the-end
values are always non-singular. The reason for this was to support null
pointers as past-the-end iterators of e.g. empty sequences. But there
seem to exist different views on what a singular (iterator) value is. E.g.
according to the <a href="http://www.sgi.com/tech/stl/trivial.html">SGI definition</a>
a null pointer is <em>not</em> a singular value:
</p>

<blockquote><p>
Dereferenceable iterators are always nonsingular, but the converse is
not true.
For example, a null pointer is nonsingular (there are well defined operations
involving null pointers) even thought it is not dereferenceable.
</p></blockquote>

<p>
and <a href="http://www.sgi.com/tech/stl/InputIterator.html">proceeds</a>:
</p>

<blockquote><p>
An iterator is valid if it is dereferenceable or past-the-end.
</p></blockquote>

<p>
Even if the standard prefers a different meaning of singular here, the
change was incomplete, because by restricting feasible expressions of singular
iterators to destruction and assignment isn't sufficient for a past-the-end
iterator: Of-course it must still be equality-comparable and in general be a readable value.
</p>

<p>
Second, the standard doesn't clearly say whether a past-the-end value is
a valid iterator or not. E.g. 20.6.12 [specialized.algorithms]/1 says:
</p>

<blockquote><p>
In all of the following algorithms, the formal template parameter <tt>ForwardIterator</tt> 
is required to satisfy the requirements of a forward iterator (24.1.3)
[..], and is required to have the property that no exceptions are thrown from [..], or
dereference of valid iterators.
</p></blockquote>

<p>
The standard should make better clear what "singular pointer" and "valid
iterator" means. The fact that the meaning of a valid <em>value</em>
has a core language meaning doesn't imply that for an iterator concept
the term "valid iterator" has the same meaning.
</p>

<p>
Let me add a final example: In X [allocator.concepts.members] of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2914.pdf">N2914</a>
we find:
</p>

<blockquote><pre>
pointer X::allocate(size_type n);
</pre>

<blockquote><p>
11 <i>Returns:</i> a pointer to the allocated memory. [<i>Note:</i> if <tt>n == 0</tt>, the return
value is unspecified. &mdash;<i>end note</i>]
</p></blockquote>

<p>
[..]
</p>

<pre>
void X::deallocate(pointer p, size_type n);
</pre>

<blockquote><p>
<i>Preconditions:</i> <tt>p</tt> shall be a non-singular pointer value obtained from a call
to <tt>allocate()</tt> on this allocator or one that compares equal to it.
</p></blockquote>
</blockquote>

<p>
If singular pointer value would include null pointers this make the
preconditions
unclear if the pointer value is a result of <tt>allocate(0)</tt>: Since the return value
is unspecified, it could be a null pointer. Does that mean that programmers
need to check the pointer value for a null value before calling deallocate?
</p>

<p><i>[
2010-11-09 Daniel comments:
]</i></p>


<p>
A later paper is in preparation.
</p>

<p><i>[
2010 Batavia:
]</i></p>


<p>
Doesn't need to be resolved for Ox
</p>


<p><b>Proposed resolution:</b></p>
<p>
Consider to await the paper.
</p>





<hr>
<h3><a name="1214"></a>1214. Insufficient/inconsistent key immutability requirements for  associative containers</h3>
<p><b>Section:</b> 23.2.4 [associative.reqmts] <b>Status:</b> <a href="lwg-active.html#Deferred">Deferred</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2009-09-20 <b>Last modified:</b> 2011-02-20</p>
<p><b>View other</b> <a href="lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Deferred">Deferred</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Scott Meyers' mentions on a recent posting on <a
href="http://groups.google.de/group/comp.std.c++/msg/6f9160fc428bcbea">c.s.c++</a>
some arguments that point to an incomplete resolution
of <a href="lwg-defects.html#103">103</a> and to an inconsistency of requirements on keys in ordered and
unordered associative
containers:
</p>

<blockquote>
<p>
1) <a href="lwg-defects.html#103">103</a> introduced the term immutable without defining it in a unique manner in
23.2.4 [associative.reqmts]/5:
</p>

<blockquote><p>
[..] Keys in an associative container are immutable.
</p></blockquote>

<p>
According to conventional dictionaries immutable is an unconditional way of
saying that something cannot be changed. So without any further explicit
allowance a user <em>always</em> runs into undefined behavior if (s)he attempts
to modify such a key. IMO this was not the intend of the committee to resolve
<a href="lwg-defects.html#103">103</a> in that way because the comments suggest an interpretation that
should give any user the freedom to modify the key in an <em>explicit</em> way
<em>provided</em> it would not affect the sort order in that container.
</p>

<p>
2) Another observation was that surprisingly no similar 'safety guards'
exists against unintentional key changes for the unordered associative
containers, specifically there is no such requirement as in
23.2.4 [associative.reqmts]/6 that "both <tt>iterator</tt> and <tt>const_iterator</tt> are constant
iterators". But the need for such protection against unintentional
changes as well as the constraints in which manner any explicit
changes may be performed are both missing and necessary, because
such changes could potentially change the <em>equivalence</em> of keys that
is measured by the <tt>hasher</tt> and <tt>key_equal</tt>.
</p>

<p>
I suggest to fix the unconditional wording involved with "immutable keys"
by at least adding a hint for the reader that users <em>may</em> perform such
changes in an explicit manner <em>and</em> to perform similar wording changes
as <a href="lwg-defects.html#103">103</a> did for the ordered associative containers also for the unordered
containers.
</p>
</blockquote>

<p><i>[
2010-03-27 Daniel provides wording.
]</i></p>


<blockquote><p>
This update attempts to provide normative wording that harmonizes the key and
function object constraints of associative and unordered containers.
</p></blockquote>

<p><i>[
2010 Batavia:
]</i></p>


<p>
We're uncomfortable with the first agenda item, and we can live with the second agenda 
item being applied before or after Madrid. 
</p>


<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
Change 23.2.4 [associative.reqmts]/2 as indicated: <i>[This ensures that
associative containers make better clear what this "arbitrary" type is, as the
unordered containers do in 23.2.5 [unord.req]/3]</i>
</p>

<blockquote><p>
2 Each associative container is parameterized on <tt>Key</tt> and an ordering
relation <tt>Compare</tt> that induces a strict weak ordering (25.4) on elements
of <tt>Key</tt>. In addition, <tt>map</tt> and <tt>multimap</tt> associate an
arbitrary <ins><em>mapped type</em></ins><del>type</del> <tt>T</tt> with the
<tt>Key</tt>. The object of type <tt>Compare</tt> is called the <em>comparison
object</em> of a container.
</p></blockquote>
</li>

<li>
<p>
Change 23.2.4 [associative.reqmts]/5 as indicated: <i>[This removes the
too strong requirement that keys must not be changed at all and brings this line
in sync with 23.2.5 [unord.req]/7. We take care about the real
constraints by the remaining suggested changes. The rationale provided by LWG
<a href="lwg-defects.html#103">103</a> didn't really argue why that addition is necessary, and I
believe the remaining additions make it clear that any user changes have strong
restrictions]</i>:
</p>

<blockquote><p>
5 For <tt>set</tt> and <tt>multiset</tt> the value type is the same as the key
type. For <tt>map</tt> and <tt>multimap</tt> it is equal to <tt>pair&lt;const
Key, T&gt;</tt>. <del>Keys in an associative container are immutable.</del>
</p></blockquote>
</li>

<li>
<p>
Change 23.2.5 [unord.req]/3+4 as indicated: <i>[The current sentence of
p.4 has doesn't say something really new and this whole subclause misses to
define the concepts of the container-specific hasher <i>object</i> and predicate
<i>object</i>. We introduce the term <em>key equality predicate</em> which is
already used in the requirements table. This change does not really correct part
of this issue, but is recommended to better clarify the nomenclature and the
difference between the function objects and the function object <em>types</em>,
which is important, because both can potentially be stateful.]</i>
</p>

<blockquote>
<p>
3 Each unordered associative container is parameterized by <tt>Key</tt>, by a
function object type <tt>Hash</tt> that meets the <tt>Hash</tt> requirements
(20.2.4) and acts as a hash function for argument values of type <tt>Key</tt>,
and by a binary predicate <tt>Pred</tt> that induces an equivalence relation on
values of type <tt>Key</tt>. Additionally, <tt>unordered_map</tt> and
<tt>unordered_multimap</tt> associate an arbitrary <em>mapped type</em>
<tt>T</tt> with the <tt>Key</tt>.
</p>

<p>
4 <ins>The container's object of type <tt>Hash</tt> - denoted by
<tt>hash</tt> - is called the <em>hash function</em> of the container.
The container's object of type <tt>Pred</tt> - denoted by
<tt>pred</tt> - is called the <em>key equality predicate</em> of the
container.</ins><del>A hash function is a function object that takes a single
argument of type <tt>Key</tt> and returns a value of type
<tt>std::size_t</tt></del>.
</p>
</blockquote>
</li>

<li>
<p>
Change 23.2.5 [unord.req]/5 as indicated: <i>[This adds a similar
safe-guard as the last sentence of 23.2.4 [associative.reqmts]/3]</i>
</p>

<blockquote><p>
5 Two values <tt>k1</tt> and <tt>k2</tt> of type <tt>Key</tt> are considered
equivalent if the container's <ins>key equality
predicate</ins><del><tt>key_equal</tt> function object</del> returns
<tt>true</tt> when passed those values. If <tt>k1</tt> and <tt>k2</tt> are
equivalent, the <ins>container's</ins> hash function shall return the same value
for both. [<i>Note:</i> thus, when an unordered associative container is
instantiated with a non-default <tt>Pred</tt> parameter it usually needs a
non-default <tt>Hash</tt> parameter as well. &mdash; <i>end note</i>] <ins>For
any two keys <tt>k1</tt> and <tt>k2</tt> in the same container, calling
<tt>pred(k1, k2)</tt> shall always return the same value. For any key <tt>k</tt>
in a container, calling <tt>hash(k)</tt> shall always return the same
value.</ins>
</p></blockquote>
</li>

<li>
<p>
After 23.2.5 [unord.req]/7 add the following new paragraph: <i>[This
ensures the same level of compile-time protection that we already require for
associative containers. It is necessary for similar reasons, because any change
in the stored key which would change it's equality relation to others or would
change it's hash value such that it would no longer fall in the same bucket,
would break the container invariants]</i>
</p>

<blockquote>
<p>
7 For <tt>unordered_set</tt> and <tt>unordered_multiset</tt> the value type is
the same as the key type. For <tt>unordered_map</tt> and
<tt>unordered_multimap</tt> it is <tt>std::pair&lt;const Key, T&gt;</tt>.
</p>
<p>
<ins>For unordered containers where the value type is the same as the key type,
both <tt>iterator</tt> and <tt>const_iterator</tt> are constant iterators. It is
unspecified whether or not <tt>iterator</tt> and <tt>const_iterator</tt> are the
same type. [<i>Note:</i> <tt>iterator</tt> and <tt>const_iterator</tt> have
identical semantics in this case, and <tt>iterator</tt> is convertible to
<tt>const_iterator</tt>. Users can avoid violating the One Definition Rule by
always using <tt>const_iterator</tt> in their function parameter lists. &mdash;
<i>end note</i>]</ins>
</p>
</blockquote>
</li>

</ol>






<hr>
<h3><a name="1330"></a>1330. Move container requirements into requirements tables</h3>
<p><b>Section:</b> 23.2 [container.requirements] <b>Status:</b> <a href="lwg-active.html#Deferred">Deferred</a>
 <b>Submitter:</b> Nicolai Josuttis <b>Opened:</b> 2010-03-10 <b>Last modified:</b> 2010-11-16</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements">issues</a> in [container.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Deferred">Deferred</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Abstract:
</p>
<p>
In general, it seems that in a couple of places container behavior is
not described in requirement tables although it is a general behavior.
</p>

<p>
History:
</p>

<p>
Issue <a href="lwg-defects.html#676">676</a> added move semantics to unordered containers.
For the added insert functions the Editor requested to put their
semantic description into a requirements table rather than describing
them for each container individually. The text however was taken from
the associative containers, where we also have the semantics for each
container described. Also, <a href="lwg-defects.html#1034">1034</a> is to some extend
requesting a clarification of the requirement tables and it turned out
that in other places we have the same problem (e.g. we have no general
requirement for type pointer and const_pointer although each container
has them with issue <a href="lwg-defects.html#1306">1306</a>).
</p>

<p>
From my personal list of functions in requirement tables
and containers, the following types/functions are missing in
requirement tables:
</p>

<ul>
<li>
<tt>pointer</tt>, <tt>const_pointer</tt> in Table 91 (container requirements)
</li>
<li>
<p>
all copy constructors, copy constructors with allocator,
 assignment operators, and insert operators
 with move semantics for associative and unordered containers
</p>
<blockquote><pre>
ContType c1(c2&amp;&amp;)
ContType c1(c2&amp;&amp;,alloc)
c1 = c2&amp;&amp;
c.insert(val&amp;&amp;)
c.insert(pos,val&amp;&amp;)
</pre></blockquote>
</li>
</ul>

<p>
As a special case, we lack the following requirements for all sequence
containers BUT array (so special wording or a new container category is
required):
</p>

<ul>
<li>
<p>
constructor with only a size argument
</p>
<blockquote><pre>
ContType c(num)
</pre></blockquote>
</li>
<li>
<p>
copy constructor with allocator and move semantics
</p>
<blockquote><pre>
ContType c1(c2&amp;&amp;,alloc)
</pre></blockquote>
</li>
<li>
<p>
all constructors that insert multiple elements with additional allocator
</p>
<blockquote><pre>
ContType c(num, val,alloc)
ContType c(beg, end,alloc)
ContType c(initlist,alloc)
</pre></blockquote>
</li>
<li>
<p>
all resize functiuons:
</p>
<blockquote><pre>
c.resize(num)
c.resize(num,val)
</pre></blockquote>
</li>
</ul>

<p>
Note that we also might have to add additional requirements on other
places for sequence containers because having an allocator requires
additional statements for the treatment of the allocators. E.g. swap for
containers with allocators is not specified in any requirement table.
</p>

<p>
And finally, if we have the requirements in the requirements tables, we
can remove the corresponding descriptions for the individual container.
However, note that sequence container requirements have NO complexity
column, so that we still need container specific descriptions for the
functions listed there.
</p>

<p><i>[
2010 Batavia
]</i></p>

<p>
While there is consensus that further cleaning up the container requirement
tables would be a good thing, there is no feeling that this <em>must</em>
be done in time for 0x.  The issue remains open, but Deferred.
</p>




<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1364"></a>1364. [FCD] It is not clear how <tt>exception_ptr</tt> is synchronized</h3>
<p><b>Section:</b> 18.8.5 [propagation] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Switzerland <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2011-03-08</p>
<p><b>View all other</b> <a href="lwg-index.html#propagation">issues</a> in [propagation].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses CH-19</b></p>
<p>
It is not clear how <tt>exception_ptr</tt> is synchronized.
</p>

<p><i>[
Resolution proposed by ballot comment
]</i></p>

<p>
Make clear that accessing in different threads
multiple <tt>exception_ptr</tt> objects that all refer to the
same exception introduce a race.
</p>

<p><i>[2011-03-08: Lawrence comments and drafts wording]</i></p>


<p>I think fundamentally, this issue is NAD, but clarification would not hurt.</p>



<p><b>Proposed resolution:</b></p>
<p>Add a new paragraph to 18.8.5 [propagation] after paragraph 6 as follows:</p>

<p><ins>
[<i>Note:</i> Exception objects have no synchronization requirements, and expressions 
using them may conflict (1.10 [intro.multithread]). &mdash; <i>end note</i>]
</ins></p>





<hr>
<h3><a name="1450"></a>1450. [FCD] Contradiction in regex_constants</h3>
<p><b>Section:</b> 28.5.2 [re.matchflag] <b>Status:</b> <a href="lwg-active.html#Deferred">Deferred</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2011-02-20</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Deferred">Deferred</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-127</b></p>

<p>
The Bitmask Type requirements in 17.5.2.1.3 [bitmask.types] p.3 say that
all elements on a bitmask type have distinct values, but
28.5.2 [re.matchflag] defines <tt>regex_constants::match_default</tt> and
<tt>regex_constants::format_default</tt> as elements of the
bitmask type <tt>regex_constants::match_flag_type</tt>, both with
value 0. This is a contradiction.
</p>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote><p>
One of the bitmask elements should be removed
from the declaration and should be defined
separately, in the same manner as
<tt>ios_base::adjustfield</tt>, <tt>ios_base::basefield</tt> and
<tt>ios_base::floatfield</tt> are defined by 27.5.3.1.2 [ios::fmtflags] p.2
and Table 120. These are constants of a bitmask
type, but are not distinct elements, they have
more than one value set in the bitmask.
<tt>regex_constants::format_default</tt> should be
specified as a constant with the same value as
<tt>regex_constants::match_default</tt>.
</p></blockquote>

<p><i>[
2010-10-31 Daniel comments:
]</i></p>

<p>
Strictly speaking, a bitmask type cannot have any element of value 0 at all, because
any such value would contradict the requirement expressed in 17.5.2.1.3 [bitmask.types] p. 3:
</p>
<blockquote><p>
for any pair <em>Ci</em> and <em>Cj</em>, <em>Ci</em> &amp; <em>Ci</em> is nonzero
</p></blockquote>
<p>
So, actually <em>both</em> <tt>regex_constants::match_default</tt> and
<tt>regex_constants::format_default</tt> are only constants of the type
<tt>regex_constants::match_flag_type</tt>, and no bitmask elements.
</p>

<p><i>[
2010-11-03 Daniel comments and provides a proposed resolution:
]</i></p>


<p>The proposed resolution is written against N3126 and considered as a further improvement
of the fixes suggested by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3110.html">n3110</a>.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add the following sentence to 28.5.2 [re.matchflag]  paragraph 1:
</p>
<blockquote><p>
1 The type <tt>regex_constants::match_flag_type</tt> is an implementation-defined bitmask type (17.5.2.1.3).
Matching a regular expression against a sequence of characters [first,last) proceeds according to the
rules of the grammar specified for the regular expression object, modified according to the effects listed in
Table 136 for any bitmask elements set. <ins>Type <tt>regex_constants::match_flag_type</tt> also defines the 
constants <tt>regex_constants::match_default</tt> and <tt>regex_constants::format_default</tt>.</ins>
</p></blockquote>





<hr>
<h3><a name="1456"></a>1456. [FCD] Missing fixed-size <tt>atomic_</tt> typedefs</h3>
<p><b>Section:</b> 29 [atomics] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2011-03-16</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics">active issues</a> in [atomics].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics">issues</a> in [atomics].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-129</b></p>
<p>
Table 143 lists the typedefs for various atomic types
corresponding to the various standard integer typedefs,
such as <tt>atomic_int_least8_t</tt> for <tt>int_least8_t</tt>, and
<tt>atomic_uint_fast64_t</tt> for <tt>uint_fast64_t</tt>. However, there are
no atomic typedefs corresponding to the fixed-size
standard typedefs <tt>int8_t</tt>, <tt>int16_t</tt>, and so forth.
</p>
<p><i>[
2010-10-24 Daniel adds:
]</i></p>


<blockquote><p>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3164.html">n3164</a> would solve this issue.
</p></blockquote>

<p><i>[
2011-02-15 Anthony corrects numbering/naming for N3225, Howard suggests improvement for the position
of '(optional)', Daniel reorders rows in harmony to remaining entries and suggests specific optionality
comments:
]</i></p>


<p><i>[2011-02-16 Reflector discussion]</i></p>

<p>
Moved to Tentatively Ready after 5 votes.
</p>

<p><i>[2011-03-16: Hans reopenes and comments]</i></p>


<p>WG14 briefly discussed LWG 1456. It turns out that they had previously made a conscious decision not to make a 
similar change. If C++ would deviate, this would introduce a C divergence.
<p/>
We should reopen the issue and, in my opinion, probably resolve it as NAD instead.  This is in a part of the standard 
that is there mostly for C compatibility, so introducing divergence here seems to make no sense.
</p>



<p><b>Proposed resolution:</b></p>
<p>
Add the following entries to table 143:
</p>
<blockquote>
<table border="1">
<caption>Table 146 &mdash; <tt>atomic</tt> <tt>&lt;inttypes.h&gt;</tt> typedefs</caption>
<tr>
<th>Atomic typedef</th>
<th><tt>&lt;inttypes.h&gt;</tt> type</th>
</tr>
<tr>
<td><tt>...</tt></td>
<td><tt>...</tt></td>
</tr>
<tr>
<td><tt>atomic_intmax_t</tt></td>
<td><tt>intmax_t</tt></td>
</tr>
<tr>
<td><tt>atomic_uintmax_t</tt></td>
<td><tt>uintmax_t</tt></td>
</tr>
<tr>
<td><ins><tt>atomic_int8_t&nbsp;</tt>// <em>iff <tt>int8_t</tt> is provided</em></ins></td>
<td><ins><tt>int8_t</tt></ins></td>
</tr>
<tr>
<td><ins><tt>atomic_uint8_t&nbsp;</tt>// <em>iff <tt>uint8_t</tt> is provided</em></ins></td>
<td><ins><tt>uint8_t</tt></ins></td>
</tr>
<tr>
<td><ins><tt>atomic_int16_t&nbsp;</tt>// <em>iff <tt>int16_t</tt> is provided</em></ins></td>
<td><ins><tt>int16_t</tt></ins></td>
</tr>
<tr>
<td><ins><tt>atomic_uint16_t&nbsp;</tt>// <em>iff <tt>uint16_t</tt> is provided</em></ins></td>
<td><ins><tt>uint16_t</tt></ins></td>
</tr>
<tr>
<td><ins><tt>atomic_int32_t&nbsp;</tt>// <em>iff <tt>int32_t</tt> is provided</em></ins></td>
<td><ins><tt>int32_t</tt></ins></td>
</tr>
<tr>
<td><ins><tt>atomic_uint32_t&nbsp;</tt>// <em>iff <tt>uint32_t</tt> is provided</em></ins></td>
<td><ins><tt>uint32_t</tt></ins></td>
</tr>
<tr>
<td><ins><tt>atomic_int64_t&nbsp;</tt>// <em>iff <tt>int64_t</tt> is provided</em></ins></td>
<td><ins><tt>int64_t</tt></ins></td>
</tr>
<tr>
<td><ins><tt>atomic_uint64_t&nbsp;</tt>// <em>iff <tt>uint64_t</tt> is provided</em></ins></td>
<td><ins><tt>uint64_t</tt></ins></td>
</tr>
</table>
</blockquote> 





<hr>
<h3><a name="1459"></a>1459. [FCD] Overlapping evaluations are allowed</h3>
<p><b>Section:</b> 29.3 [atomics.order] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Canada <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2011-03-09</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.order">active issues</a> in [atomics.order].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.order">issues</a> in [atomics.order].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Duplicate of:</b> <a href="lwg-closed.html#1458">1458</a></p>
<p><b>Discussion:</b></p>
<p><b>Addresses CA-21, GB-131</b></p>
<p>
29.4 [atomics.lockfree] p.8 states:
</p>
<blockquote><p>
An atomic store shall only store a value that has
been computed from constants and program input values
by a finite sequence of program evaluations, such
that each evaluation observes the values of variables
as computed by the last prior assignment in the
sequence.
</p></blockquote>
<p>
... but 1.9 [intro.execution] p.13 states:
</p>
<blockquote><p>
If A is not sequenced before B and B is not
sequenced before A, then A and B are unsequenced.
[ <em>Note</em>: The execution of unsequenced
evaluations can overlap. &mdash; <em>end note</em> ]
</p></blockquote>
<p>
Overlapping executions can make it impossible to
construct the sequence described in 29.4 [atomics.lockfree] p.8. We are not
sure of the intention here and do not offer a suggestion for
change, but note that 29.4 [atomics.lockfree] p.8 is the condition that prevents
out-of-thin-air reads.
</p>
<p>
For an example, suppose we have a function invocation
f(e1,e2). The evaluations of e1 and e2 can overlap.
Suppose that the evaluation of e1 writes y and reads x
whereas the evaluation of e2 reads y and writes x, with
reads-from edges as below (all this is within a single
thread).
</p>
<pre>
 e1           e2
Wrlx y--   --Wrlx x
      rf\ /rf
         X
        / \
Rrlx x&lt;-   -&gt;Rrlx y
</pre>
<p>
This seems like it should be allowed, but there seems to
be no way to produce a sequence of evaluations with the
property above.
</p>
<p>
In more detail, here the two evaluations, e1 and e2, are
being executed as the arguments of a function and are
consequently not sequenced-before each other. In
practice we'd expect that they could overlap (as allowed
by 1.9 [intro.execution] p.13), with the two writes taking effect before the two
reads. However, if we have to construct a linear order of
evaluations, as in 29.4 [atomics.lockfree] p.8, then the execution above is not
permited. Is that really intended?
</p>

<p><i>[
Resolution proposed by ballot comment
]</i></p>

<p>
Please clarify.
</p>

<p><i>[2011-03-09 Hans comments:]</i></p>


<p>I'm not proud of 29.3 [atomics.order] p9 (formerly p8), and I agree with the comments that this
isn't entirely satisfactory. 29.3 [atomics.order] p9 was designed to preclude
out-of-thin-air results for races among <tt>memory_order_relaxed</tt> atomics, in spite of 
the fact that Java experience has shown we don't really know how to do that adequately. In 
the long run, we probably want to revisit this.
<p/>
However, in the short term, I'm still inclined to declare this NAD, for two separate reasons:
</p>

<ol>
<li><p>1.9 [intro.execution] p15 states: "If a side effect on a scalar
object is unsequenced relative to either another side
effect on the same scalar object or a value computation
using the value of the same scalar object, the behavior is undefined."
I think the examples presented here have undefined behavior as a result.
It's not completely clear to me whether examples can be constructed
that exhibit this problem, and don't have undefined behavior.</p></li>

<li><p>This comment seems to be using a different meaning of "evaluation"
from what is used elsewhere in the standard. The sequence of evaluations
here doesn't have to consist of full expression evaluations.  They
can be evaluations of operations like lvalue to rvalue conversion,
or individual assignments. In particular, the reads and writes
executed by <tt>e1</tt> and <tt>e2</tt> in the example could be treated as separate
evaluations for purposes of producing the sequence.
The definition of "sequenced before" in 1.9 [intro.execution] makes
little sense if the term "evaluation" is restricted to any notion
of complete expression. Perhaps we should add yet another note
to clarify this?  29.3 [atomics.order] p10 probably leads to 
the wrong impression here.
<p/>
An alternative resolution would be to simply delete our flakey
attempt at preventing out-of-thin-air reads, by removing 29.3 [atomics.order] p9-11,
possibly adding a note that explains that we technically allow,
but strongly discourage them. If we were starting this from scratch
now, that would probably be my preference.  But it seems like too drastic
a resolution at this stage.
</p></li>
</ol>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1460"></a>1460. [FCD] Missing lock-free property for type <tt>bool</tt> should be added</h3>
<p><b>Section:</b> 29.4 [atomics.lockfree] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2011-03-14</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.lockfree">issues</a> in [atomics.lockfree].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-154</b></p>

<p>There is no <tt>ATOMIC_BOOL_LOCK_FREE</tt> macro.</p>

<p>Proposed resolution suggested by the NB comment:</p>

<p>
Add <tt>ATOMIC_BOOL_LOCK_FREE</tt> to 29.4 [atomics.lockfree] and to 29.2 [atomics.syn]:
</p>
<blockquote><pre>
[..]
<ins>#define ATOMIC_BOOL_LOCK_FREE <em>unspecified</em></ins>
#define ATOMIC_CHAR_LOCK_FREE <em>unspecified</em>
#define ATOMIC_CHAR16_T_LOCK_FREE <em>unspecified</em>
#define ATOMIC_CHAR32_T_LOCK_FREE <em>unspecified</em>
[..]
</pre></blockquote>


<p><i>[2011-03-12: Lawrence comments and drafts wording]</i></p>


<p>Point: We were missing a macro test for <tt>bool</tt>.</p>

<p>Comment: The <tt>atomic&lt;bool&gt;</tt> type is the easiest to make lock-free.
There is no harm in providing a macro.</p>

<p>Action: Add an <tt>ATOMIC_BOOL_LOCK_FREE</tt>.</p>

<p>Point: We were missing a macro test for pointers.</p>

<p>Comment: The national body comment noting the missing macro
for <tt>bool</tt> did not note the lack of a macro for pointers because
<tt>ATOMIC_ADDRESS_LOCK_FREE</tt> was present at the time of the comment.
Its removal appears to be an overzealous consequence of removing
<tt>atomic_address</tt>.</p>

<p>Action: Add an <tt>ATOMIC_POINTER_LOCK_FREE</tt>.</p>

<p>Point: Presumably <tt>atomic_is_lock_free()</tt> will be an inline function
producing a constant in those cases in which the macros are useful.</p>

<p>Comment: The point is technically correct, but could use some
exposition. Systems providing forward binary compatibility, e.g.
mainstream desktop and server systems, would likely have these
functions as inline constants only when the answer is true.
Otherwise, the function should defer to a platform-specific dynamic
library to take advantage of future systems that do provide lock-free
support.</p>

<p>Comment: Such functions are not useful in the preprocessor, and not
portably useful in <tt>static_assert</tt>.</p>

<p>Action: Preserve the macros.</p>

<p>Point: The required explicit instantiations are <tt>atomic&lt;X&gt;</tt> for each
of the types <tt>X</tt> in Table 145. Table 145 does not list <tt>bool</tt>, so 
<tt>atomic&lt;bool&gt;</tt> is not a required instantiation.</p>

<p>Comment: I think specialization was intended in the point instead of
instantiation. In any event, 29.5 [atomics.types.generic] paragraph 5 does
indirectly require a specialization for <tt>atomic&lt;bool&gt;</tt>.  Confusion
arises because the specialization for other integral types have a
wider interface than the generic <tt>atomic&lt;T&gt;</tt>, but 
<tt>atomic&lt;bool&gt;</tt> does not.</p>

<p>Action: Add clarifying text.</p>

<p>Point: The name of Table 145, "atomic integral typedefs", is perhaps
misleading, since the types listed do not contain all of the
"integral" types.</p>

<p>Comment: Granted, though the table describe those with extra operations.</p>

<p>Action: Leave the text as is.</p>

<p>Point: The macros correspond to the types in Table 145, "with the
signed and unsigned variants grouped together". That's a rather
inartful way of saying that <tt>ATOMIC_SHORT_LOCK_FREE</tt> applies to
<tt>signed short</tt> and <tt>unsigned short</tt>. Presumably this also means that
<tt>ATOMIC_CHAR_LOCK_FREE</tt> applies to all three char types.</p>

<p>Comment: Yes, it is inartful.</p>

<p>Comment: Adding additional macros to distinguish signed and unsigned
would provide no real additional information given the other
constraints in the language.</p>

<p>Comment: Yes, it applies to all three <tt>char</tt> types.</p>

<p>Action: Leave the text as is.</p>

<p>Point: The standard says that "There are full specializations over the
integral types (<tt>char</tt>, <tt>signed char</tt>, ...)" <tt>bool</tt> 
is not in the list. But this text is not normative. It simply tells you 
that "there are" specializations, not "there shall be" specializations, which would
impose a requirement. The requirement, to the extent that there is
one, is in the header synopsis, which, in N3242, sort of pulls in the
list of types in Table 145.</p>

<p>Comment: The intent was for the specializations to be normative.
Otherwise the extra member functions could not be present.</p>

<p>Action: Clarify the text.</p>


<p><b>Proposed resolution:</b></p>
<ol>
<li><p>Edit header <tt>&lt;atomic&gt;</tt> synopsis 29.2 [atomics.syn]:</p>

<blockquote><pre>
namespace std {
  <i>// 29.3, order and consistency</i>
  enum memory_order;
  template &lt;class T&gt;
  T kill_dependency(T y);

  <i>// 29.4, lock-free property</i>
  <ins>#define ATOMIC_BOOL_LOCK_FREE <i>unspecified</i></ins>
  #define ATOMIC_CHAR_LOCK_FREE <i>unspecified</i>
  #define ATOMIC_CHAR16_T_LOCK_FREE <i>unspecified</i>
  #define ATOMIC_CHAR32_T_LOCK_FREE <i>unspecified</i>
  #define ATOMIC_WCHAR_T_LOCK_FREE <i>unspecified</i>
  #define ATOMIC_SHORT_LOCK_FREE <i>unspecified</i>
  #define ATOMIC_INT_LOCK_FREE <i>unspecified</i>
  #define ATOMIC_LONG_LOCK_FREE <i>unspecified</i>
  #define ATOMIC_LLONG_LOCK_FREE <i>unspecified</i>
  <ins>#define ATOMIC_POINTER_LOCK_FREE <i>unspecified</i></ins>
  
  <i>// 29.5, generic types</i>
  template&lt;class T&gt; struct atomic;
  template&lt;&gt; struct atomic&lt;<i>integral</i>&gt;;
  template&lt;class T&gt; struct atomic&lt;T*&gt;;

  <i>// 29.6.1, general operations on atomic types
  // In the following declarations, </i>atomic_type<i> is either
  // </i>atomic&lt;T&gt;<i> or a named base class for </i>T<i> from
  // Table 145 or inferred from
  // Table 146 </i><ins><i>or from</i> bool</ins><i>.</i> 

  [&hellip;]
}
</pre></blockquote>
</li>

<li><p>Edit the synopsis of 29.4 [atomics.lockfree] and paragraph 1 as follows:</p>

<blockquote><pre>
<ins>#define ATOMIC_BOOL_LOCK_FREE <i>unspecified</i></ins>
#define ATOMIC_CHAR_LOCK_FREE <i><del>implementation-defined</del><ins>unspecified</ins></i>
#define ATOMIC_CHAR16_T_LOCK_FREE <i><del>implementation-defined</del><ins>unspecified</ins></i>
#define ATOMIC_CHAR32_T_LOCK_FREE <i><del>implementation-defined</del><ins>unspecified</ins></i>
#define ATOMIC_WCHAR_T_LOCK_FREE <i><del>implementation-defined</del><ins>unspecified</ins></i>
#define ATOMIC_SHORT_LOCK_FREE <i><del>implementation-defined</del><ins>unspecified</ins></i>
#define ATOMIC_INT_LOCK_FREE <i><del>implementation-defined</del><ins>unspecified</ins></i>
#define ATOMIC_LONG_LOCK_FREE <i><del>implementation-defined</del><ins>unspecified</ins></i>
#define ATOMIC_LLONG_LOCK_FREE <i><del>implementation-defined</del><ins>unspecified</ins></i>
<ins>#define ATOMIC_POINTER_LOCK_FREE <i>unspecified</i></ins>
</pre><blockquote>
<p>
1 The <tt>ATOMIC_&hellip;_LOCK_FREE</tt> macros indicate the lock-free property of the corresponding atomic types, with
the signed and unsigned variants grouped together. The properties also apply to the corresponding <ins>(partial)</ins> 
specializations of the <tt>atomic</tt> template. A value of 0 indicates that the types are never lock-free. A value of 1
indicates that the types are sometimes lock-free. A value of 2 indicates that the types are always lock-free.
</p>
</blockquote></blockquote>  
</li>

<li><p>Edit 29.5 [atomics.types.generic] paragraph 3, 4, and 6-8 as follows:</p>

<blockquote><p>
2 The semantics of the operations on specializations of <tt>atomic</tt> are defined in 29.6 [atomics.types.operations].
<p/>
3 Specializations <ins>and instantiations</ins> of the <tt>atomic</tt> template shall have a deleted copy constructor, 
a deleted copy assignment operator, and a <tt>constexpr</tt> value constructor.
<p/>
4 There <del>are</del><ins>shall be</ins> full specializations <del>over</del><ins>for</ins> the integral types <del>(</del>
<tt>char</tt>, <tt>signed char</tt>, <tt>unsigned char</tt>, <tt>short</tt>, <tt>unsigned short</tt>, <tt>int</tt>, 
<tt>unsigned int</tt>, <tt>long</tt>, <tt>unsigned long</tt>, <tt>long long</tt>, <tt>unsigned long long</tt>, 
<tt>char16_t</tt>, <tt>char32_t</tt>, <ins>and</ins> <tt>wchar_t</tt>, and any other types needed by the typedefs in the header 
<tt>&lt;cstdint&gt;</tt><del>)</del> on the <tt>atomic</tt> class
template. For each integral type integral, the specialization <tt>atomic&lt;<i>integral</i>&gt;</tt> provides additional atomic
operations appropriate to integral types. <del>[Editor's note: I'm guessing that this is the correct rendering of
the text in the paper; if this sentence was intended to impose a requirement, rather than a description, it
will have to be changed.]</del> <ins>There shall be a specialization <tt>atomic&lt;bool&gt;</tt> which provides
the general atomic operations as specified in 29.6.1 [atomics.types.operations.general].</ins>
<p/>
5 The atomic integral specializations and the specialization <tt>atomic&lt;bool&gt;</tt> shall have standard layout. They
shall each have a trivial default constructor and a trivial destructor. They shall each support aggregate
initialization syntax.
<p/>
6 There <del>are</del><ins>shall be</ins> pointer partial specializations <del>on</del><ins>of</ins> the <tt>atomic</tt> 
class template. These specializations shall have trivial default constructors and trivial destructors.
<p/>
7 There <del>are</del><ins>shall be</ins> named types corresponding to the integral specializations of <tt>atomic</tt>, as 
specified in Table 145. <ins>In addition, there shall be named type <code>atomic_bool</code> corresponding to the specialization 
<code>atomic&lt;bool&gt;</code>.</ins> Each named type is <ins>either</ins> a typedef to the corresponding specialization 
or a base class of the corresponding specialization. If it is a base class, it shall support the same member functions 
as the corresponding specialization.
<p/>
8 There <del>are</del><ins>shall be</ins> atomic typedefs corresponding to the typedefs in the header <tt>&lt;inttypes.h&gt;</tt> 
as specified in Table 146.
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="1461"></a>1461. [FCD] Rename all <tt>ATOMIC_*</tt> macros as <tt>STD_ATOMIC_*</tt></h3>
<p><b>Section:</b> 29 [atomics] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Canada <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2011-03-06</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics">active issues</a> in [atomics].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics">issues</a> in [atomics].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses CA-1</b></p>
<p>
All <tt>ATOMIC_</tt>... macros should be prefixed with <tt>STD_</tt> as
in <tt>STD_ATOMIC_</tt>... to indicate they are <tt>STD</tt> macros as
other standard macros. The rationale that they all seem too long seems weak.
</p>

<p><i>[2011-03-06: Daniel adapts suggested wording to N3242 and comments]</i></p>


<p>I suggest to declare this issue as NAD. Reason for this suggestion is, that
C1x is currently going to suggest exactly the same macros as additions to
header <tt>&lt;stdatomic.h&gt;</tt>, therefore C++0x should not define a
whole new set. I'm making this suggestion with the understanding that
C1x is intending to keep in sync in this regard. For example, the most
<a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1548.pdf">recent 
draft of C1x</a> does contain the macro <tt>ATOMIC_ADDRESS_LOCK_FREE</tt>
which has recently been removed from the C++ working draft.</p>


<p><b>Proposed resolution:</b></p>
<ol>
<li><p>Change sub-clause 29.2 [atomics.syn] as indicated:</p>
<blockquote><pre>
[..]
// <em>[atomics.lockfree], lock-free property</em>
#define <ins>STD_</ins>ATOMIC_CHAR_LOCK_FREE <em>unspecified</em>
#define <ins>STD_</ins>ATOMIC_CHAR16_T_LOCK_FREE <em>unspecified</em>
#define <ins>STD_</ins>ATOMIC_CHAR32_T_LOCK_FREE <em>unspecified</em>
#define <ins>STD_</ins>ATOMIC_WCHAR_T_LOCK_FREE <em>unspecified</em>
#define <ins>STD_</ins>ATOMIC_SHORT_LOCK_FREE <em>unspecified</em>
#define <ins>STD_</ins>ATOMIC_INT_LOCK_FREE <em>unspecified</em>
#define <ins>STD_</ins>ATOMIC_LONG_LOCK_FREE <em>unspecified</em>
#define <ins>STD_</ins>ATOMIC_LLONG_LOCK_FREE <em>unspecified</em>

// <em>[atomics.types.operations.req], operations on atomic types</em>
#define <ins>STD_</ins>ATOMIC_VAR_INIT(value) <em>see below</em>
[..]
</pre></blockquote>
</li>
<li>
<p>Change 29.4 [atomics.lockfree] p. 1 as indicated:</p>
<blockquote><pre>
#define <ins>STD_</ins>ATOMIC_CHAR_LOCK_FREE <em>implementation-defined</em>
#define <ins>STD_</ins>ATOMIC_CHAR16_T_LOCK_FREE <em>implementation-defined</em>
#define <ins>STD_</ins>ATOMIC_CHAR32_T_LOCK_FREE <em>implementation-defined</em>
#define <ins>STD_</ins>ATOMIC_WCHAR_T_LOCK_FREE <em>implementation-defined</em>
#define <ins>STD_</ins>ATOMIC_SHORT_LOCK_FREE <em>implementation-defined</em>
#define <ins>STD_</ins>ATOMIC_INT_LOCK_FREE <em>implementation-defined</em>
#define <ins>STD_</ins>ATOMIC_LONG_LOCK_FREE <em>implementation-defined</em>
#define <ins>STD_</ins>ATOMIC_LLONG_LOCK_FREE <em>implementation-defined</em>
</pre><blockquote>
<p>
1 The <tt><ins>STD_</ins>ATOMIC_..._LOCK_FREE</tt> macros indicate the lock-free property of the corresponding atomic types, [..]
</p></blockquote></blockquote>
</li>
<li>
<p>Change 29.6.5 [atomics.types.operations.req] p. 6 as indicated:</p>
<blockquote><pre>
#define <ins>STD_</ins>ATOMIC_VAR_INIT(value) <em>see below</em>
</pre><blockquote><p>
5 <em>Remarks</em>: The macro expands to a token sequence suitable for constant initialization 
an atomic variable of static storage duration of a type that is initialization-compatible
with <i>value</i>. [ <i>Note</i>: This operation may need to initialize locks. &mdash; <i>end note</i> ] 
Concurrent access to the variable being initialized, even via an atomic operation, constitutes 
a data race. [ <em>Example:</em>
</p><blockquote><pre>
atomic&lt;int&gt; v = <ins>STD_</ins>ATOMIC_VAR_INIT(5);
</pre></blockquote>
<p>&mdash; <em>end example</em> ]</p>
</blockquote></blockquote>
</li>
<li>
<p>Change 29.7 [atomics.flag] p. 1+4 as indicated:</p>
<blockquote><pre>
namespace std {
  [..]
  #define <ins>STD_</ins>ATOMIC_FLAG_INIT <em>see below</em>
}
</pre><blockquote><p>
[..]
4 The macro <tt><ins>STD_</ins>ATOMIC_FLAG_INIT</tt> shall be defined in such a way that it can be used to initialize an object of
type <tt>atomic_flag</tt> to the clear state. For a static-duration object, that initialization shall be static. It is
unspecified whether an unitialized <tt>atomic_flag</tt> object has an initial state of set or clear. [ <em>Example:</em>
</p><blockquote><pre>
atomic_flag guard = <ins>STD_</ins>ATOMIC_FLAG_INIT;
</pre></blockquote>
<p>&mdash; <em>end example</em> ]</p>
</blockquote></blockquote>
</li>
</ol>





<hr>
<h3><a name="1478"></a>1478. [FCD] Clarify race conditions in atomics initialization</h3>
<p><b>Section:</b> 29.6 [atomics.types.operations] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2011-02-26</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.types.operations">issues</a> in [atomics.types.operations].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-136</b></p>
<p>
GB requests normative clarification in 29.6 [atomics.types.operations] p.4 that
concurrent access constitutes a race, as already done on p.6 and p.7.
</p>
<p><i>[
Resolution proposed in ballot comment:
]</i></p>


<blockquote><p>
Initialisation of atomics:
<p/>
We believe the intent is that for any atomics there is a distinguished
initialisation write, but that this need not happens-before all the
other operations on that atomic - specifically so that the
initialisation write might be non-atomic and hence give rise to a data
race, and hence undefined behaviour, in examples such as this (from
Hans):
</p>
<blockquote><pre>
atomic&lt;atomic&lt;int&gt; *&gt; p
f()                      |
{ atomic&lt;int&gt;x;          | W_na x
  p.store(&amp;x,mo_rlx);    | W_rlx p=&amp;x
}                        |
</pre></blockquote><p>
(where na is nonatomic and rlx is relaxed). We suspect also that no
other mixed atomic/nonatomic access to the same location is intended
to be permitted. Either way, a note would probably help.
</p></blockquote>

<p><i>[2011-02-26: Hans comments and drafts wording]</i></p>


<p>I think the important point here is to clarify that races on atomics
are possible, and can be introduced as a result of non-atomic
initialization operations.  There are other parts of this that remain unclear
to me, such as whether there are other ways to introduce data races on atomics,
or whether the races with initialization also introduce undefined behavior
by the 3.8 lifetime rules.  But I don't think that it is necessary to resolve
those issues before releasing the standard.  That's particularly true
since we've introduced <tt>atomic_init</tt>, which allows easier ways to
construct initialization races.
</p>


<p><b>Proposed resolution:</b></p>
<ol>
<li><p>Update 29.6.5 [atomics.types.operations.req] p. 5 as follows:</p>

<blockquote><pre>
constexpr A::A(C desired);
</pre><blockquote><p>
5 <i>Effects</i>: Initializes the object with the value <tt>desired</tt>. <del>[ <i>Note</i>: 
Construction is not atomic. &mdash; <i>end note</i> ]</del><ins> Initialization is not an 
atomic operation (1.10) [intro.multithread]. [<i>Note</i>: It is possible to have an
access to an atomic object <tt>A</tt> race with its construction, for example
by communicating the address of the just-constructed object <tt>A</tt> to another thread 
via <code>memory_order_relaxed</code> atomic operations on a suitable atomic pointer variable, 
and then immediately accessing <tt>A</tt> in the receiving thread.  This results in undefined 
behavior. &mdash; <i>end note</i>]</ins>
</p></blockquote></blockquote>
</li>

<li><p>In response to the editor comment to 29.6.5 [atomics.types.operations.req] p. 8: 
The first <i>Effects</i> element is the correct and intended one:</p>

<blockquote><pre>
void atomic_init(volatile A *object, C desired);
void atomic_init(A *object, C desired);
</pre><blockquote><p>
8 <i>Effects</i>: Non-atomically initializes <tt>*object</tt> with value <tt>desired</tt>.
This function shall only be applied to objects that have been default constructed, and then only once.
[ <i>Note</i>: these semantics ensure compatibility with C. &mdash; <i>end note</i> ] [ <i>Note</i>: 
Concurrent access from another thread, even via an atomic operation, constitutes a data 
race. &mdash; <i>end note</i> ] <del>[<i>Editor's note</i>: The preceding text is from the WD as 
amended by N3196. N3193 makes different changes, marked up in the paper as follows:]
<i>Effects</i>: Dynamically initializes an atomic variable. Non-atomically That is, non-atomically assigns the
value desired to <tt>*object</tt>. [ <i>Note</i>: this operation may need to initialize 
locks. &mdash; <i>end note</i> ] Concurrent access from another thread, even via an atomic 
operation, constitutes a data race.</del>
</p></blockquote></blockquote>
</li>
</ol>





<hr>
<h3><a name="1502"></a>1502. [FCD] Specification of [futures.state]</h3>
<p><b>Section:</b> 30.6.4 [futures.state] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2011-03-19</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.state">issues</a> in [futures.state].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-195</b></p>

<p>The intent and meaning of 30.6.4 [futures.state] p10 is not apparent.</p>

<blockquote><p>
10 Accesses to the same shared state conflict (1.10).
</p></blockquote>

<p><i>[
2011-03-07 Jonathan Wakely adds:
]</i></p>

<blockquote><p>
It's not clear which paragraph this refers to, I had to go to the
ballot comments where US-195 reveals it's para 8, which in the FCD
(N3092) says:
</p><blockquote><p>
 Accesses to the same associated asynchronous state conflict (1.10).
</p></blockquote>
<p>This is now para 10 in N3242:</p>
<blockquote><p>
 Accesses to the same shared state conflict (1.10).
</p></blockquote>
</blockquote>

<p><i>[2011-03-07: Lawrence comments and drafts wording]</i></p>


<p>The intent of this paragraph is to deal with operations,
such as <code>shared_future::get()</code>, that return a reference
to a value held in the shared state.  User code could potentially
conflict when accessing that value.</p>

<p>Lawrence proposed resolution:</p>

<p>Modify 30.6.4 [futures.state] p10 as follows:</p>

<blockquote><p>
10 <del>Accesses to the same shared state conflict (1.10 [intro.multithread]).</del><ins>Some 
  operations, e.g. <code>shared_future::get()</code>
 (30.6.7 [futures.shared_future]), may return a reference to a
 value held in their shared state. Accesses and modifications through
 those references by concurrent threads to the same 
 shared state may potentially conflict (1.10 [intro.multithread]).
 [<i>Note:</i> As a consequence, accesses must either use
 read-only operations or provide additional synchronization.
 &mdash; <i>end note</i>]</ins>
</p></blockquote>

<p><i>[2011-03-19: Detlef suggests an alternative resolution, shown below.]</i></p>




<p><b>Proposed resolution:</b></p>
<p>Modify 30.6.4 [futures.state] p10 as follows:</p>

<blockquote><p>
10 Accesses to the same shared state conflict (1.10 [intro.multithread]). <ins>[<i>Note</i>: 
This explicitely specifies that the shared state is visible in the objects that reference this state 
in the sense of data race avoidance 17.6.5.9 [res.on.data.races]. &mdash; <i>end note</i>]</ins>
</p></blockquote>





<hr>
<h3><a name="1504"></a>1504. [FCD] Term "are serialized" is not defined</h3>
<p><b>Section:</b> 30.6.5 [futures.promise] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2011-03-20</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures.promise">active issues</a> in [futures.promise].</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.promise">issues</a> in [futures.promise].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-196</b></p>
<p>
The term "are serialized" is not defined (30.6.5 [futures.promise] p. 21, 25).
</p>
<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote><p>
Replace "are serialized" with "shall not introduce a data race (17.6.4.8)".
</p></blockquote>

<p><i>[
2010-11-02 Daniel translates proposal into proper wording changes
]</i></p>


<p><i>[2011-03-19: Detlef comments]</i></p>


<p>The proposed resolution for <a href="lwg-active.html#1507">1507</a> would cover this issue as well.</p>


<p><b>Proposed resolution:</b></p>
<ol>
<li>Change 30.6.5 [futures.promise] p. 21 as indicated:
<blockquote><p>
21 <em>Synchronization</em>: calls to <tt>set_value</tt> and <tt>set_exception</tt> on a single 
<tt>promise</tt> object <del>are serialized</del><ins>shall not introduce a data race ([res.on.data.races])</ins>.
[ <em>Note</em>: and they synchronize and serialize with other functions through the referred associated asynchronous
state. &mdash; <em>end note</em> ]
</p></blockquote>
</li>
<li>Change 30.6.5 [futures.promise] p. 25 as indicated:
<blockquote><p>
25 <em>Synchronization</em>: calls to <tt>set_value</tt> and <tt>set_exception</tt> on a single 
<tt>promise</tt> object <del>are serialized</del><ins>shall not introduce a data race ([res.on.data.races])</ins>.
[ <em>Note</em>: and they synchronize and serialize with other functions through the referred associated asynchronous
state. &mdash; <em>end note</em> ]
</p></blockquote>
</li>
</ol>





<hr>
<h3><a name="1505"></a>1505. [FCD] Synchronization between
<tt>promise::set_value</tt> and <tt>future::get</tt></h3>
<p><b>Section:</b> 30.6.5 [futures.promise] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2011-03-20</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures.promise">active issues</a> in [futures.promise].</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.promise">issues</a> in [futures.promise].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-197</b></p>
<p>
There is no defined synchronization between
<tt>promise::set_value</tt> and <tt>future::get</tt> (30.6.5 [futures.promise] p. 21, 25).
</p>
<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote><p>
Replace "[<i>Note</i>: and they synchronize and
serialize with other functions through the referred
associated asynchronous state. &mdash; <i>end note</i>]" with
the normative "They synchronize with (1.10) any
operation on a future object with the same
associated asynchronous state marked ready."
</p></blockquote>

<p><i>[
2010-11-02 Daniel translates proposal into proper wording changes
]</i></p>


<p><i>[2011-03-19: Detlef comments]</i></p>


<p>The proposed resolution for <a href="lwg-active.html#1507">1507</a> would cover this issue as well.
Effectively it will reject the request but a clarification is added that the 
normative wording is already in 30.6.4 [futures.state].</p>



<p><b>Proposed resolution:</b></p>
<ol>
<li>Change 30.6.5 [futures.promise] p. 21 as indicated:
<blockquote><p>
21 <em>Synchronization</em>: calls to <tt>set_value</tt> and <tt>set_exception</tt> on a single 
<tt>promise</tt> object are serialized.
<del>[ <em>Note</em>: and they synchronize and serialize with other functions through the referred associated asynchronous
state. &mdash; <em>end note</em> ]</del><ins>They <em>synchronize with</em> ([intro.multithread]) any
operation on a future object with the same associated asynchronous state marked ready.</ins>
</p></blockquote>
</li>
<li>Change 30.6.5 [futures.promise] p. 25 as indicated:
<blockquote><p>
25 <em>Synchronization</em>: calls to <tt>set_value</tt> and <tt>set_exception</tt> on a single 
<tt>promise</tt> object are serialized.
<del>[ <em>Note</em>: and they synchronize and serialize with other functions through the referred associated asynchronous
state. &mdash; <em>end note</em> ]</del><ins>They <em>synchronize with</em> ([intro.multithread]) any
operation on a future object with the same associated asynchronous state marked ready.</ins>
</p></blockquote>
</li>
</ol>





<hr>
<h3><a name="1507"></a>1507. [FCD] <tt>promise::<i>XXX</i>_at_thread_exit</tt> functions have no
synchronization requirements</h3>
<p><b>Section:</b> 30.6.5 [futures.promise] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2011-03-20</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures.promise">active issues</a> in [futures.promise].</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.promise">issues</a> in [futures.promise].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-199</b></p>
<p>
<tt>promise::<i>XXX</i>_at_thread_exit</tt> functions have no
synchronization requirements. Specifying synchronization
for these member functions requires coordinating with the
words in 30.6.5 [futures.promise]/21 and 25, which give synchronization
requirements for <tt>promise::set_value</tt> and
<tt>promise::set_exception</tt> (30.6.5 [futures.promise] p. 26 ff., p. 29 ff.).
</p>
<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote><p>
Change 30.6.5 [futures.promise]/21 to mention <tt>set_value_at_thread_exit</tt> and
<tt>set_exception_at_thread_exit;</tt> with this text, replace 30.6.5 [futures.promise]/25 
and add two new paragraphs, after 30.6.5 [futures.promise]/28 and 30.6.5 [futures.promise]/31.
</p></blockquote>

<p><i>[2011-03-8: Lawrence comments and drafts wording]</i></p>


<p>This comment applies as well to other <tt>*_at_thread_exit</tt>
functions.  The following resolution adds synchronization paragraphs
to all of them and edits a couple of related synchronization
paragraphs.</p>

<p><i>[2011-03-09: Hans and Anthony add some improvements]</i></p>


<p><i>[2011-03-19: Detlef comments]</i></p>


<p>In regard to the suggested part:</p>

<blockquote><p>
These operations do not provide any ordering guarantees with
respect to other operations, except through operations on futures
that reference the same shared state.
</p></blockquote>

<p>I would like this to change to:</p>

<blockquote><p>
These operations do not provide any ordering guarantees with
respect to other operations on the same promise object.
[<i>Note</i>: They synchronize with calls to operations on
objects that refer to the same shared state according to
30.6.4 [futures.state]. &mdash; <i>end note</i>]
</p></blockquote>

<p>The current proposed resolution has exactly the same paragraph at
for places. I propose to have it only once as new paragraph 2.</p>

<p>This also covers <a href="lwg-active.html#1504">1504</a> (US-196) and <a href="lwg-active.html#1505">1505</a> (US-197).
US-197 is essentially rejected with this resolution, but a clarification is added 
that the normative wording is already in 30.6.4 [futures.state].</p>



<p><b>Proposed resolution:</b></p>
<ol>
<li><p>Edit 30.4.1.2 [thread.mutex.requirements.mutex] paragraph 5 as follows:</p>

<blockquote><p>
5 The implementation shall provide lock and unlock operations, as described below. <del>The implementation 
shall serialize those operations.</del><ins>For purposes of determining the existence of a data race, these
behave as atomic operations (1.10 [intro.multithread]).  The lock and unlock operations on
a single mutex shall appear to occur in a single total order. [<i>Note</i>: this can be viewed as the 
modification order (1.10 [intro.multithread]) of the mutex. &mdash; <i>end note</i>]</ins> [ <i>Note</i>: 
Construction and destruction of an object of a mutex type need not be thread-safe; other synchronization 
should be used to ensure that mutex objects are initialized and visible to other threads. &mdash; <i>end note</i> ]
</p></blockquote>
</li>

<li><p>Edit 30.5 [thread.condition] paragraphs 6-9 as follows:</p>

<blockquote><pre>
void notify_all_at_thread_exit(condition_variable&amp; cond, unique_lock&lt;mutex&gt; lk);
</pre>
<blockquote>
<p>
-6- <i>Requires</i>: <tt>lk</tt> is locked by the calling thread and either
</p>
<ul>
<li>no other thread is waiting on <tt>cond</tt>, or</li>
<li><tt>lk.mutex()</tt> returns the same value for each of the lock arguments supplied by all concurrently
waiting (via <tt>wait</tt>, <tt>wait_for</tt>, or <tt>wait_until</tt>) threads.</li>
</ul>
<p>
-7- <i>Effects</i>: transfers ownership of the lock associated with <tt>lk</tt> into internal storage and schedules 
<tt>cond</tt> to be notified when the current thread exits, after all objects of thread storage duration 
associated with the current thread have been destroyed. This notification shall be as if
</p>
<blockquote><pre>
lk.unlock();
cond.notify_all();
</pre></blockquote>
<p>
<ins>-?- <i>Synchronization:</i> The call to <code>notify_all_at_thread_exit</code>
and the completion of the destructors for all the current thread's variables of 
thread storage duration synchronize with (1.10 [intro.multithread]) calls 
to functions waiting on <code>cond</code>.</ins>
<p/>
-8- <i>Note</i>: The supplied lock will be held until the thread exits, and care must be taken to ensure that
this does not cause deadlock due to lock ordering issues. After calling <tt>notify_all_at_thread_exit</tt>
it is recommended that the thread should be exited as soon as possible, and that no blocking or
time-consuming tasks are run on that thread.
<p/>
-9- <i>Note</i>: It is the user's responsibility to ensure that waiting threads do not erroneously 
assume that the thread has finished if they experience spurious wakeups. This typically requires 
that the condition being waited for is satisfied while holding the lock on <tt>lk</tt>, and that 
this lock is not released and reacquired prior to calling <tt>notify_all_at_thread_exit</tt>.
</p>
</blockquote></blockquote>
</li>

<li><p>Edit 30.6.5 [futures.promise], paragraphs 14-27 as follows:</p>

<blockquote><pre>
void promise::set_value(const R&amp; r);
void promise::set_value(R&amp;&amp; r);
void promise&lt;R&amp;&gt;::set_value(R&amp; r);
void promise&lt;void&gt;::set_value();
</pre>
<blockquote>
<p>
-14- <i>Effects</i>: atomically stores the value <tt>r</tt> in the shared state and makes that state 
ready (30.6.4 [futures.state]).
<p/>
-15- <i>Throws</i>:
</p>
<ul>
<li><tt>future_error</tt> if its shared state already has a stored value or exception, or</li>
<li>for the first version, any exception thrown by the copy constructor of <tt>R</tt>, or</li>
<li>for the second version, any exception thrown by the move constructor of <tt>R</tt>.</li>
</ul>
<p>
-16- <i>Error conditions</i>:
</p>
<ul>
<li><tt>promise_already_satisfied</tt> if its shared state already has a stored value or exception.</li>
<li><tt>no_state</tt> if <tt>*this</tt> has no shared state.</li>
</ul>
<p>
-17- <i>Synchronization</i>: <del>calls to <tt>set_value</tt> and <tt>set_exception</tt> on a single 
<tt>promise</tt> object are serialized. [ <i>Note</i>: And they synchronize and serialize with other functions 
through the referred shared state. &mdash; <i>end note</i> ]</del><ins>For purposes of determining the 
existence of a data race, <tt>set_value</tt>, <tt>set_exception</tt>, <tt>set_value_at_thread_exit</tt>,
and <tt>set_exception_at_thread_exit</tt> behave as atomic operations (1.10 [intro.multithread]) on
the memory location associated with the <tt>promise</tt>. Calls to these operations on a single promise shall 
appear to occur in a single total order.  [<i>Note</i>: this can be viewed as the modification order
(1.10 [intro.multithread]) of the promise. &mdash; <i>end note</i>] These operations do not 
provide any ordering guarantees with respect to other operations, except through operations on futures
that reference the same shared state.</ins>
</p>
</blockquote></blockquote>

<blockquote><pre>
void set_exception(exception_ptr p);
</pre>
<blockquote>
<p>
-18- <i>Effects</i>: atomically stores the exception pointer <tt>p</tt> in the shared state and makes that 
state ready (30.6.4 [futures.state]).
</p>

<p>
-19- <i>Throws</i>: <tt>future_error</tt> if its shared state already has a stored value or exception.
</p>

<p>
-20- <i>Error conditions</i>:
</p>
<ul>
<li><tt>promise_already_satisfied</tt> if its shared state already has a stored value or exception.</li>
<li><tt>no_state</tt> if <tt>*this</tt> has no shared state.</li>
</ul>

<p>
-21- <i>Synchronization</i>: <del>calls to <tt>set_value</tt> and <tt>set_exception</tt> on a single 
<tt>promise</tt> object are serialized. [ <i>Note</i>: And they synchronize and serialize with 
other functions through the referred shared state. &mdash; <i>end note</i> ]</del><ins>For purposes of determining the 
existence of a data race, <tt>set_value</tt>, <tt>set_exception</tt>, <tt>set_value_at_thread_exit</tt>,
and <tt>set_exception_at_thread_exit</tt> behave as atomic operations (1.10 [intro.multithread]) on
the memory location associated with the <tt>promise</tt>. Calls to these operations on a single promise shall 
appear to occur in a single total order.  [<i>Note</i>: this can be viewed as the modification order
(1.10 [intro.multithread]) of the promise. &mdash; <i>end note</i>] These operations do not 
provide any ordering guarantees with respect to other operations, except through operations on futures
that reference the same shared state.</ins>
</p>
</blockquote></blockquote>

<blockquote><pre>
void promise::set_value_at_thread_exit(const R&amp; r);
void promise::set_value_at_thread_exit(R&amp;&amp; r);
void promise&lt;R&amp;&gt;::set_value_at_thread_exit(R&amp; r);
void promise&lt;void&gt;::set_value_at_thread_exit();
</pre>
<blockquote>
<p>
-22- <i>Effects</i>: Stores the value <tt>r</tt> in the shared state without making that state 
ready immediately. Schedules that state to be made ready when the current thread exits, after 
all objects of thread storage duration associated with the current thread have been destroyed.
<p/>
-23- <i>Throws</i>: <tt>future_error</tt> if an error condition occurs.
<p/>
-24- <i>Error conditions</i>:
</p>
<ul>
<li><tt>promise_already_satisfied</tt> if its shared state already has a stored value or exception.</li>
<li><tt>no_state</tt> if <tt>*this</tt> has no shared state.</li>
</ul>
<p>
<ins>-??- <i>Synchronization</i>: For purposes of determining the existence of a data race, <tt>set_value</tt>, 
<tt>set_exception</tt>, <tt>set_value_at_thread_exit</tt>, and <tt>set_exception_at_thread_exit</tt> behave as 
atomic operations (1.10 [intro.multithread]) on the memory location associated with the <tt>promise</tt>. 
Calls to these operations on a single promise shall appear to occur in a single total order.  [<i>Note</i>: 
this can be viewed as the modification order (1.10 [intro.multithread]) of the promise. &mdash; 
<i>end note</i>] These operations do not provide any ordering guarantees with respect to other operations, 
except through operations on futures that reference the same shared state.</ins>
</p>
</blockquote></blockquote>

<blockquote><pre>
void promise::set_exception_at_thread_exit(exception_ptr p);
</pre>
<blockquote>
<p>
-25- <i>Effects</i>: Stores the exception pointer <tt>p</tt> in the shared state without 
making that state ready immediately. Schedules that state to be made ready when the current 
thread exits, after all objects of thread storage duration associated with the current 
thread have been destroyed.
<p/>
-26- <i>Throws</i>: <tt>future_error</tt> if an error condition occurs.
<p/>
-27- <i>Error conditions</i>:
</p>
<ul>
<li><tt>promise_already_satisfied</tt> if its shared state already has a stored value or exception.</li>
<li><tt>no_state</tt> if <tt>*this</tt> has no shared state.</li>
</ul>
<p>
<ins>-??- <i>Synchronization</i>: For purposes of determining the existence of a data race, <tt>set_value</tt>, 
<tt>set_exception</tt>, <tt>set_value_at_thread_exit</tt>, and <tt>set_exception_at_thread_exit</tt> behave as 
atomic operations (1.10 [intro.multithread]) on the memory location associated with the <tt>promise</tt>. 
Calls to these operations on a single promise shall appear to occur in a single total order.  [<i>Note</i>: 
this can be viewed as the modification order (1.10 [intro.multithread]) of the promise. &mdash; 
<i>end note</i>] These operations do not provide any ordering guarantees with respect to other operations, 
except through operations on futures that reference the same shared state.</ins>
</p>
</blockquote></blockquote>
</li>

<li><p>Edit 30.6.9.1 [futures.task.members], paragraph 15-21 as follows:</p>

<blockquote><pre>
void operator()(ArgTypes... args);
</pre>
<blockquote>
<p>
-15- <i>Effects</i>: <tt><var>INVOKE</var>(f, t1, t2, ..., tN, R)</tt>, where <tt>f</tt> is the stored task 
of <tt>*this</tt> and <tt>t1</tt>, <tt>t2</tt>, <tt>...</tt>, <tt>tN</tt> are the values in 
<tt>args...</tt>. If the task returns normally, the return value is stored as the asynchronous 
result in the shared state of <tt>*this</tt>, otherwise the exception thrown by the task is 
stored. The shared state of <tt>*this</tt> is made ready, and any threads blocked in a function 
waiting for the shared state of <tt>*this</tt> to become ready are unblocked.
<p/>
-16- <i>Throws</i>: a <tt>future_error</tt> exception object if there is no shared state or the stored 
task has already been invoked.
<p/>
-17- <i>Error conditions</i>:
</p>
<ul>
<li><tt>promise_already_satisfied</tt> if the shared state is already ready.</li>
<li><tt>no_state</tt> if <tt>*this</tt> has no shared state.</li>
</ul>
<p>
-18- <i>Synchronization</i>: a successful call to <tt>operator()</tt> synchronizes with (1.10 [intro.multithread]) 
a call to any member function of a <tt>future</tt> or <tt>shared_future</tt> object that shares the 
shared state of <tt>*this</tt>. The completion of the invocation of the stored task and the storage 
of the result (whether normal or exceptional) into the shared state synchronizes with (1.10 [intro.multithread]) 
the successful return from any member function that detects that the state is set to ready. [ <i>Note</i>: 
<tt>operator()</tt> synchronizes and serializes with other functions through the shared state. &mdash; <i>end note</i> ]
</p>
</blockquote></blockquote>

<blockquote><pre>
void make_ready_at_thread_exit(ArgTypes... args);
</pre>
<blockquote>
<p>
-19- <i>Effects</i>: <tt><var>INVOKE</var>(f, t1, t2, ..., tN, R)</tt>, where <tt>f</tt> is the 
stored task and <tt>t1</tt>, <tt>t2</tt>, <tt>...</tt>, <tt>tN</tt> are the values in <tt>args...</tt>. 
If the task returns normally, the return value is stored as the asynchronous result in the shared 
state of <tt>*this</tt>, otherwise the exception thrown by the task is stored. In either case, 
this shall be done without making that state ready (30.6.4 [futures.state]) immediately. 
Schedules the shared state to be made ready when the current thread exits, after all objects of 
thread storage duration associated with the current thread have been destroyed.
<p/>
-20- <i>Throws</i>: <tt>future_error</tt> if an error condition occurs.
<p/>
-21- <i>Error conditions</i>:
</p>
<ul>
<li><tt>promise_already_satisfied</tt> if the shared state already has a stored value or exception.</li>
<li><tt>no_state</tt> if <tt>*this</tt> has no shared state.</li>
</ul>
<p>
<ins>-??- <i>Synchronization:</i> a successful call to <code>make_ready_at_thread_exit</code>
synchronizes with (1.10 [intro.multithread]) a call to any member function of
a <code>future</code> or <code>shared_future</code> object that shares the shared state of 
<code>*this</code>. The completion of</ins>
</p>
<ul>
<li><p><ins>the invocation of the stored task and the storage of the result (whether normal or 
exceptional) into the shared state</ins></p></li>
<li><p><ins>the destructors for all the current thread's variables of thread storage duration</ins></p></li>
</ul>
<p>
<ins>synchronize with (1.10 [intro.multithread]) the successful return from any member function
that detects that the state is set to ready. [<i>Note:</i> <code>make_ready_at_thread_exit</code>
synchronizes and serializes with other functions through the shared state. &mdash; <i>end note</i>]</ins>
</p>
</blockquote></blockquote>

</li>
</ol>





<hr>
<h3><a name="1521"></a>1521. Requirements on internal pointer representations in containers</h3>
<p><b>Section:</b> 23.2.1 [container.requirements.general] <b>Status:</b> <a href="lwg-active.html#Deferred">Deferred</a>
 <b>Submitter:</b> Mike Spertus <b>Opened:</b> 2010-10-16 <b>Last modified:</b> 2011-03-24</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements.general">issues</a> in [container.requirements.general].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Deferred">Deferred</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-104, US-141</b></p>

<p>
The standard doesn't say that containers should use abstract pointer 
types internally. Both Howard and Pablo agree that this is the intent. 
Further, it is necessary for containers to be stored, for example, in 
shared memory with an interprocess allocator (the type of scenario that 
allocators are intended to support).
</p>
<p>
In spite of the (possible) agreement on intent, it is necessary to make 
this explicit:
</p>
<p>
An implementations may like to store the result of dereferencing the 
pointer (which is a raw reference) as an optimization, but that prevents 
the data structure from being put in shared memory, etc. In fact, a 
container could store raw references to the allocator, which would be a 
little weird but conforming as long as it has one by-value copy. 
Furthermore, pointers to locales, ctypes, etc. may be there, which also 
prevents the data structure from being put in shared memory, so we 
should make explicit that a container does not store raw pointers or 
references at all.
</p>

<p><i>[
Pre-batavia
]</i></p>

<p>
This issue is being opened as part of the response to NB comments US-104/141. 
See paper <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3171.pdf">N3171</a>
in the pre-Batavia mailing. 
</p>

<p><i>[2011-03-23 Madrid meeting]</i></p>


<p>Deferred</p>



<p><b>Proposed resolution:</b></p>
<p>
Add to the end of 23.2.1 [container.requirements.general] p. 8:
</p>
<blockquote><p>
[..] In all container types defined in this Clause, the member <tt>get_allocator()</tt> returns 
a copy of the allocator used to construct the container or, if that allocator has been replaced, 
a copy of the most recent replacement. <ins>The container may not store internal objects whose 
types are of the form  <tt>T *</tt> or <tt>T &amp;</tt> except insofar as they are part of the 
item type or members.</ins>
</p></blockquote>





<hr>
<h3><a name="1523"></a>1523. [FCD] <tt>noexcept</tt> for Clause 29</h3>
<p><b>Section:</b> 29 [atomics] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hans Boehm <b>Opened:</b> 2010-11-13 <b>Last modified:</b> 2011-03-07</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics">active issues</a> in [atomics].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics">issues</a> in [atomics].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-63 for Clause 29</b></p>

<p>Clause 29 does not specify noexcept for any of the atomic operations.
It probably should, though that's not completely clear.
In particular, atomics may want to throw in implementations that support transactional memory.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Apply paper <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3251.html">N3251</a>,
noexcept for the Atomics Library.
</p>





<hr>
<h3><a name="1524"></a>1524. [FCD] Allocation functions are missing <i>happens-before</i> requirements and guarantees</h3>
<p><b>Section:</b> 5.3.4 [expr.new], 5.3.5 [expr.delete] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hans Boehm <b>Opened:</b> 2011-02-26 <b>Last modified:</b> 2011-02-26</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-34</b></p>

<p>Technical details:
<p/>
When the same unit of storage is allocated and deallocated repeatedly, operations on it can't be allowed to
race between the allocator and the user program. But I don't see any mention of <i>happens-before</i> in the
descriptions of allocation and deallocation functions.
<p/>
Proposed resolution (not wording yet):
</p>
<ul>
<li><p>The call to an allocation function returning a pointer <tt>P</tt> must happen-before the matching
deallocation call with <tt>P</tt> as a parameter. Otherwise the behavior is undefined. I don't know whether
receiving <tt>P</tt> with <tt>memory_order_consume</tt> fits this requirement. <tt>memory_order_relaxed</tt> does not.</p>
</li>
<li><p>If some memory is passed to a deallocation function, the implementation must ensure that the
deallocation call happens-before any allocation call that returns the same memory address.</p>
</li>
</ul>

<p><i>[2011-02-26: Hans comments and drafts wording]</i></p>


<p>The second requirement already exists, almost verbatim, as 18.6.1.4 [new.delete.dataraces] p. 1. 
I think this is where the statement belongs.  However, this paragraph requires work to correctly address 
the first part of the issue.
</p>


<p><b>Proposed resolution:</b></p>
<p>Change 18.6.1.4 [new.delete.dataraces] p. 1 as follows:</p>

<blockquote><p>
1 <del>The library versions of <tt>operator new</tt> and <tt>operator delete</tt>, user replacement versions of global 
<tt>operator new</tt> and <tt>operator delete</tt>, and the C standard library functions <tt>calloc</tt>, <tt>malloc</tt>, 
<tt>realloc</tt>, and <tt>free</tt> shall not introduce data races (1.10 [intro.multithread]) as a result 
of concurrent calls from different threads.</del><ins> For purposes of determining the existence of data races,
the library versions of <tt>operator new</tt>, user replacement versions of global <tt>operator new</tt>, and the C 
standard library functions <tt>calloc</tt> and <tt>malloc</tt> shall behave as though they accessed and modified only 
the storage referenced by the return value. The library versions of <tt>operator delete</tt>, user replacement
versions of <tt>operator delete</tt>, and the C standard library function <tt>free</tt> shall behave as though they 
accessed and modified only the storage referenced by their first argument. The C standard library <tt>realloc</tt> 
function shall behave as though it accessed and modified only the storage referenced by its first argument and by 
its return value.</ins> Calls to these functions that allocate or deallocate a particular unit of storage 
shall occur in a single total order, and each such deallocation call shall happen before the next allocation 
(if any) in this order.
</p></blockquote>





<hr>
<h3><a name="1526"></a>1526. [FCD] C++ should not impose thread safety requirements on C99 library implementations</h3>
<p><b>Section:</b> 17.6.5.9 [res.on.data.races] <b>Status:</b> <a href="lwg-active.html#Deferred">Deferred</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2011-03-24 <b>Last modified:</b> 2011-03-24</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Deferred">Deferred</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-111</b></p>

<p>Section 17.6.5.9 [res.on.data.races], Data Race Avoidance, requires the C++ Standard Library to avoid data races 
that might otherwise result from two threads making calls to C++ Standard Library functions on 
distinct objects. The C standard library is part of the C++ Standard Library and some C++ Standary library 
functions (parts of the Localization library, as well as Numeric Conversions in 21.5), are specified 
to make use of the C standard library. Therefore, the C++ standard indirectly imposes a requirement 
on the thread safety of the C standard library. However, since the C standard does not address the 
concept of thread safety conforming C implementations exist that do no provide such guarantees. 
This conflict needs to be reconciled.</p>

<p>Suggested resolution by national body comment:</p>

<blockquote><p>
remove the requirement to make use of <tt>strtol()</tt> and <tt>sprintf()</tt> since these functions depend on the 
global C locale and thus cannot be made thread safe.
</p></blockquote>

<p><i>[2011-03-24 Madrid meeting]</i></p>


<p>Deferred</p>



<p><b>Rationale:</b></p>No consensus to make a change at this time

<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2003"></a>2003. String exception inconsistency in erase.</h3>
<p><b>Section:</b> 21.4.1 [string.require] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Jos&eacute; Daniel Garc&iacute;a S&aacute;nchez <b>Opened:</b> 2010-10-21 <b>Last modified:</b> 2011-03-24</p>
<p><b>View all other</b> <a href="lwg-index.html#string.require">issues</a> in [string.require].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Clause 21.4.1 [string.require]p3 states:
</p>
<blockquote><p>
No <tt>erase()</tt> or <tt>pop_back()</tt> member function shall throw
any exceptions.
</p></blockquote>
<p>
However in 21.4.6.5 [string::erase] p2 the first version of <tt>erase</tt> has
</p>
<blockquote><p>
<i>Throws</i>: <tt>out_of_range</tt> if <tt>pos > size()</tt>.
</p></blockquote>

<p><i>[2011-03-24 Madrid meeting]</i></p>


<p>
Beman: Don't want to just change this, can we just say "unless otherwise specified"?
<p/>
Alisdair: Leave open, but update proposed resolution to say something like "unless otherwise specified".
<p/>
General agreement that it should be corrected but not a stop-ship.
<p/>
Action: Update proposed wording for issue 2003 as above, but leave Open. 
</p>


<p><b>Proposed resolution:</b></p>
<p>
Update [string.require]p/3:
</p>
<blockquote><p>
3 No <del><tt>erase()</tt> or</del> <tt>pop_back()</tt> member function
shall throw any exceptions.
</p></blockquote>





<hr>
<h3><a name="2005"></a>2005. <tt>unordered_map::insert(T&amp;&amp;)</tt> protection should apply to <tt>map</tt> too</h3>
<p><b>Section:</b> 23.4.4.4 [map.modifiers], 23.4.5.3 [multimap.modifiers] <b>Status:</b> <a href="lwg-active.html#Review">Review</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2010-10-14 <b>Last modified:</b> 2011-03-24</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In [unord.map.modifiers], the signature:
</p>
<blockquote><pre>
template &lt;class P&gt;
    pair&lt;iterator, bool&gt; insert(P&amp;&amp; obj);
</pre></blockquote>
<p>
now has an added Remarks paragraph:
</p>
<blockquote><p>
<i>Remarks</i>: This signature shall not participate in overload resolution unless <tt>P</tt>
is implicitly convertible to <tt>value_type</tt>.
</p></blockquote>
<p>
The same is true for <tt>unordered_multimap</tt>.
<p/>
But neither <tt>map</tt> nor <tt>multimap</tt> have this constraint, even though it is a
Good Thing(TM) in those cases as well.
</p>

<p><i>[
The submitter suggests: Add the same Remarks clause to [map.modifiers] and [multimap.modifiers].
]</i></p>


<p><i>[
2010-10-29 Daniel comments:
]</i></p>


<p>
I believe both paragraphs need more cleanup: First, the current Requires element conflict with the Remark; 
second, it seems to me that the whole single Requires element is intended to be split into a Requires
and an Effects element; third, the reference to <tt>tuple</tt> is incorrect (noticed by Paolo Carlini);
fourth, it refers to some non-existing <tt>InputIterator</tt> parameter relevant for a completely different
overload; sixth, the return type of the overload with hint is wrong.
The following proposed resolution tries to solve these issues as well and uses similar wording as for
the corresponding unordered containers. Unfortunately it has some redundancy over Table&nbsp;99, but I did
not remove the specification because of the more general template parameter <tt>P</tt> - the Table&nbsp;99 
requirements apply only for an argument <em>identical</em> to <tt>value_type</tt>.
<p/>
Proposed resolution:
</p>

<ol>
<li>Change 23.4.4.4 [map.modifiers] around p. 1 as indicated:
<blockquote><pre>
template &lt;class P&gt; pair&lt;iterator, bool&gt; insert(P&amp;&amp; x);
template &lt;class P&gt; <del>pair&lt;</del>iterator<del>, bool&gt;</del> insert(const_iterator position, P&amp;&amp; x);
</pre><blockquote><p>
1 <em>Requires</em>: <del><tt>P</tt> shall be convertible to </del><tt>value_type</tt><ins> is constructible 
from <tt>std::forward&lt;P&gt;(x)</tt>.</ins>.
<p/>
<del>If <tt>P</tt> is instantiated as a reference type, then the argument <tt>x</tt> is copied from. Otherwise <tt>x</tt> is considered
to be an rvalue as it is converted to <tt>value_type</tt> and inserted into the map. Specifically, in
such cases <tt>CopyConstructible</tt> is not required of <tt>key_type</tt> or <tt>mapped_type</tt> unless the conversion
from <tt>P</tt> specifically requires it (e.g., if <tt>P</tt> is a <tt>tuple&lt;const key_type, mapped_type&gt;</tt>, then <tt>key_type</tt>
must be <tt>CopyConstructible</tt>). The signature taking <tt>InputIterator</tt> parameters does not require
<tt>CopyConstructible</tt> of either <tt>key_type</tt> or <tt>mapped_type</tt> if the dereferenced <tt>InputIterator</tt> returns a
non-const rvalue <tt>pair&lt;key_type,mapped_type&gt;</tt>. Otherwise <tt>CopyConstructible</tt> is required for both
<tt>key_type</tt> and <tt>mapped_type</tt>.</del><br/>
<ins>? <em>Effects</em>: Inserts <tt>x</tt> converted to <tt>value_type</tt> if and only if there is no element in the container with
key equivalent to the key of <tt>value_type(x)</tt>. For the second form, the iterator <tt>position</tt> is a hint pointing to where the
search should start.</ins>
<p/>
<ins>? <em>Returns</em>: For the first form, the <tt>bool</tt> component of the returned <tt>pair</tt> object indicates whether the 
insertion took place and the iterator component - or for the second form the returned iterator - points to the element with key equivalent 
to the key of <tt>value_type(x)</tt>.</ins>
<p/>
<ins>? <em>Complexity</em>: Logarithmic in general, but amortized constant if <tt>x</tt> is inserted right before <tt>position</tt>.</ins>
<p/>
<ins>? <em>Remarks</em>: These signatures shall not participate in overload resolution unless <tt>P</tt> 
is implicitly convertible to <tt>value_type</tt>.</ins>
</p>
</blockquote></blockquote>
</li>
<li>Change 23.4.5.3 [multimap.modifiers] around p. 1 as indicated:
<blockquote><pre>
template &lt;class P&gt; iterator insert(P&amp;&amp; x);
template &lt;class P&gt; iterator insert(const_iterator position, P&amp;&amp; x);
</pre><blockquote><p>
1 <em>Requires</em>: <del><tt>P</tt> shall be convertible to </del><tt>value_type</tt> <ins>is constructible from 
<tt>std::forward&lt;P&gt;(x)</tt></ins>.
<p/>
<del>If <tt>P</tt> is instantiated as a reference type, then the argument <tt>x</tt> is copied from. Otherwise 
<tt>x</tt> is considered to be an rvalue as it is converted to <tt>value_type</tt> and inserted into the map. 
Specifically, in such cases <tt>CopyConstructible</tt> is not required of <tt>key_type</tt> or <tt>mapped_type</tt> 
unless the conversion from <tt>P</tt> specifically requires it (e.g., if <tt>P</tt> is a <tt>tuple&lt;const key_type, mapped_type&gt;</tt>, 
then <tt>key_type</tt> must be <tt>CopyConstructible</tt>). The signature taking <tt>InputIterator</tt> parameters 
does not require <tt>CopyConstructible</tt> of either <tt>key_type</tt> or <tt>mapped_type</tt> if the dereferenced 
<tt>InputIterator</tt> returns a non-const rvalue <tt>pair&lt;key_type, mapped_type&gt;</tt>. Otherwise <tt>CopyConstructible</tt> 
is required for both <tt>key_type</tt> and <tt>mapped_type</tt>.</del><br/>
<ins>? <em>Effects</em>: Inserts <tt>x</tt> converted to <tt>value_type</tt>. For the second form, the iterator <tt>position</tt> 
is a hint pointing to where the search should start.</ins>
<p/>
<ins>? <em>Returns</em>: An iterator that points to the element with key equivalent to the key of <tt>value_type(x)</tt>.</ins>
<p/>
<ins>? <em>Complexity</em>: Logarithmic in general, but amortized constant if <tt>x</tt> is inserted right before <tt>position</tt>.</ins>
<p/>
<ins>? <em>Remarks</em>: These signatures shall not participate in overload resolution unless <tt>P</tt> 
is implicitly convertible to <tt>value_type</tt>.</ins>
</p>
</blockquote></blockquote>
</li>
</ol>

<p><i>[
2010 Batavia:
]</i></p>


<p>
We need <tt>is_convertible</tt>, not <tt>is_constructible</tt>, both in ordered and unordered containers. 
</p>



<p><b>Proposed resolution:</b></p>
<ol>
<li>Add a new Remarks element after 23.4.4.4 [map.modifiers] p. 1:
<blockquote><pre>
template &lt;class P&gt; pair&lt;iterator, bool&gt; insert(P&amp;&amp; x);
template &lt;class P&gt; pair&lt;iterator, bool&gt; insert(const_iterator position, P&amp;&amp; x);
</pre><blockquote><p>
1 <em>Requires</em>: <tt>P</tt> shall be convertible to <tt>value_type</tt>.
<p/>
If <tt>P</tt> is instantiated as a reference type, then the argument <tt>x</tt> is copied from. Otherwise <tt>x</tt> is considered
to be an rvalue as it is converted to <tt>value_type</tt> and inserted into the map. Specifically, in
such cases <tt>CopyConstructible</tt> is not required of <tt>key_type</tt> or <tt>mapped_type</tt> unless the conversion
from <tt>P</tt> specifically requires it (e.g., if <tt>P</tt> is a <tt>tuple&lt;const key_type, mapped_type&gt;</tt>, then <tt>key_type</tt>
must be <tt>CopyConstructible</tt>). The signature taking <tt>InputIterator</tt> parameters does not require
<tt>CopyConstructible</tt> of either <tt>key_type</tt> or <tt>mapped_type</tt> if the dereferenced <tt>InputIterator</tt> returns a
non-const rvalue <tt>pair&lt;key_type,mapped_type&gt;</tt>. Otherwise <tt>CopyConstructible</tt> is required for both
<tt>key_type</tt> and <tt>mapped_type</tt>.
<p/>
<ins>? <em>Remarks</em>: These signatures shall not participate in overload resolution unless <tt>P</tt> 
is implicitly convertible to <tt>value_type</tt>.</ins>
</p>
</blockquote></blockquote>
</li>
<li>Change 23.4.5.3 [multimap.modifiers] around p. 1 as indicated:
<blockquote><pre>
template &lt;class P&gt; iterator insert(P&amp;&amp; x);
template &lt;class P&gt; iterator insert(const_iterator position, P&amp;&amp; x);
</pre><blockquote><p>
1 <em>Requires</em>: <tt>P</tt> shall be convertible to <tt>value_type</tt>.
<p/>
If <tt>P</tt> is instantiated as a reference type, then the argument <tt>x</tt> is copied from. Otherwise 
<tt>x</tt> is considered to be an rvalue as it is converted to <tt>value_type</tt> and inserted into the map. 
Specifically, in such cases <tt>CopyConstructible</tt> is not required of <tt>key_type</tt> or <tt>mapped_type</tt> 
unless the conversion from <tt>P</tt> specifically requires it (e.g., if <tt>P</tt> is a <tt>tuple&lt;const key_type, mapped_type&gt;</tt>, 
then <tt>key_type</tt> must be <tt>CopyConstructible</tt>). The signature taking <tt>InputIterator</tt> parameters 
does not require <tt>CopyConstructible</tt> of either <tt>key_type</tt> or <tt>mapped_type</tt> if the dereferenced 
<tt>InputIterator</tt> returns a non-const rvalue <tt>pair&lt;key_type, mapped_type&gt;</tt>. Otherwise <tt>CopyConstructible</tt> 
is required for both <tt>key_type</tt> and <tt>mapped_type</tt>.
<p/>
<ins>? <em>Remarks</em>: These signatures shall not participate in overload resolution unless <tt>P</tt> 
is implicitly convertible to <tt>value_type</tt>.</ins>
</p>
</blockquote></blockquote>
</li>
</ol>





<hr>
<h3><a name="2008"></a>2008. Conflicting Error Conditions for <tt>packaged_task::operator()</tt></h3>
<p><b>Section:</b> 30.6.9.1 [futures.task.members] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2010-06-21 <b>Last modified:</b> 2011-02-17</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures.task.members">active issues</a> in [futures.task.members].</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.task.members">issues</a> in [futures.task.members].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The Throws clause for <tt>packaged_task::operator()</tt> says that it throws "a
<tt>future_error</tt> exception object if there is no associated asynchronous
state or the stored task has already been invoked." However, the Error
Conditions clause does not define an error condition when the stored task has
already been invoked, only when the associated state is already ready (i.e. the
invocation has completed).
</p>

<p><i>[2011-02-17 Anthony provides an alternative resolution]</i></p>


<p><strong>Previous</strong> proposed resolution:</p>

<p>
Change the first bullet item in 30.6.9.1 [futures.task.members] /22:
</p>

<blockquote><pre>
void operator()(ArgTypes... args);
</pre>
<blockquote>
<p>
20 ...
</p>
<p>
21 ...
</p>
<p>
22 <i>Error conditions:</i>
</p>
<ul>
<li>
<tt>promise_already_satisfied</tt> if <del>the associated asynchronous state is
already ready</del> <ins><tt>operator()</tt> has already been called</ins>.
</li>
<li>
<tt>no_state</tt> if <tt>*this</tt> has no associated asynchronous state.
</li>
</ul>
</blockquote>
</blockquote>



<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
Change the first bullet item in 30.6.9.1 [futures.task.members] p. 17:
</p>

<blockquote><pre>
void operator()(ArgTypes... args);
</pre>
<blockquote>
<p>
15 ...
</p>
<p>
16 ...
</p>
<p>
17 <i>Error conditions:</i>
</p>
<ul>
<li>
<tt>promise_already_satisfied</tt> if the <del>associated asynchronous state is already 
ready</del><ins>stored task has already been invoked</ins>.
</li>
<li>
<tt>no_state</tt> if <tt>*this</tt> has no associated asynchronous state.
</li>
</ul>
</blockquote>
</blockquote>
</li>

<li>
<p>
Change the first bullet item in 30.6.9.1 [futures.task.members] p. 21:
</p>

<blockquote><pre>
void make_ready_at_thread_exit(ArgTypes... args);
</pre>
<blockquote>
<p>
19 ...
</p>
<p>
20 ...
</p>
<p>
21 <i>Error conditions:</i>
</p>
<ul>
<li>
<tt>promise_already_satisfied</tt> if the <del>associated asynchronous state already has a stored value or
exception</del><ins>stored task has already been invoked</ins>.
</li>
<li>
<tt>no_state</tt> if <tt>*this</tt> has no associated asynchronous state.
</li>
</ul>
</blockquote>
</blockquote>

</li>
</ol>






<hr>
<h3><a name="2010"></a>2010. <tt>is_* traits</tt> for binding operations can't be meaningfully specialized</h3>
<p><b>Section:</b> 20.8.9.1.1 [func.bind.isbind] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Sean Hunt <b>Opened:</b> 2010-07-19 <b>Last modified:</b> 2011-02-20</p>
<p><b>View all other</b> <a href="lwg-index.html#func.bind.isbind">issues</a> in [func.bind.isbind].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.8.9.1.1 [func.bind.isbind] says for <tt>is_bind_expression</tt>:
</p>

<blockquote><p>
Users may specialize this template to indicate that a type should be
treated as a subexpression in a <tt>bind</tt> call.
</p></blockquote>

<p>
But it also says:
</p>

<blockquote><p>
If <tt>T</tt> is a type returned from <tt>bind</tt>,
<tt>is_bind_expression&lt;T&gt;</tt> shall be publicly derived from
<tt>integral_constant&lt;bool, true&gt;</tt>, otherwise from
<tt>integral_constant&lt;bool, false&gt;</tt>.
</p></blockquote>

<p>
This means that while the user is free to specialize, any specialization
would have to be <tt>false</tt> to avoid violating the second
requirement. A similar problem exists for <tt>is_placeholder</tt>.
</p>


<p><i>[
2010 Batavia (post meeting session)
]</i></p>

<p>
Alisdair recognises this is clearly a bug introduced by some wording he
wrote, the sole purpose of this metafunction is as a customization point
for users to write their own <tt>bind</tt>-expression types that participate
in the standard library <tt>bind</tt> protocol.  The consensus was that this
should be fixed in Madrid, moved to Open.
</p>

<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2011"></a>2011. unexpected output required of strings</h3>
<p><b>Section:</b> 21.4.8.9 [string.io] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> James Kanze <b>Opened:</b> 2010-07-23 <b>Last modified:</b> 2011-03-24</p>
<p><b>View all other</b> <a href="lwg-index.html#string.io">issues</a> in [string.io].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
What should the following code output? 
</p>

<blockquote><pre>
#include &lt;string>
#include &lt;iostream>
#include &lt;iomanip>

int 
main() 
{ 
   std::string test("0X1Y2Z"); 
   std::cout.fill('*'); 
   std::cout.setf(std::ios::internal, std::ios::adjustfield); 
   std::cout &lt;&lt; std::setw(8) &lt;&lt; test &lt;&lt; std::endl; 
} 
</pre></blockquote>

<p>
I would expect "<tt>**0X1Y2Z</tt>", and this is what the compilers I have access
to (VC++, g++ and Sun CC) do.  But according to the standard, it should be
"<tt>0X**1Y2Z</tt>":
</p>

<p>
21.4.8.9 [string.io]/5: 
</p>

<blockquote><pre>
template&lt;class charT, class traits, class Allocator&gt;
  basic_ostream&lt;charT, traits&gt;&amp;
    operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os, const basic_string&lt;charT,traits,Allocator&gt;&amp; str);
</pre><blockquote><p>
<i>Effects:</i> Behaves as a formatted output function (27.7.3.6.1 [ostream.formatted.reqmts]). After constructing 
a <tt>sentry</tt> object, if this object returns <tt>true</tt> when converted to a value of type <tt>bool</tt>, 
determines padding as described in 22.4.2.2.2 [facet.num.put.virtuals], then inserts the resulting sequence of
characters seq as if by calling <tt>os.rdbuf()-&gt;sputn(seq, n)</tt>, where <tt>n</tt> is the larger of 
<tt>os.width()</tt> and <tt>str.size()</tt>; then calls <tt>os.width(0)</tt>.
</p></blockquote>
</blockquote>

<p>
22.4.2.2.2 [facet.num.put.virtuals]/5: 
</p>

<blockquote>
<p>
[...] 
</p>

<p>
<b>Stage 3:</b> A local variable is initialized as
</p>

<blockquote><pre>
fmtflags adjustfield= (flags &amp; (ios_base::adjustfield));
</pre></blockquote>

<p>
The location of any padding is determined according to Table 88. 
</p>

<p>
If <tt>str.width()</tt> is nonzero and the number of <tt>charT</tt>'s in the
sequence after stage 2 is less than <tt>str.width()</tt>, then enough fill
characters are added to the sequence at the position indicated for padding to
bring the length of the sequence to <tt>str.width()</tt>. <tt>str.width(0)</tt>
is called.
</p>

<table border="1">
<caption>Table 88 &mdash; Fill padding</caption>
<tr>
<th>State</th>
<th>Location</th>
</tr>

<tr>
<td><tt>adjustfield == ios_base::left</tt></td>
<td>pad after</td>
</tr>

<tr>
<td><tt>adjustfield == ios_base::right</tt></td>
<td>pad before</td>
</tr>

<tr>
<td><tt>adjustfield == internal</tt> and a sign occurs in the representation</td>
<td>pad after the sign</td>
</tr>

<tr>
<td><tt>adjustfield == internal</tt> and representation after stage 1 began with 0x or 0X</td>
<td>pad after x or X</td>
</tr>

<tr>
<td><i>otherwise</i></td>
<td>pad before</td>
</tr>
</table>

</blockquote>

<p>
Although it's not 100% clear what "the sequence after stage 2" should mean here,
when there is no stage 2, the only reasonable assumption is that it is the
contents of the string being output.  In the above code, the string being output
is "<tt>0X1Y2Z</tt>", which starts with "<tt>0X</tt>", so the padding should be
inserted "after x or X", and not before the string. I believe that this is a
defect in the standard, and not in the three compilers I tried.
</p>

<p><i>[
2010 Batavia (post meeting session)
]</i></p>

<p>
Consensus that all known implementations are consistent, and disagree with the
standard. Preference is to fix the standard before implementations start trying
to conform to the current spec, as the current implementations have the preferred
form. Howard volunteered to drught for Madrid, move to Open.
</p>

<p><i>[2011-03-24 Madrid meeting]</i></p>


<p>
Daniel Kr&uuml;gler volunteered to provide wording, interacting with Dietmar and
Bill. 
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2012"></a>2012. Associative maps should insert <tt>pair</tt>, not <tt>tuple</tt></h3>
<p><b>Section:</b> 23.4 [associative] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Paolo Carlini <b>Opened:</b> 2010-10-29 <b>Last modified:</b> 2011-03-24</p>
<p><b>View all other</b> <a href="lwg-index.html#associative">issues</a> in [associative].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I'm seeing something strange in the paragraphs 23.4.4.4 [map.modifiers] and 23.4.5.3 [multimap.modifiers]:
they both talk about <tt>tuple&lt;const key_type, mapped_type&gt;</tt> but I think they
should be talking about <tt>pair&lt;const key_type, mapped_type&gt;</tt> because, among
other reasons, a <tt>tuple</tt> is not convertible to a <tt>pair</tt>. If I replace <tt>tuple</tt>
with <tt>pair</tt> everything makes sense to me.
<p/>
The proposed resolution is obvious. 
</p>

<p><i>[
2010-11-07 Daniel comments
]</i></p>


<p>
This is by far not the only necessary fix within both sub-clauses. For details see the 2010-10-29 comment in 
<a href="lwg-active.html#2005">2005</a>.
</p>

<p><i>[2011-03-24 Madrid meeting]</i></p>


<p>
Paolo: Don't think we can do it now.
<p/>
Daniel K: Agrees. 
</p>


<p><b>Proposed resolution:</b></p>
<p>
Apply the resolution proposed by the 2010-10-29 comment in <a href="lwg-active.html#2005">2005</a>.
</p>





<hr>
<h3><a name="2013"></a>2013. Do library implementers have the freedom to add <tt>constexpr</tt>?</h3>
<p><b>Section:</b> 17.6.5.6 [constexpr.functions] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2010-11-12 <b>Last modified:</b> 2011-02-20</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>Suppose that a particular function is not tagged as constexpr in the standard,
but that, in some particular implementation, it is possible to write it within
the constexpr constraints. If an implementer tags such a function as constexpr,
is that a violation of the standard or is it a conforming extension?</p>

<p>There are two questions to consider. First, is this allowed under the
as-if rule? Second, if it does not fall under as-if, is there
(and should there be) any special license granted to implementers
to do this anyway, sort of the way we allow elision of copy constructors
even though it is detectable by users?</p>

<p>I believe that this does not fall under "as-if", so implementers
probably don't have that freedom today. I suggest changing the WP
to grant it. Even if we decide otherwise, however, I suggest that
we make it explicit.</p>



<p><b>Proposed resolution:</b></p>
<p><i>In 17.6.4.6 [constexpr.functions], change paragraph 1 to:</i></p>

<blockquote><p>
<ins>This standard explicitly requires that certain standard library functions
are <tt>constexpr</tt> [dcl.constexpr].
Additionally, an implementation may declare any function to be <tt>constexpr</tt>
if that function's definition satisfies the necessary constraints.</ins>
Within any header that provides any non-defining declarations of <tt>constexpr</tt>
functions or constructors an implementation shall provide corresponding definitions. 
</p></blockquote>






<hr>
<h3><a name="2015"></a>2015. Incorrect pre-conditions for some type traits</h3>
<p><b>Section:</b> 20.9.4 [meta.unary] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Nikolay Ivchenkov <b>Opened:</b> 2010-11-08 <b>Last modified:</b> 2011-02-20</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.unary">issues</a> in [meta.unary].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>According to N3126&nbsp;&#x2011;&nbsp;3.9/9,</p>

<p>&quot;Scalar types, trivial class types (Clause 9), arrays of such types
and <i>cv</i>&#x2011;qualified versions of these types (3.9.3) are collectively
called <i>trivial types</i>.&quot;</p>

<p>Thus, an array (possibly of unknown bound) can be trivial type, non&#x2011;trivial type, 
or an array type whose triviality cannot be determined because its element type is incomplete.</p>

<p>According to N3126&nbsp;&#x2011;&nbsp;Table 45, preconditions for <tt>std::is_trivial</tt> are
defined as follows:</p>

<p>&quot;<tt>T</tt> shall be a complete type, (possibly <i>cv</i>-qualified) <tt>void</tt>, 
or an array of unknown bound&quot;</p>

<p>It seems that &quot;an array of unknown bound&quot; should be changed to &quot;an
array of unknown bound of a complete element type&quot;. Preconditions for
some other templates (e.g., <tt>std::is_trivially_copyable</tt>,
<tt>std::is_standard_layout</tt>, <tt>std::is_pod</tt>, and <tt>std::is_literal_type</tt>) should
be changed similarly.</p>

<p>On the other hand, some preconditions look too restrictive. For
example, <tt>std::is_empty</tt> and <tt>std::is_polymorphic</tt> might accept any
incomplete non&#x2011;class type.</p>

<p><i>[2011-02-18: Daniel provides wording proposal]</i></p>


<p>
While reviewing the individual preconditions I could find three different groups of
either too weakening or too strengthening constraints:
</p>
<ol>
<li><pre>is_empty/is_polymorphic/is_abstract/has_virtual_destructor:</pre>

<p>These traits can only apply for <em>non&#x2011;union class types</em>, otherwise the result must
always be false</p>
</li>

<li><pre>is_base_of:</pre>

<p>Similar to the previous bullet, but the current wording comes already near to that ideal,
it only misses to add the <em>non&#x2011;union</em> aspect.</p>
</li>

<li><pre>is_trivial/is_trivially_copyable/is_standard_layout/is_pod/is_literal_type:</pre>

<p>These traits always require that <tt>std::remove_all_extents&lt;T&gt;::type</tt> to be <tt><i>cv</i> void</tt> or 
a complete type.</p>
</li>
</ol>


<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
Modify the pre-conditions of the following type traits in 20.9.4.3 [meta.unary.prop], Table 48 &mdash; Type property predicates:
</p>

<blockquote>
<table border="1">
<caption>Table 48 &mdash; Type property predicates</caption>
<tr>
<th>Template</th>
<th>Condition</th>
<th>Preconditions</th>
</tr>

<tr>
<td colspan="3" style="text-align:center;">...</td>
</tr>

<tr>
<td><tt>template &lt;class T&gt;<br/>
struct is_trivial;</tt></td>
<td><tt>T</tt> is a trivial type (3.9)</td>
<td><tt><ins>remove_all_extents&lt;</ins>T<ins>&gt;::type</ins></tt><br/>
shall be a complete type<del>,</del><ins> or</ins> (possibly<br/>
cv-qualified) <tt>void</tt><del>, or an array of<br/>
unknown bound</del>.</td>
</tr>

<tr>
<td><tt>template &lt;class T&gt;<br/>
struct is_trivially_copyable;</tt></td>
<td><tt>T</tt> is a trivially copyable<br/>
type (3.9)</td>
<td><tt><ins>remove_all_extents&lt;</ins>T<ins>&gt;::type</ins></tt><br/>
shall be a complete type<del>,</del><ins> or</ins> (possibly<br/>
cv-qualified) <tt>void</tt><del>, or an array of<br/>
unknown bound</del>.</td>
</tr>

<tr>
<td><tt>template &lt;class T&gt;<br/>
struct is_standard_layout;</tt></td>
<td><tt>T</tt> is a standard-layout<br/>
type (3.9)</td>
<td><tt><ins>remove_all_extents&lt;</ins>T<ins>&gt;::type</ins></tt><br/>
shall be a complete type<del>,</del><ins> or</ins> (possibly<br/>
cv-qualified) <tt>void</tt><del>, or an array of<br/>
unknown bound</del>.</td>
</tr>

<tr>
<td><tt>template &lt;class T&gt;<br/>
struct is_pod;</tt></td>
<td><tt>T</tt> is a POD type (3.9)</td>
<td><tt><ins>remove_all_extents&lt;</ins>T<ins>&gt;::type</ins></tt><br/>
shall be a complete type<del>,</del><ins> or</ins> (possibly<br/>
cv-qualified) <tt>void</tt><del>, or an array of<br/>
unknown bound</del>.</td>
</tr>

<tr>
<td><tt>template &lt;class T&gt;<br/>
struct is_literal_type;</tt></td>
<td><tt>T</tt> is a literal type (3.9)</td>
<td><tt><ins>remove_all_extents&lt;</ins>T<ins>&gt;::type</ins></tt><br/>
shall be a complete type<del>,</del><ins> or</ins> (possibly<br/>
cv-qualified) <tt>void</tt><del>, or an array of<br/>
unknown bound</del>.</td>
</tr>

<tr>
<td><tt>template &lt;class T&gt;<br/>
struct is_empty;</tt></td>
<td><tt>T</tt> is a class type, but not a<br/>
union type, with no<br/>
non-static data members<br/>
other than bit-fields of<br/>
length 0, no virtual<br/>
member functions, no<br/>
virtual base classes, and<br/>
no base class B for which<br/>
<tt>is_empty&lt;B&gt;::value</tt> is<br/>
false.</td>
<td><del><tt>T</tt> shall be a complete type,<br/>
(possibly cv-qualified) <tt>void</tt>, or<br/>
an array of unknown bound</del><ins>If <tt>T</tt><br/>
is a non&#x2011;union class type, <tt>T</tt><br/>
shall be a complete type</ins>.</td>
</tr>

<tr>
<td><tt>template &lt;class T&gt;<br/>
struct is_polymorphic;</tt></td>
<td><tt>T</tt> is a polymorphic<br/>
class (10.3)</td>
<td><del><tt>T</tt> shall be a complete type,<br/>
type, (possibly cv-qualified) <tt>void</tt>, or<br/>
an array of unknown bound</del><ins>If <tt>T</tt><br/>
is a non&#x2011;union class type, <tt>T</tt><br/>
shall be a complete type</ins>.</td>
</tr>

<tr>
<td><tt>template &lt;class T&gt;<br/>
struct is_abstract;</tt></td>
<td><tt>T</tt> is an abstract<br/>
class (10.4)</td>
<td><del><tt>T</tt> shall be a complete type,<br/>
type, (possibly cv-qualified) <tt>void</tt>, or<br/>
an array of unknown bound</del><ins>If <tt>T</tt><br/>
is a non&#x2011;union class type, <tt>T</tt><br/>
shall be a complete type</ins>.</td>
</tr>

<tr>
<td colspan="3" style="text-align:center;">...</td>
</tr>

<tr>
<td><tt>template &lt;class T&gt;<br/>
struct has_virtual_destructor;</tt></td>
<td><tt>T</tt> has a virtual<br/>
destructor (12.4)</td>
<td><del><tt>T</tt> shall be a complete type,<br/>
(possibly cv-qualified) <tt>void</tt>, or<br/>
an array of unknown bound</del><ins>If <tt>T</tt><br/>
is a non&#x2011;union class type, <tt>T</tt><br/>
shall be a complete type</ins>.</td>
</tr>

</table>
</blockquote>

</li>

<li>
<p>
Modify the pre-conditions of the following type traits in 20.9.6 [meta.rel], Table 50 &mdash; Type relationship predicates:
</p>

<blockquote>
<table border="1">
<caption>Table 50 &mdash; Type relationship predicates</caption>
<tr>
<th>Template</th>
<th>Condition</th>
<th>Comments</th>
</tr>

<tr>
<td colspan="3" style="text-align:center;">...</td>
</tr>

<tr>
<td><tt>template &lt;class Base, class<br/>
Derived&gt;<br/>
struct is_base_of;</tt></td>
<td><tt>Base</tt> is a base class of<br/>
<tt>Derived</tt> (10) without<br/>
regard to cv-qualifiers<br/>
or <tt>Base</tt> and <tt>Derived</tt><br/>
are not unions and<br/>
name the same class<br/>
type without regard to<br/>
cv-qualifiers</td>
<td>If <tt>Base</tt> and <tt>Derived</tt> are<br/>
<ins>non&#x2011;union</ins> class types<br/>
and are different types<br/>
(ignoring possible cv-qualifiers)<br/>
then <tt>Derived</tt> shall be a complete<br/>
type. [ <i>Note</i>: Base classes that<br/>
are private, protected, or<br/>
ambigious are, nonetheless, base<br/>
classes. &mdash; <i>end note</i> ]</td>
</tr>

<tr>
<td colspan="3" style="text-align:center;">...</td>
</tr>

</table>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2016"></a>2016. <tt>Allocators</tt> must be no-throw <i>swappable</i></h3>
<p><b>Section:</b> 17.6.3.5 [allocator.requirements] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2010-11-17 <b>Last modified:</b> 2011-02-20</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
During the Batavia meeting it turned out that there is a definition
hole for types satisfying the <tt>Allocators</tt> requirements: The problem
became obvious when it was discussed whether all <tt>swap</tt> functions 
of <tt>Containers</tt> with internal data handles can be safely tagged
with <tt>noexcept</tt> or not. While it is correct that the implicit
<tt>swap</tt> function of an allocator is required to be a no-throw
operation (because move/copy-constructors and assignment operators are
required to be no-throw functions), there are no such requirements
for specialized <tt>swap</tt> overloads for a particular allocator.
<p/>
But this requirement is essential because the <tt>Containers</tt> are
required to support <i>swappable</i> <tt>Allocators</tt>, when the value
<tt>allocator_traits&lt;&gt;::propagate_on_container_swap</tt> evaluates
to <tt>true</tt>.
</p>
<p><i>[2011-02-10 Alberto, Daniel, and Pablo collaborated on the proposed wording]</i></p>

<p>
The proposed resolution (based on N3225) attempts to solve the following problems:
</p>
<ol>
<li>Table 44 &mdash; Allocator requirements, expression rows 
<tt>X::propagate_on_container_copy_assignment</tt>, <tt>X::propagate_on_container_move_assignment</tt>, and
<tt>X::propagate_on_container_swap</tt> only describe operations, but no requirements. In fact, if and only
if these compile-time predicates evaluate to <tt>true</tt>, the <em>additional</em> requirements
<tt>CopyAssignable</tt>,  no-throw <tt>MoveAssignable</tt>, and no-throw lvalue <tt>Swappable</tt>, 
respectively, are imposed on the allocator types.</li>
<li>23.2.1 [container.requirements.general] p. 9 misses to refer to the correct swap conditions: The current wording does not relate to
17.6.3.2 [swappable.requirements] as it should and omits to mention that lvalues shall be swapped. Additional there is one
situation described twice in p. 8 and p. 9 (undefined behaviour unless <tt>a.get_allocator() == b.get_allocator()</tt>
or <tt>allocator_traits&lt;allocator_type&gt;::propagate_on_container_swap::value == true</tt>), which should be cleaned up.</li>
</ol>



<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
Adapt the following three rows from Table 44 &mdash; Allocator requirements:
</p>

<blockquote>
<table border="1">
<caption>Table 44 &mdash; Allocator requirements</caption>
<tr>
<th>
Expression
</th>

<th>
Return type
</th>

<th>
Assertion/note<br/>pre-/post-condition
</th>

<th>
Default
</th>

</tr>

<tr>
<td><tt>X::propagate_on_container_copy_assignment</tt></td>

<td>Identical to or derived from <tt>true_type</tt><br/>
or <tt>false_type</tt></td>

<td><tt>true_type</tt> only if an allocator of type <tt>X</tt> should be copied<br/> 
when the client container is copy-assigned. <ins>See Note B, below.</ins></td>

<td><tt>false_type</tt></td>
</tr>

<tr>
<td><tt>X::propagate_on_container_move_assignment</tt></td>

<td>Identical to or derived from <tt>true_type</tt><br/>
or <tt>false_type</tt></td>

<td><tt>true_type</tt> only if an allocator of type <tt>X</tt> should be moved<br/>
when the client container is move-assigned. <ins>See Note B, below.</ins></td>

<td><tt>false_type</tt></td>
</tr>

<tr>
<td><tt>X::propagate_on_container_swap</tt></td>

<td>Identical to or derived from <tt>true_type</tt><br/>
or <tt>false_type</tt></td>

<td><tt>true_type</tt> only if an allocator of type <tt>X</tt> should be swapped<br/>
when the client container is swapped. <ins>See Note B, below.</ins></td>

<td><tt>false_type</tt></td>
</tr>

</table>
</blockquote>


</li>

<li>
<p>Following 17.6.3.5 [allocator.requirements] p. 3 insert a new normative paragraph:</p>

<blockquote><p>
<ins>Note B: If <tt>X::propagate_on_container_copy_assignment::value</tt> is true, <tt>X</tt> shall 
satisfy the <tt>CopyAssignable</tt> requirements (Table 39  [copyassignable]). 
If <tt>X::propagate_on_container_move_assignment::value</tt> is true, <tt>X</tt> shall satisfy the 
<tt>MoveAssignable</tt> requirements (Table 38  [moveassignable]) and the move operation
shall not throw exceptions. If <tt>X::propagate_on_container_swap::value</tt> is true, lvalues of 
<tt>X</tt> shall be swappable (17.6.3.2 [swappable.requirements]) and the <tt>swap</tt> operation 
shall not throw exceptions.</ins>
</p></blockquote>
</li>

<li>
<p>Modify 23.2.1 [container.requirements.general] p. 8 and p. 9 as indicated:</p>

<blockquote><p>
8 - [..] The allocator may be replaced only via assignment or <tt>swap()</tt>. Allocator replacement is 
performed by copy assignment, move assignment, or swapping of the allocator only if 
<tt>allocator_traits&lt;allocator_type&gt;::propagate_on_container_copy_assignment::value</tt>,
<tt>allocator_traits&lt;allocator_type&gt;::propagate_on_container_move_assignment::value</tt>, 
or <tt>allocator_traits&lt;allocator_type&gt;::propagate_on_container_swap::value</tt> is true 
within the implementation of the corresponding container operation. <del>The behavior of a call to 
a container's <tt>swap</tt> function is undefined unless the objects being swapped have allocators that compare 
equal or <tt>allocator_traits&lt;allocator_type&gt;::propagate_on_container_swap::value</tt> is true</del>. In all 
container types defined in this Clause, the member <tt>get_allocator()</tt> returns a copy of the allocator 
used to construct the container or, if that allocator has been replaced, a copy of the most recent replacement.
<p/>
9 - The expression <tt>a.swap(b)</tt>, for containers <tt>a</tt> and <tt>b</tt> of a standard container type 
other than <tt>array</tt>, shall exchange the values of <tt>a</tt> and <tt>b</tt> without invoking any move, 
copy, or swap operations on the individual container elements. <ins>Lvalues of a</ins><del>A</del>ny <tt>Compare</tt>, 
<tt>Pred</tt>, or <tt>Hash</tt> object<del>s</del> belonging to <tt>a</tt> and <tt>b</tt> shall be swappable 
and shall be exchanged by <del>unqualified calls to non-member</del> <ins>calling</ins> <tt>swap</tt> 
<ins>as described in 17.6.3.2 [swappable.requirements]</ins>. If <tt>allocator_traits&lt;allocator_type&gt;::propagate_on_container_swap::value</tt> 
is <tt>true</tt>, then <ins>lvalues of <tt>allocator_type</tt> shall be swappable and</ins> the allocators of <tt>a</tt> and 
<tt>b</tt> shall also be exchanged using <ins>a</ins> <del>an unqualified call to non-member</del> 
<tt>swap</tt> <ins>call</ins> <ins>as described in 17.6.3.2 [swappable.requirements]</ins>. Otherwise, 
<del>they</del><ins>the allocators</ins> shall not be swapped, and the behavior is undefined unless
<tt>a.get_allocator() == b.get_allocator()</tt>. Every iterator referring to an element in one container before
the swap shall refer to the same element in the other container after the swap. It is unspecified whether an
iterator with value <tt>a.end()</tt> before the swap will have value <tt>b.end()</tt> after the swap.
</p></blockquote>
</li>
</ol>






<hr>
<h3><a name="2018"></a>2018. <tt>regex_traits::isctype</tt> Returns clause is wrong</h3>
<p><b>Section:</b> 28.7 [re.traits] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2010-11-16 <b>Last modified:</b> 2011-03-24</p>
<p><b>View all other</b> <a href="lwg-index.html#re.traits">issues</a> in [re.traits].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>28.7 [re.traits] p. 12 says:</p>

<blockquote><p>
returns true if <tt>f</tt> bitwise or&#39;ed with the result of calling
<tt>lookup_classname</tt> with an iterator pair that designates the character
sequence &quot;w&quot; is not equal to <tt>0</tt> and <tt>c == '_'</tt>
</p></blockquote>

<p>
If the bitmask value corresponding to &quot;w&quot; has a non-zero value (which
it must do) then the bitwise or with any value is also non-zero, and
so <tt>isctype('_', f)</tt> returns true for any <tt>f</tt>. Obviously this is wrong,
since <tt>'_'</tt> is not in every <tt>ctype</tt> category.
</p>

<p>
There&#39;s a similar problem with the following phrases discussing the
&quot;blank&quot; char class.
</p>


<p><b>Proposed resolution:</b></p>
<p>Replace the Returns clause with a description in terms of <tt>ctype</tt>
categories, rather than pseudocode in terms of bitwise operations.
(full replacement wording to follow)
</p>





<hr>
<h3><a name="2021"></a>2021. Further incorrect usages of <tt>result_of</tt></h3>
<p><b>Section:</b> 20.8.9.1.2 [func.bind.bind], 30.6.1 [futures.overview], 30.6.8 [futures.async] <b>Status:</b> <a href="lwg-active.html#Review">Review</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2010-12-07 <b>Last modified:</b> 2011-03-24</p>
<p><b>View all other</b> <a href="lwg-index.html#func.bind.bind">issues</a> in [func.bind.bind].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Issue <a href="lwg-active.html#2017">2017</a> points out some incorrect usages of <tt>result_of</tt> in the
declaration of the function call operator overload of <tt>reference_wrapper</tt>,
but there are more such specification defects:
</p>
<ol>
<li>According to 20.8.9.1.2 [func.bind.bind] p. 3: 
<blockquote><p>
[..] The effect of <tt>g(u1, u2, ..., uM)</tt> shall be <tt>INVOKE(fd, v1, v2, ..., vN, result_of&lt;FD cv (V1, V2, ..., VN)&gt;::type)</tt> [..]
</p></blockquote>
<p>
but <tt>fd</tt> is defined as &quot;an lvalue of type <tt>FD</tt> constructed from <tt>std::forward&lt;F&gt;(f)</tt>&quot;. This means that
the above usage must refer to <tt>result_of&lt;FD cv <strong>&amp;</strong> (V1, V2, ..., VN)&gt;</tt> instead.
</p>
</li>
<li><p>
Similar in 20.8.9.1.2 [func.bind.bind] p. 10 bullet 2 we have:
</p>
<blockquote><p>
if the value of <tt>is_bind_expression&lt;TiD&gt;::value</tt> is true, the argument is <tt>tid(std::forward&lt;Uj&gt;(uj)...)</tt>
and its type <tt>Vi</tt> is <tt>result_of&lt;TiD cv (Uj...)&gt;::type</tt>
</p></blockquote>
<p>
Again, <tt>tid</tt> is defined as &quot;lvalue of type <tt>TiD</tt> constructed from <tt>std::forward&lt;Ti&gt;(ti)</tt>&quot;. This means that
the above usage must refer to <tt>result_of&lt;TiD cv <strong>&amp;</strong> (Uj...)&gt;</tt> instead. We also have similar defect as in
<a href="lwg-active.html#2017">2017</a> in regard to the argument types, this leads us to the further corrected form 
<tt>result_of&lt;TiD cv <strong>&amp;</strong> (Uj<strong>&amp;&amp;</strong>...)&gt;</tt>. This is not the end: Since the <tt>Vi</tt>
are similar sensitive to the argument problem, the last part must say: 
<p/>
&quot;[..] its type <tt>Vi</tt> is <tt>result_of&lt;TiD cv <strong>&amp;</strong> (Uj<strong>&amp;&amp;</strong>...)&gt;::type <strong>&amp;&amp;</strong>&quot;</tt>
<p/>
(The bound arguments <tt>Vi</tt> can never be <tt>void</tt> types, therefore we don't need 
to use the more defensive <tt>std::add_rvalue_reference</tt> type trait)
</p>
</li>
<li><p>The function template <tt>async</tt> is declared as follows (the other overload has the same problem):</p>
<blockquote><pre>
template &lt;class F, class... Args&gt;
future&lt;typename result_of&lt;F(Args...)&gt;::type&gt;
async(F&amp;&amp; f, Args&amp;&amp;... args);
</pre></blockquote><p>
This usage has the some same problems as we have found in <tt>reference_wrapper</tt> (<a href="lwg-active.html#2017">2017</a>) and more: According to
the specification in 30.6.8 [futures.async] the effective result type is that of the call of
</p><blockquote><pre>
INVOKE(decay_copy(std::forward&lt;F&gt;(f)), decay_copy(std::forward&lt;Args&gt;(args))...)
</pre></blockquote><p>
First, <tt>decay_copy</tt> potentially modifies the effective types to <tt>decay&lt;F&gt;::type</tt> and <tt>decay&lt;Args&gt;::type...</tt>.
Second, the current specification is not really clear, what the value category of callable type or the arguments shall be: According
to the second bullet of 30.6.8 [futures.async] p. 3:
</p>
<blockquote><p>
Invocation of the deferred function evaluates <tt>INVOKE(g, xyz)</tt> where <tt>g</tt> is the stored value of 
<tt>decay_copy(std::forward&lt;F&gt;(f))</tt> and <tt>xyz</tt> is the stored copy of 
<tt>decay_copy(std::forward&lt;Args&gt;(args))...</tt>.
</p></blockquote><p>
This seems to imply that lvalues are provided in contrast to the direct call expression of 30.6.8 [futures.async] p. 2
which implies rvalues instead. The specification needs to be clarified.
</p>
</li>
</ol>


<p><b>Proposed resolution:</b></p>
<p>
The suggested wording changes are against the working draft N3242.
</p>
<ol>
<li>
<p>Change 20.8.9.1.2 [func.bind.bind] p. 3 as indicated:</p>

<blockquote><p>
<i>Returns</i>: A forwarding call wrapper <tt>g</tt> with a weak result type (20.8.2). The effect of 
<tt>g(u1, u2, ..., uM)</tt> shall be <tt>INVOKE(fd, v1, v2, ..., vN, result_of&lt;FD cv <ins>&amp;</ins> (V1, V2, ..., VN)&gt;::type)</tt>, 
where <i>cv</i> represents the <i>cv</i>-qualifiers of <tt>g</tt> and the values and types of the bound arguments 
<tt>v1, v2, ..., vN</tt> are determined as specified below. [..]
</p></blockquote>

</li>

<li>
<p>Change 20.8.9.1.2 [func.bind.bind] p. 10 bullet 2 as indicated:</p>

<blockquote><p>
if the value of <tt>is_bind_expression&lt;TiD&gt;::value</tt> is <tt>true</tt>, the argument is 
<tt>tid(std::forward&lt;Uj&gt;(uj)...)</tt> and its type <tt>Vi</tt> is 
<tt>result_of&lt;TiD cv <ins>&amp;</ins> (Uj<ins>&amp;&amp;</ins>...)&gt;::type<ins>&amp;&amp;</ins></tt>;
</p></blockquote>

</li>

<li>
<p>
This resolution assumes that the wording of 30.6.8 [futures.async] is incorrectly implying rvalues
as arguments of <tt>INVOKE</tt>, those should be lvalues instead.
</p>

<p>
Change the function signatures in header <tt>&lt;future&gt;</tt> synopsis 30.6.1 [futures.overview] p. 1
and in 30.6.8 [futures.async] p. 1 as indicated:
</p>

<blockquote><pre>
template &lt;class F, class... Args&gt;
future&lt;typename result_of&lt;<ins>typename decay&lt;</ins>F<ins>&gt;::type&amp;</ins>(<ins>typename decay&lt;</ins>Args<ins>&gt;::type&amp;</ins>...)&gt;::type&gt;
async(F&amp;&amp; f, Args&amp;&amp;... args);
template &lt;class F, class... Args>
future&lt;typename result_of&lt;<ins>typename decay&lt;</ins>F<ins>&gt;::type&amp;</ins>(<ins>typename decay&lt;</ins>Args<ins>&gt;::type&amp;</ins>...)&gt;::type&gt;
async(launch policy, F&amp;&amp; f, Args&amp;&amp;... args);
</pre></blockquote>
</li>

<li>
<p>Change 30.6.8 [futures.async] p. 4 as indicated: [Note: There is one tiny editorial correction that completes one
<tt>::</tt> scope specifier]
[Note: This sub-section need more wording: The call expressions used imply a different value category]
</p>

<blockquote><p>
<i>Returns</i>: an object of type 
<tt>future&lt;typename result_of&lt;<ins>typename decay&lt;</ins>F<ins>&gt;::type&amp;</ins>(<ins>typename decay&lt;</ins>Args<ins>&gt;::type&amp;</ins>...)&gt;:<ins>:</ins>type&gt;</tt> 
that refers to the associated asynchronous state created by this call to <tt>async</tt>.
</p></blockquote>
</li>
</ol>





<hr>
<h3><a name="2032"></a>2032. Incorrect synchronization clause of <tt>async</tt> function</h3>
<p><b>Section:</b> 30.6.8 [futures.async] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Alberto Ganesh Barbati <b>Opened:</b> 2011-02-17 <b>Last modified:</b> 2011-02-20</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.async">issues</a> in [futures.async].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Clause 30.6.8 [futures.async] has undergone significant rewording
in Batavia. Due to co-presence of at least three different sources
of modification there is a part where changes have overlapped
(marked by an Editor's note), which should be reconciled. Moreover,
I believe that a few non-overlapping sentences are now incorrect
and should be fixed, so the problem cannot be handled editorially.
(See c++std-lib-29667.)
</p>



<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p> 
Edit 30.6.4 [futures.state], paragraph 3 as follows.
</p>

<blockquote>
<p>
An <dfn>asynchronous return object</dfn>
is an object that reads results from an associated asynchronous state.
A <dfn>waiting function</dfn> of an asynchronous return object
is one that potentially blocks
to wait for the associated asynchronous state to be made ready.
<ins>If a waiting function can return
before the state is made ready because of a timeout (30.2.5),
then it is a <dfn>timed waiting function</dfn>,
otherwise it is a <dfn>non-timed waiting function</dfn>.</ins>
</p>
</blockquote>
</li>

<li>
<p>
Edit within 30.6.8 [futures.async] paragraph 3 bullet 2 as follows.
</p>

<blockquote>
<p>
<i>Effects:</i>
[...]
</p>
<ul><li>if <code>policy &amp; launch::deferred</code> is non-zero &mdash; [...]
The associated asynchronous state is not made ready
until the function has completed.
The first call to a <ins>non-timed waiting</ins> function
<ins>(30.6.4 [futures.state])</ins>
<del>requiring a non-timed wait</del>
on an asynchronous return object
referring to <del>the</del> <ins>this</ins>
associated asynchronous state
<del>created by this <code>async</code> call to become ready</del>
shall invoke the deferred function
in the thread that called the waiting function<del>;</del><ins>.</ins>
<del>once</del> <ins>Once</ins> evaluation of
<code><var>INVOKE</var>(g, xyz)</code> begins,
the function is no longer considered deferred.
[...]
</li></ul>
</blockquote>
</li>

<li>
<p>
Edit 30.6.8 [futures.async] paragraph 5 as follows.
</p>

<blockquote>
<p>
<i>Synchronization:</i>
Regardless of the provided <code>policy</code> argument,
</p>
<ul>
<li>
the invocation of <code>async</code> synchronizes with (1.10)
the invocation of <code>f</code>.
[<i>Note:</i>
this statement applies even when the corresponding future object
is moved to another thread.
&mdash;<i>end note</i>];
and
</li>
<li>
the completion of the function <code>f</code>
is sequenced before (1.10) the associated asynchronous state is made ready.
[<i>Note:</i>
<code>f</code> might not be called at all,
so its completion might never happen.
&mdash;<i>end note</i>]
</li>
</ul>

<p>
<del>If <code>policy &amp; launch::async</code> is non-zero,</del>
<ins>If the implementation chooses the <code>launch::async</code> policy,</ins>
</p>
<ul>
<li>
a call to a waiting function on an asynchronous return object
that shares the associated asynchronous state
created by this <code>async</code> call
shall block until the associated thread has completed,
as if joined (30.3.1.5);
</li>
<li>
<del>the <code>join()</code> on the created thread object</del>
<ins>the associated thread completion</ins>
synchronizes with (1.10)
the return from the first function
that successfully detects the ready status of the associated asynchronous state
or with the return from the last function that 
releases the associated asynchronous state <del>returns</del>,
whichever happens first.
<del><b>[Editor's note:
N3196 changes the following sentence as indicated.
N3188 removes the sentence.
Please pick one.]</b>
If the invocation is deferred,
the completion of the invocation of the deferred function
synchronizes with the successful return
from a call to a waiting function on the associated asynchronous state.</del>
</li>
</ul>
</blockquote>

</li>
</ol>






<hr>
<h3><a name="2033"></a>2033. Preconditions of <tt>reserve</tt>, <tt>shrink_to_fit</tt>, and <tt>resize</tt> functions</h3>
<p><b>Section:</b> 23.3.6.3 [vector.capacity], 23.3.3.3 [deque.capacity] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Nikolay Ivchenkov <b>Opened:</b> 2011-02-20 <b>Last modified:</b> 2011-03-24</p>
<p><b>View other</b> <a href="lwg-index-open.html#vector.capacity">active issues</a> in [vector.capacity].</p>
<p><b>View all other</b> <a href="lwg-index.html#vector.capacity">issues</a> in [vector.capacity].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I have several questions with regard to the working paper N3225 (C++0x working draft):
</p>
<ol>
<li><p>
Where the working draft specifies preconditions for <tt>shrink_to_fit</tt>
member function of <tt>std::vector</tt> and <tt>std::deque</tt>?
</p></li>
<li><p>
Where the working draft specifies preconditions for '<tt>void reserve(size_type n)</tt>' 
member function of <tt>std::vector</tt>?
</p></li>
<li><p>
Does a call to '<tt>void resize(size_type sz)</tt>' of <tt>std::vector</tt> require
the element type to be <tt>DefaultConstructible</tt>? If yes, why such
requirement is not listed in the <i>Requires</i> paragraph?
</p></li>
<li><p>
Does a call to '<tt>void resize(size_type sz)</tt>' of <tt>std::vector</tt> require
the element type to be <tt>MoveAssignable</tt> because the call <tt>erase(begin() + sz, end())</tt> 
mentioned in the <i>Effects</i> paragraph would require the element type to be <tt>MoveAssignable</tt>?
</p></li>
<li><p>
Why <tt>CopyInsertable</tt> requirement is used for '<tt>void resize(size_type sz)</tt>' of <tt>std::vector</tt> 
instead of <tt>MoveInsertable</tt> requirement?
</p></li>
</ol>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2034"></a>2034. Initialization of atomics is misspecified so that it doesn't preserve sequential consistency</h3>
<p><b>Section:</b> 29.3 [atomics.order] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hans Boehm <b>Opened:</b> 2011-02-26 <b>Last modified:</b> 2011-03-16</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.order">active issues</a> in [atomics.order].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.order">issues</a> in [atomics.order].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
This violates the core intent of the memory model, as stated in the note in 1.10 [intro.multithread] p. 21.
</p>

<p>
This was discovered by Mark Batty, and pointed out in their POPL 2011 paper, "Mathematizing C++ Concurrency",
section 4, "Sequential consistency of SC atomics".  The problem is quite technical, but well-explained in that paper.
</p>

<p>
This particular issue was not understood at the time the FCD comments were generated. But it is closely related 
to a number of FCD comments. It should have arisen from 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3224.html#US171">US-171</a>, though that's not 
the actual history.
</p>

<p>This issue has been under discussion for several months in a group that included a half dozen or so of the 
most interested committee members. The P/R represents a well-considered consensus among us:</p>

<p><i>[2011-03-16: Jens updates wording]</i></p>




<p><b>Proposed resolution:</b></p>
<p>Modify 29.3 [atomics.order] p.3, so that the normative part reads:</p>

<blockquote><p>
3 There shall be a single total order <i>S</i> on all <tt>memory_order_seq_cst</tt> operations, consistent 
with the &quot;happens before&quot; order and modification orders for all affected locations, such that each 
<tt>memory_order_seq_cst</tt> operation that loads a value observes either the last 
preceding modification according to this order <i>S</i><ins>, <i>A</i> (if any)</ins>, or the result of an operation 
<ins><i>X</i></ins> that <del>is not</del><ins>does not happen before <i>A</i> and that is not</ins> <tt>memory_order_seq_cst</tt>. 
[ <i>Note</i>: Although it is not explicitly required that <i>S</i> include locks, it can always be extended 
to an order that does include lock and unlock operations, since the ordering between those is already included 
in the &quot;happens before&quot; ordering. &mdash; <i>end note</i> ]
</p></blockquote>








<hr>
<h3><a name="2035"></a>2035. Output iterator requirements are broken</h3>
<p><b>Section:</b> 24.2.4 [output.iterators] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2011-02-27 <b>Last modified:</b> 2011-03-24</p>
<p><b>View other</b> <a href="lwg-index-open.html#output.iterators">active issues</a> in [output.iterators].</p>
<p><b>View all other</b> <a href="lwg-index.html#output.iterators">issues</a> in [output.iterators].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>During the Pittsburgh meeting the proposal <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3066.html">N3066</a>
became accepted because it fixed several severe issues related to the iterator specification. But the current working draft (N3225)
does not reflect all these changes. Since I'm unaware whether every correction can be done editorial, this issue is submitted to take
care of that. To give one example: All expressions of Table 108 &mdash; &quot;Output iterator requirements&quot; have a post-condition
that the iterator is incrementable. This is impossible, because it would exclude any finite sequence that is accessed by an output 
iterator, such as a pointer to a C array. The N3066 wording changes did not have these effects.
</p>

<p><i>[2011-03-01: Daniel comments:]</i></p>


<p>This issue has some overlap with the issue <a href="lwg-active.html#2038">2038</a> and I would prefer if we
could solve both at one location. I suggest the following approach:
</p>
<ol>
<li><p>The terms <tt><i>dereferencable</i></tt> and <tt><i>incrementable</i></tt> could be defined in a more
general way not restricted to iterators (similar to the concepts <tt>HasDereference</tt> and 
<tt>HasPreincrement</tt> from working draft N2914). But on the other hand, all current usages of 
<tt><i>dereferencable</i></tt> and <tt><i>incrementable</i></tt> are involved with types that satisfy 
iterator requirements. Thus, I believe that it is sufficient for C++0x to add corresponding definitions to 
24.2.1 [iterator.requirements.general] and to let all previous usages of these terms refer to this 
sub-clause. Since the same problem occurs with the past-the-end iterator, this proposal suggest providing 
similar references to usages that precede its definition as well.
</p></li>
<li><p>We also need to ensure that all iterator expressions get either an operational semantics in
terms of others or we need to add missing pre- and post-conditions. E.g. we have the following
ones without semantics:
</p><blockquote><pre>
*r++ = o // output iterator
*r--     // bidirectional iterator
</pre></blockquote><p>
According to the <a href="http://www.sgi.com/tech/stl/OutputIterator.html">SGI specification</a>
these correspond to
</p><blockquote><pre>
{ *r = o; ++r; }                         // output iterator
{ reference tmp = *r; --r; return tmp; } // bidirectional iterator
</pre></blockquote><p>
respectively. Please note especially the latter expression for bidirectional iterator. It fixes a problem
that we have for forward iterator as well: Both these iterator categories provide stronger guarantees
than input iterator, because the result of the dereference operation is <tt>reference</tt>, and <strong>not</strong>
only convertible to the value type (The exact form from the SGI documentation does not correctly refer to
<tt>reference</tt>).
</p></li>
</ol>

<p><i>[2011-03-14: Daniel comments and updates the suggested wording]</i></p>


<p>In addition to the before mentioned necessary changes there is another one need, which
became obvious due to issue <a href="lwg-active.html#2042">2042</a>: <tt>forward_list&lt;&gt;::before_begin()</tt> returns
an iterator value which is not dereferencable, but obviously the intention is that it should
be incrementable. This leads to the conclusion that imposing dereferencable as a requirement
for the expressions <tt>++r</tt> is wrong: We only need the iterator to be incrementable. A
similar conclusion applies to the expression <tt>--r</tt> of bidirectional iterators.</p>


<p><b>Proposed resolution:</b></p>
<ol>
<li><p>Add a reference to 24.2.1 [iterator.requirements.general] to the following parts of the
library preceding Clause 24 Iterators library: (I stopped from 23.2.5 [unord.req] on, because
the remaining references are the concrete containers)</p>
<ol>
<li><p>17.6.3.2 [swappable.requirements] p. 5:</p>

<blockquote><p>
5 A type <tt>X</tt> satisfying any of the iterator requirements (24.2) is <tt><i>ValueSwappable</i></tt> if, 
for any dereferenceable <ins>(24.2.1 [iterator.requirements.general])</ins> object <tt>x</tt> of type 
<tt>X</tt>, <tt>*x</tt> is swappable.
</p></blockquote>
</li>

<li><p>17.6.3.5 [allocator.requirements], Table 27 &mdash> &quot;Descriptive variable definitions&quot;, 
row with the expression <tt>c</tt>:</p>

<blockquote><p>
a dereferenceable <ins>(24.2.1 [iterator.requirements.general])</ins> pointer of type <tt>C*</tt>
</p></blockquote>

</li>

<li><p>20.6.3.2 [pointer.traits.functions]:</p>
<blockquote><p>
<i>Returns</i>: The first template function returns a dereferenceable <ins>(24.2.1 [iterator.requirements.general])</ins> 
pointer to <tt>r</tt> obtained by calling <tt>Ptr::pointer_to(r)</tt>;  [&hellip;]
</p></blockquote>
</li>

<li><p>21.4.3 [string.iterators] p. 2:</p>
<blockquote><p>
<i>Returns</i>: An iterator which is the past-the-end value <ins>(24.2.1 [iterator.requirements.general])</ins>.
</p></blockquote>
</li>

<li><p>22.4.5.1.2 [locale.time.get.virtuals] p. 11:</p>
<blockquote><pre>
iter_type do_get(iter_type s, iter_type end, ios_base&amp; f,
  ios_base::iostate&amp; err, tm *t, char format, char modifier) const;
</pre><blockquote><p>
<i>Requires</i>: <tt>t</tt> shall be dereferenceable <ins>(24.2.1 [iterator.requirements.general])</ins>.
</p></blockquote></blockquote>
</li>

<li><p>23.2.1 [container.requirements.general] p. 6:</p>

<blockquote><p>
[&hellip;]  <tt>end()</tt> returns an iterator which is the past-the-end <ins>(24.2.1 [iterator.requirements.general])</ins> 
value for the container.  [&hellip;]
</p></blockquote>
</li>

<li><p>23.2.3 [sequence.reqmts] p. 3:</p>

<blockquote><p>
[&hellip;]  <tt>q</tt> denotes a valid dereferenceable <ins>(24.2.1 [iterator.requirements.general])</ins> 
const iterator to <tt>a</tt>,  [&hellip;]
</p></blockquote>
</li>

<li><p>23.2.4 [associative.reqmts] p. 8 (I omit intentionally one further reference in the same sub-clause):</p>

<blockquote><p>
[&hellip;]  <tt>q</tt> denotes a valid dereferenceable <ins>(24.2.1 [iterator.requirements.general])</ins> 
const iterator to <tt>a</tt>,  [&hellip;]
</p></blockquote>
</li>

<li><p>23.2.5 [unord.req] p. 10 (I omit intentionally one further reference in the same sub-clause):</p>

<blockquote><p>
[&hellip;]  <tt>q</tt> and <tt>q1</tt> are valid dereferenceable <ins>(24.2.1 [iterator.requirements.general])</ins> 
const iterators to <tt>a</tt>,  [&hellip;]
</p></blockquote>
</li>
</ol>

</li>
<li><p>Edit 24.2.1 [iterator.requirements.general] p. 5 as indicated (The intent is to properly define
<i>incrementable</i> and to ensure some further library guarantee related to past-the-end iterator values):</p>

<blockquote><p>
5 Just as a regular pointer to an array guarantees that there is a pointer value pointing past the last element
of the array, so for any iterator type there is an iterator value that points past the last element of a
corresponding sequence. These values are called <i>past-the-end values</i>. Values of an iterator <tt>i</tt> for which the
expression <tt>*i</tt> is defined are called <i>dereferenceable</i>. <ins>Values of an iterator <tt>i</tt> for which the
expression <tt>++i</tt> is defined are called <i>incrementable</i>. </ins> The library never assumes that 
past-the-end values are dereferenceable <ins>or incrementable</ins>. Iterators can also have singular values 
that are not associated with any sequence. [&hellip;]
</p></blockquote>
</li>

<li><p>Modify the column contents of Table 106 &mdash; &quot;Iterator requirements&quot;, 
24.2.2 [iterator.iterators], as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 106 &mdash; Iterator requirements</caption>

<tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Assertion&frasl;note<br/>pre-&frasl;post-condition</th>
</tr>

<tr>
<td><tt>*r</tt></td>
<td><tt>reference</tt></td>
<td><tt>&nbsp;</tt></td>
<td>pre: <tt>r</tt> is dereferenceable.</td>
</tr>

<tr>
<td><tt>++r</tt></td>
<td><tt>X&amp;</tt></td>
<td><tt>&nbsp;</tt></td>
<td><ins>pre: <tt>r</tt> is incrementable.</ins></td>
</tr>

</table>
</blockquote>
</li>

<li><p>Modify the column contents of Table 107 &mdash; &quot;Input iterator requirements&quot;, 
24.2.3 [input.iterators], as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 107 &mdash; Input iterator requirements (in addition to Iterator)</caption>

<tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Assertion&frasl;note<br/>pre-&frasl;post-condition</th>
</tr>

<tr>
<td><tt>a != b</tt></td>
<td>contextually<br/>
convertible to <tt>bool</tt></td>
<td><tt>!(a == b)</tt></td>
<td>pre: <tt>(a, b)</tt> is in the domain<br/>
of <tt>==</tt>.
</td>
</tr>

<tr>
<td><tt>*a</tt></td>
<td>convertible to <tt>T</tt></td>
<td><tt>&nbsp;</tt></td>
<td>pre: <tt>a</tt> is dereferenceable.<br/>
The expression<br/>
<tt>(void)*a, *a</tt> is equivalent<br/>
to <tt>*a</tt>.<br/>
If <tt>a == b</tt> and <tt>(a,b)</tt> is in<br/>
the domain of <tt>==</tt> then <tt>*a</tt> is<br/>
equivalent to <tt>*b</tt>.
</td>
</tr>

<tr>
<td><tt>a-&gt;m</tt></td>
<td><tt>&nbsp;</tt></td>
<td><tt>(*a).m</tt></td>
<td>pre: <tt>a</tt> is dereferenceable.
</td>
</tr>

<tr>
<td><tt>++r</tt></td>
<td><tt>X&amp;</tt></td>
<td><tt>&nbsp;</tt></td>
<td>pre: <tt>r</tt> is <del>dereferenceable</del><ins>incrementable</ins>.<br/>
post: <tt>r</tt> is dereferenceable or<br/>
<tt>r</tt> is past-the-end.<br/>
post: any copies of the<br/>
previous value of <tt>r</tt> are no<br/>
longer required either to be<br/>
dereferenceable<ins>, incrementable,</ins><br/>
or to be in the domain of <tt>==</tt>.
</td>
</tr>

<tr>
<td><tt>(void)r++</tt></td>
<td><tt>&nbsp;</tt></td>
<td><ins><tt>(void)++r</tt></ins></td>
<td><del>equivalent to <tt>(void)++r</tt></del></td>
</tr>

<tr>
<td><tt>*r++</tt></td>
<td>convertible to <tt>T</tt></td>
<td><tt>{ T tmp = *r;<br/>
++r;<br/>
return tmp; }
</tt></td>
<td><tt>&nbsp;</tt></td>
</tr>

</table>
</blockquote>
</li>

<li>
<p>Modify the column contents of Table 108 &mdash; &quot;Output iterator requirements&quot;, 
24.2.4 [output.iterators], as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 108 &mdash; Output iterator requirements (in addition to Iterator)</caption>

<tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Assertion&frasl;note<br/>pre-&frasl;post-condition</th>
</tr>

<tr>
<td><tt>*r = o</tt></td>
<td>result is not used</td>
<td><tt>&nbsp;</tt></td>
<td><ins>pre: <tt>r</tt> is dereferenceable.</ins><br/>
<i>Remark</i>: After this operation<br/>
<tt>r</tt> is not required to be<br/>
dereferenceable.<br/>
post: <tt>r</tt> is incrementable.
</td>
</tr>

<tr>
<td><tt>++r</tt></td>
<td><tt>X&amp;</tt></td>
<td><tt>&nbsp;</tt></td>
<td><ins>pre: <tt>r</tt> is incrementable.</ins><br/>
<tt>&amp;r == &amp;++r</tt>.<br/>
<i>Remark</i>: After this operation<br/>
<tt>r</tt> is not required to be<br/>
dereferenceable <ins>or incrementable</ins>.<br/>
<del>post: <tt>r</tt> is incrementable.</del>
</td>
</tr>

<tr>
<td><tt>r++</tt></td>
<td>convertible to <tt>const X&amp;</tt></td>
<td><tt>{ X tmp = r;<br/>
  ++r;<br/>
  return tmp; }</tt>
</td>
<td><i>Remark</i>: After this operation<br/>
<tt>r</tt> is not required to be<br/>
dereferenceable <ins>or incrementable</ins>.<br/>
<del>post: <tt>r</tt> is incrementable.</del>
</td>
</tr>

<tr>
<td><tt>*r++ = o</tt></td>
<td>result is not used</td>
<td><ins><tt>{ *r = o; ++r; }</tt></ins></td>
<td><i>Remark</i>: After this operation<br/>
<tt>r</tt> is not required to be<br/>
dereferenceable <ins>or incrementable</ins>.<br/>
<del>post: <tt>r</tt> is incrementable.</del>
</td>
</tr>
</table>
</blockquote>
</li>

<li><p>Modify the column contents of Table 109 &mdash; &quot;Forward iterator requirements&quot;, 
24.2.5 [forward.iterators], as indicated [<i>Rationale</i>: Since the return type of the
expression <tt>*r++</tt> is now guaranteed to be type <tt>reference</tt>, the implied operational
semantics from input iterator based on value copies is wrong &mdash; <i>end rationale</i>]</p>

<blockquote>
<table border="1">
<caption>Table 109 &mdash; Forward iterator requirements (in addition to input iterator)</caption>

<tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Assertion&frasl;note<br/>pre-&frasl;post-condition</th>
</tr>

<tr>
<td><tt>r++</tt></td>
<td>convertible to <tt>const X&amp;</tt></td>
<td><tt>{ X tmp = r;<br/>
  ++r;<br/>
  return tmp; }</tt>
</td>
<td><tt>&nbsp;</tt></td>
</tr>

<tr>
<td><tt>*r++</tt></td>
<td>reference</td>
<td><ins><tt>{ reference tmp = *r;<br/>
 ++r;<br/> 
 return tmp; }</tt></ins></td>
<td><tt>&nbsp;</tt></td>
</tr>
</table>
</blockquote>

</li>

<li><p>Modify the column contents of Table 110 &mdash; &quot;Bidirectional iterator requirements&quot;, 
24.2.6 [bidirectional.iterators], as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 110 &mdash; Bidirectional iterator requirements (in addition to forward iterator)</caption>

<tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Assertion&frasl;note<br/>pre-&frasl;post-condition</th>
</tr>

<tr>
<td><tt>--r</tt></td>
<td><tt>X&amp;</tt></td>
<td><tt>&nbsp;</tt></td>
<td>pre: there exists <tt>s</tt> such that<br/>
<tt>r == ++s</tt>.<br/>
post: <tt>r</tt> is <del>dereferenceable</del><ins>incrementable</ins>.<br/>
<tt>--(++r) == r</tt>.<br/>
<tt>--r == --s</tt> implies <tt>r == s</tt>.<br/>
<tt>&amp;r == &amp;--r</tt>.
</td>
</tr>

<tr>
<td><tt>r--</tt></td>
<td>convertible to <tt>const X&amp;</tt></td>
<td><tt>{ X tmp = r;<br/>
  --r;<br/>
  return tmp; }</tt>
</td>
<td><tt>&nbsp;</tt></td>
</tr>

<tr>
<td><tt>*r--</tt></td>
<td>reference</td>
<td><ins><tt>{ reference tmp = *r;<br/>
 --r;<br/> 
 return tmp; }</tt></ins></td>
<td><tt>&nbsp;</tt></td>
</tr>
</table>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2037"></a>2037. <tt>atomic</tt> free functions incorrectly specified</h3>
<p><b>Section:</b> 29.2 [atomics.syn] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2011-03-01 <b>Last modified:</b> 2011-03-09</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.syn">active issues</a> in [atomics.syn].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.syn">issues</a> in [atomics.syn].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>In earlier specifications of atomics the template specialization <tt>atomic&lt;<i>integer</i>&gt;</tt> 
was derived from <tt>atomic_integer</tt> (e.g. <tt>atomic&lt;int&gt;</tt> was derived from <tt>atomic_int</tt>), 
and the working draft required free functions such as</p>

<blockquote><pre>
int atomic_load(const atomic_int*)
</pre></blockquote>

<p>for each of the <tt>atomic_integer</tt> types. This worked fine with normal function overloading.</p>

<p>For the post-Batavia working draft, N3193 removed the requirement that <tt>atomic&lt;integer&gt;</tt> 
be derived from <tt>atomic_integer</tt> and replaced the free functions taking pointers to 
<tt>atomic_integer</tt> with template functions taking <tt>atomic_type*</tt>, such as</p>

<blockquote><pre>
template &lt;class T&gt; T atomic_load(const atomic_type*);
</pre></blockquote>

<p>and a code comment explaining that <tt>atomic_type</tt> can be either <tt>atomic&lt;T&gt;</tt> or a 
named base class of <tt>atomic&lt;T&gt;</tt>. The latter possibility is supposed to allow existing 
implementations based on the previous specification to continue to conform.</p>

<p>From history, this allowance seems to imply that functions like <tt>atomic_load</tt> can be non-template 
free functions, as they were before. The explicit requirements do not allow this, and, by requiring that 
they be templates, make them far more complicated. As the specification is currently written, code that 
uses an implementation that uses a base class would have to provide an explicit template type:</p>

<blockquote><pre>
atomic&lt;int&gt; my_atomic_int;
atomic_load&lt;int&gt;(&amp;my_atomic_int);
</pre></blockquote>

<p>That type argument isn't needed when <tt>atomic_type</tt> is <tt>atomic&lt;T&gt;</tt>, but cautious 
users would always provide it to make their code portable across different implementations of the 
standard library.</p>

<p>One possibility for the implementor would be to do some template meta-programming to infer the type 
<tt>T</tt> when there are no function parameters of type <tt>T</tt>, but without running afoul of the 
prohibition on adding parameters with default values (17.6.5.4 [global.functions]/3).</p>

<p>So the promise that implementations of the previous specification continue to conform has not been 
met. The specification of these free functions should be rewritten to support library code written to 
the previous specification or the vacuous promise should be removed.
</p>

<p><i>[2011-03-08: Lawrence comments and drafts wording:]</i></p>


<p>One of the goals is to permit atomics code to compile under both C and C++. Adding explicit 
template arguments would defeat that goal.
<p/>
The intent was to permit the normal function overloads for <tt>atomic_int</tt> when <tt>atomic_int</tt> 
is distinct from <tt>atomic&lt;int&gt;</tt>. That intent was not reflected in the wording.
</p>



<p><b>Proposed resolution:</b></p>
<p>Explicitly permit free functions.</p>

<ol>
<li>
<p>Edit within the header <tt>&lt;atomic&gt;</tt> synopsis 29.2 [atomics.syn] as follows:</p>

<blockquote><pre>
<i>// 29.6.1, general operations on atomic types</i>
<del><i>// In the following declarations, <em>atomic_type</em> is either</i>
<i>// </i><code>atomic&lt;T&gt;</code><i> or a named base class for</i> <code>T</code><i> from</i>
<i>// Table 145 or inferred from</i>
<i>// Table 146.</i></del>
<ins><i>// In the following declarations, <em>atomic-type</em> is either</i> 
<i>// </i><code>atomic&lt;T&gt;</code><i> or a named base class for</i> <code>T</code><i> from</i>
<i>// Table 145 or inferred from</i>
<i>// Table 146.</i>
<i>// If it is </i><code>atomic&lt;T&gt;</code><i>, then the declaration is a template
// declaration prefixed with</i> <code>template &lt;class T&gt;</code></ins>
<del>template &lt;class T&gt;</del>
bool atomic_is_lock_free(const volatile <em><del>atomic_type</del><ins>atomic-type</ins></em>*);
<del>template &lt;class T&gt;</del>
bool atomic_is_lock_free(const <em><del>atomic_type</del><ins>atomic-type</ins></em>*);
<del>template &lt;class T&gt;</del>
void atomic_init(volatile <em><del>atomic_type</del><ins>atomic-type</ins></em>*, T);
<del>template &lt;class T&gt;</del>
void atomic_init(<em><del>atomic_type</del><ins>atomic-type</ins></em>*, T);
<del>template &lt;class T&gt;</del>
void atomic_store(volatile <em><del>atomic_type</del><ins>atomic-type</ins></em>*, T);
<del>template &lt;class T&gt;</del>
void atomic_store(<em><del>atomic_type</del><ins>atomic-type</ins></em>*, T);
<del>template &lt;class T&gt;</del>
void atomic_store_explicit(volatile <em><del>atomic_type</del><ins>atomic-type</ins></em>*, T, memory_order);
<del>template &lt;class T&gt;</del>
void atomic_store_explicit(<em><del>atomic_type</del><ins>atomic-type</ins></em>*, T, memory_order);
<del>template &lt;class T&gt;</del>
T atomic_load(const volatile <em><del>atomic_type</del><ins>atomic-type</ins></em>*);
<del>template &lt;class T&gt;</del>
T atomic_load(const <em><del>atomic_type</del><ins>atomic-type</ins></em>*);
<del>template &lt;class T&gt;</del>
T atomic_load_explicit(const volatile <em><del>atomic_type</del><ins>atomic-type</ins></em>*, memory_order);
<del>template &lt;class T&gt;</del>
T atomic_load_explicit(const <em><del>atomic_type</del><ins>atomic-type</ins></em>*, memory_order);
<del>template &lt;class T&gt;</del>
T atomic_exchange(volatile <em><del>atomic_type</del><ins>atomic-type</ins></em>*, T);
<del>template &lt;class T&gt;</del>
T atomic_exchange(<em><del>atomic_type</del><ins>atomic-type</ins></em>*, T);
<del>template &lt;class T&gt;</del>
T atomic_exchange_explicit(volatile <em><del>atomic_type</del><ins>atomic-type</ins></em>*, T, memory_order);
<del>template &lt;class T&gt;</del>
T atomic_exchange_explicit(<em><del>atomic_type</del><ins>atomic-type</ins></em>*, T, memory_order);
<del>template &lt;class T&gt;</del>
bool atomic_compare_exchange_weak(volatile <em><del>atomic_type</del><ins>atomic-type</ins></em>*, T*, T);
<del>template &lt;class T&gt;</del>
bool atomic_compare_exchange_weak(<em><del>atomic_type</del><ins>atomic-type</ins></em>*, T*, T);
<del>template &lt;class T&gt;</del>
bool atomic_compare_exchange_strong(volatile <em><del>atomic_type</del><ins>atomic-type</ins></em>*, T*, T);
<del>template &lt;class T&gt;</del>
bool atomic_compare_exchange_strong(<em><del>atomic_type</del><ins>atomic-type</ins></em>*, T*, T);
<del>template &lt;class T&gt;</del>
bool atomic_compare_exchange_weak_explicit(volatile <em><del>atomic_type</del><ins>atomic-type</ins></em>*, T*, T,
  memory_order, memory_order);
<del>template &lt;class T&gt;</del>
bool atomic_compare_exchange_weak_explicit(<em><del>atomic_type</del><ins>atomic-type</ins></em>*, T*, T.
  memory_order, memory_order);
<del>template &lt;class T&gt;</del>
bool atomic_compare)exchange_strong_explicit(volatile <em><del>atomic_type</del><ins>atomic-type</ins></em>*, T*, T,
  memory_order, memory_order);
<del>template &lt;class T&gt;</del>
bool atomic_compare_exchange_strong_explicit(<em><del>atomic_type</del><ins>atomic-type</ins></em>*, T*, T,
  memory_order, memory_order);
  
<i>// 29.6.2, templated operations on atomic types</i>
<del><i>// In the following declarations, <em>atomic_type</em> is either
// </i><code>atomic&lt;T&gt;</code><i> or a named base class for</i> <code>T</code><i> from
// Table 145 or inferred from
// Table 146.</i></del>
template &lt;class T&gt;
T atomic_fetch_add(volatile <del><em>atomic-type</em></del><ins>atomic&lt;T&gt;</ins>*, T);
template &lt;class T&gt;
T atomic_fetch_add(<del><em>atomic-type</em></del><ins>atomic&lt;T&gt;</ins>*, T);
template &lt;class T&gt;
T atomic_fetch_add_explicit(volatile <del><em>atomic-type</em></del><ins>atomic&lt;T&gt;</ins>*, T, memory_order);
template &lt;class T&gt;
T atomic_fetch_add_explicit(<del><em>atomic-type</em></del><ins>atomic&lt;T&gt;</ins>*, T, memory_order);
template &lt;class T&gt;
T atomic_fetch_sub(volatile <del><em>atomic-type</em></del><ins>atomic&lt;T&gt;</ins>*, T);
template &lt;class T&gt;
T atomic_fetch_sub(<del><em>atomic-type</em></del><ins>atomic&lt;T&gt;</ins>*, T);
template &lt;class T&gt;
T atomic_fetch_sub_explicit(volatile <del><em>atomic-type</em></del><ins>atomic&lt;T&gt;</ins>*, T, memory_order);
template &lt;class T&gt;
T atomic_fetch_sub_explicit(<del><em>atomic-type</em></del><ins>atomic&lt;T&gt;</ins>*, T, memory_order);
template &lt;class T&gt;
T atomic_fetch_and(volatile <del><em>atomic-type</em></del><ins>atomic&lt;T&gt;</ins>*, T);
template &lt;class T&gt;
T atomic_fetch_and(<del><em>atomic-type</em></del><ins>atomic&lt;T&gt;</ins>*, T);
template &lt;class T&gt;
T atomic_fetch_and_explicit(volatile <del><em>atomic-type</em></del><ins>atomic&lt;T&gt;</ins>*, T, memory_order);
template &lt;class T&gt;
T atomic_fetch_and_explicit(<del><em>atomic-type</em></del><ins>atomic&lt;T&gt;</ins>*, T, memory_order);
template &lt;class T&gt;
T atomic_fetch_or(volatile <del><em>atomic-type</em></del><ins>atomic&lt;T&gt;</ins>*, T);
template &lt;class T&gt;
T atomic_fetch_or(<del><em>atomic-type</em></del><ins>atomic&lt;T&gt;</ins>*, T);
template &lt;class T&gt;
T atomic_fetch_or_explicit(volatile <del><em>atomic-type</em></del><ins>atomic&lt;T&gt;</ins>*, T, memory_order);
template &lt;class T&gt;
T atomic_fetch_or_explicit(<del><em>atomic-type</em></del><ins>atomic&lt;T&gt;</ins>*, T, memory_order);
template &lt;class T&gt;
T atomic_fetch_xor(volatile <del><em>atomic-type</em></del><ins>atomic&lt;T&gt;</ins>*, T);
template &lt;class T&gt;
T atomic_fetch_xor(<del><em>atomic-type</em></del><ins>atomic&lt;T&gt;</ins>*, T);
template &lt;class T&gt;
T atomic_fetch_xor_explicit(volatile <del><em>atomic-type</em></del><ins>atomic&lt;T&gt;</ins>*, T, memory_order);
template &lt;class T&gt;
T atomic_fetch_xor_explicit(<del><em>atomic-type</em></del><ins>atomic&lt;T&gt;</ins>*, T, memory_order);

<i>// 29.6.3, arithmetic operations on atomic types</i>
<ins><i>// In the following declarations, <em>atomic-integral</em> is either 
// </i><code>atomic&lt;T&gt;</code> <i>or a named base class for</i> <code>T</code> <i>from 
// Table 145 or inferred from 
// Table 146.
// If it is</i> <code>atomic&lt;T&gt;</code><i>,
// then the declaration is a template specialization declaration prefixed with
//</i> <code>template &lt;&gt;</code></ins>
<del>template &lt;&gt;</del>
<em>integral</em> atomic_fetch_add(volatile <em>atomic-integral</em>*, <em>integral</em>);
<del>template &lt;&gt;</del>
<em>integral</em> atomic_fetch_add(<em>atomic-integral</em>*, <em>integral</em>);
<del>template &lt;&gt;</del>
<em>integral</em> atomic_fetch_add_explicit(volatile <em>atomic-integral</em>*, <em>integral</em>, memory_order);
<del>template &lt;&gt;</del>
<em>integral</em> atomic_fetch_add_explicit(<em>atomic-integral</em>*, <em>integral</em>, memory_order);
<del>template &lt;&gt;</del>
<em>integral</em> atomic_fetch_sub(volatile <em>atomic-integral</em>*, <em>integral</em>);
<del>template &lt;&gt;</del>
<em>integral</em> atomic_fetch_sub(<em>atomic-integral</em>*, <em>integral</em>);
<del>template &lt;&gt;</del>
<em>integral</em> atomic_fetch_sub_explicit(volatile <em>atomic-integral</em>*, <em>integral</em>, memory_order);
<del>template &lt;&gt;</del>
<em>integral</em> atomic_fetch_sub_explicit(<em>atomic-integral</em>*, <em>integral</em>, memory_order);
<del>template &lt;&gt;</del>
<em>integral</em> atomic_fetch_and(volatile <em>atomic-integral</em>*, <em>integral</em>);
<del>template &lt;&gt;</del>
<em>integral</em> atomic_fetch_and(<em>atomic-integral</em>*, <em>integral</em>);
<del>template &lt;&gt;</del>
<em>integral</em> atomic_fetch_and_explicit(volatile <em>atomic-integral</em>*, <em>integral</em>, memory_order);
<del>template &lt;&gt;</del>
<em>integral</em> atomic_fetch_and_explicit(<em>atomic-integral</em>*, <em>integral</em>, memory_order);
<del>template &lt;&gt;</del>
<em>integral</em> atomic_fetch_or(volatile <em>atomic-integral</em>*, <em>integral</em>);
<del>template &lt;&gt;</del>
<em>integral</em> atomic_fetch_or(<em>atomic-integral</em>*, <em>integral</em>);
<del>template &lt;&gt;</del>
<em>integral</em> atomic_fetch_or_explicit(<em>atomic-integral</em>*, <em>integral</em>, memory_order);
<del>template &lt;&gt;</del>
<em>integral</em> atomic_fetch_or_explicit(<em>atomic-integral</em>*, <em>integral</em>, memory_order);
<del>template &lt;&gt;</del>
<em>integral</em> atomic_fetch_xor(volatile <em>atomic-integral</em>*, <em>integral</em>);
<del>template &lt;&gt;</del>
<em>integral</em> atomic_fetch_xor(<em>atomic-integral</em>*, <em>integral</em>);
<del>template &lt;&gt;</del>
<em>integral</em> atomic_fetch_xor_explicit(volatile <em>atomic-integral</em>*, <em>integral</em>, memory_order);
<del>template &lt;&gt;</del>
<em>integral</em> atomic_fetch_xor_explicit(<em>atomic-integral</em>*, <em>integral</em>, memory_order);
</pre></blockquote>
</li>

<li><p>Edit 29.6.1 [atomics.types.operations.general] paragraph 1+2 as follows:</p>

<blockquote><p>
-1- The implementation shall provide the <ins>functions and</ins> function templates identified as 
&quot;general operations on atomic types&quot; in 29.2 [atomics.syn].
<p/>
-2- In the declarations of these <ins>functions and function</ins> templates, the name <em>atomic-type</em> 
refers to either <tt>atomic&lt;T&gt;</tt> or to a named base class for <tt>T</tt> from Table 145 or 
inferred from Table 146.
</p>
</blockquote>
</li>

<li><p>In 29.6.2 [atomics.types.operations.templ] delete paragraph 2:</p>

<blockquote><p>
-1- The implementation shall declare but not define the function templates identified as 
&quot;templated operations on atomic types&quot; in 29.2 [atomics.syn].
<p/>
<del>-2- In the declarations of these templates, the name <em>atomic-type</em> refers to either 
<tt>atomic&lt;T&gt;</tt> or to a named base class for <tt>T</tt> from Table 145 or 
inferred from Table 146.</del>
</p>
</blockquote>
</li>

<li><p>Edit 29.6.3 [atomics.types.operations.arith] paragraph 1+2 as follows:</p>

<blockquote><p>
-1- The implementation shall provide the <ins>functions and</ins> function template 
specializations identified as &quot;arithmetic operations on atomic types&quot; in 
29.2 [atomics.syn].
<p/>
-2- In the declarations of these <ins>functions and function</ins> template specialization<ins>s</ins>, 
the name <em>integral</em> refers to an integral type and the name <em>atomic-integral</em> 
refers to either <tt>atomic&lt;</tt><em>integral</em><tt>&gt;</tt> or to a named base class for 
<em>integral</em> from Table 145 or inferred from Table 146.
</p>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="2038"></a>2038. Missing definition for <tt>incrementable</tt> iterator</h3>
<p><b>Section:</b> 24.2.4 [output.iterators] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2011-02-27 <b>Last modified:</b> 2011-03-24</p>
<p><b>View other</b> <a href="lwg-index-open.html#output.iterators">active issues</a> in [output.iterators].</p>
<p><b>View all other</b> <a href="lwg-index.html#output.iterators">issues</a> in [output.iterators].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>

<p>In comp.lang.c++, Vicente Botet raises the following questions:</p>

<blockquote><p>
&quot;In "24.2.4 Output iterators" there are 3 uses of incrementable. I've
not found the definition. Could some one point me where it is defined?
<p/>
Something similar occurs with dereferenceable. While the definition is
given in "24.2.1 In general" it is used several times before.
<p/>
Shouldn't these definitions be moved to some previous section?&quot;
</p></blockquote>

<p>He's right: both terms are used without being properly defined.
<p/>
There is no definition of "incrementable".
<p/>
While there is a definition of "dereferenceable", it is, in fact, a definition of 
"dereferenceable iterator". "dereferenceable" is used throughout Clause 23 (Containers) 
before its definition in Clause 24. In almost all cases it's referring to iterators, 
but in 17.6.3.2 [swappable.requirements] there is a mention of "dereferenceable object"; in 
17.6.3.5 [allocator.requirements] the table of Descriptive variable definitions refers to a 
"dereferenceable pointer"; 20.6.3.2 [pointer.traits.functions] refers to a 
"dereferenceable pointer"; in 22.4.5.1.2 [locale.time.get.virtuals]&frasl;11 (<tt>do_get</tt>) 
there is a requirement that a pointer "shall be dereferenceable". In those specific cases 
it is not defined.
</p>

<p><i>[2011-03-02: Daniel comments:]</i></p>


<p>I believe that the currently proposed resolution of issue <a href="lwg-active.html#2035">2035</a> solves this
issue as well.</p>



<p><b>Proposed resolution:</b></p>
<p></p>





<hr>
<h3><a name="2040"></a>2040. Missing type traits related to <tt>is_convertible</tt></h3>
<p><b>Section:</b> 20.9 [meta] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2011-03-03 <b>Last modified:</b> 2011-03-24</p>
<p><b>View all other</b> <a href="lwg-index.html#meta">issues</a> in [meta].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>When <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3142.html">n3142</a>
was suggested, it concentrated on constructions, assignments, and destructions, but overlooked 
to complement the single remaining compiler-support trait</p>

<blockquote><pre>
template &lt;class From, class To&gt; struct is_convertible;
</pre></blockquote>

<p>with the no-throw and triviality related aspects as it had been done with the other
expression-based traits. Specifically, the current specification misses to add the
following traits:
</p>

<blockquote><pre>
template &lt;class From, class To&gt; struct is_nothrow_convertible;
template &lt;class From, class To&gt; struct is_trivially_convertible;
</pre></blockquote>

<p>In particular the lack of <tt>is_nothrow_convertible</tt> is severly restricting. This
was recently recognized when the proposal for <tt>decay_copy</tt> was prepared by 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3255.html">n3255</a>.
There does not exist a portable means to define the correct conditional <tt>noexcept</tt>
specification for the <tt>decay_copy</tt> function template, which is declared as:</p>

<blockquote><pre>
template &lt;class T&gt; 
typename decay&lt;T&gt;::type decay_copy(T&amp;&amp; v) noexcept(<i>???</i>);
</pre></blockquote>

<p>The semantics of <tt>decay_copy</tt> bases on an implicit conversion which again
influences the overload set of functions that are viable here. In most circumstances
this will have the same effect as comparing against the trait 
<tt>std::is_nothrow_move_constructible</tt>, but there is no guarantee for that being
the right answer. It is possible to construct examples, where this would lead
to the false result, e.g.</p>

<blockquote><pre>
struct S {
  S(const S&amp;) noexcept(false);
 
  template&lt;class T&gt;
  explicit S(T&amp;&amp;) noexcept(true);
};
</pre></blockquote>

<p><tt>std::is_nothrow_move_constructible</tt> will properly honor the explicit template
constructor because of the direct-initialization context which is part of the
<tt>std::is_constructible</tt> definition and will in this case select it, such that
<tt>std::is_nothrow_move_constructible&lt;S&gt;::value == true</tt>, but if we had
the traits <tt>is_nothrow_convertible</tt>, <tt>is_nothrow_convertible&lt;S, S&gt;::value</tt>
would evaluate to <tt>false</tt>, because it would use the copy-initialization context
that is part of the <tt>is_convertible</tt> definition, excluding any explicit
constructors and giving the opposite result.</p>

<p>The <tt>decay_copy</tt> example is surely not one of the most convincing examples, but
<tt>is_nothrow_convertible</tt> has several use-cases, and can e.g. be used to express
whether calling the following implicit conversion function could throw an exception or not:</p>

<blockquote><pre>
template&lt;class T, class U&gt;
T implicit_cast(U&amp;&amp; u) noexcept(is_nothrow_convertible&lt;U, T&gt;::value) 
{
  return std::forward&lt;U&gt;(u);
}
</pre></blockquote>

<p>Therefore I suggest to add the missing trait <tt>is_nothrow_convertible</tt> and for
completeness also the missing trait <tt>is_trivially_convertible</tt> to 20.9 [meta].</p>

<p><i>[2011-03-24 Madrid meeting]</i></p>


<p>
Daniel K: This is a new feature so out of scope.
<p/>
Pablo: Any objections to moving 2040 to Open?
<p/>
No objections. 
</p>


<p><b>Proposed resolution:</b></p>
<ol>
<li><p>Ammend the following declarations to the header <tt>&lt;type_traits&gt;</tt> synopsis
in 20.9.2 [meta.type.synop]:</p>

<blockquote><pre>
namespace std {
  &hellip;
  // 20.9.6, type relations:
  template &lt;class T, class U&gt; struct is_same;
  template &lt;class Base, class Derived&gt; struct is_base_of;
  template &lt;class From, class To&gt; struct is_convertible;
  <ins>template &lt;class From, class To&gt; struct is_trivially_convertible;</ins>
  <ins>template &lt;class From, class To&gt; struct is_nothrow_convertible;</ins>

  &hellip;
}
</pre></blockquote>
</li>

<li><p>Modify Table 51 &mdash; &quot;Type relationship predicates&quot; as indicated. The removal of the
remaining traces of the trait <tt>is_explicitly_convertible</tt> is an editorial
step, it was removed by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3047.html">n3047</a>:
</p>

<blockquote>
<table border="1">
<caption>Table 51 &mdash; Type relationship predicates</caption>

<tr>
<th>Template</th>
<th>Condition</th>
<th>Comments</th>
</tr>

<tr>
<td colspan="3" style="text-align:center;">&hellip;</td> 
</tr>

<tr>
<td><tt>template &lt;class From, class To&gt;<br/>
struct is_convertible;</tt></td>
<td><i>see below</i></td>
<td><tt>From</tt> and <tt>To</tt> shall be complete<br/>
types, arrays of unknown bound, or<br/>
(possibly cv-qualified) <tt>void</tt><br/>
types.</td>
</tr>

<tr>
<td><del><tt>template &lt;class From, class To&gt;<br/>
struct is_explicitly_convertible;</tt></del></td>
<td><del><tt>is_constructible&lt;To, From&gt;::value</tt></del></td>
<td><del>a synonym for a two-argument<br/>
version of <tt>is_constructible</tt>.<br/>
An implementation may define it<br/>
as an alias template.</del></td>
</tr>

<tr>
<td><ins><tt>template &lt;class From, class To&gt;<br/>
struct is_trivially_convertible;</tt></ins></td>
<td><ins><tt>is_convertible&lt;From,<br/>
 To&gt;::value</tt> is <tt>true</tt> and the<br/>
conversion, as defined by<br/>
<tt>is_convertible</tt>, is known<br/>
to call no operation that is<br/>
not trivial ([basic.types], [special]).</ins></td>
<td><ins><tt>From</tt> and <tt>To</tt> shall be complete<br/>
types, arrays of unknown bound,<br/>
or (possibly cv-qualified) <tt>void</tt><br/>
types.</ins></td>
</tr>

<tr>
<td><ins><tt>template &lt;class From, class To&gt;<br/>
struct is_nothrow_convertible;</tt></ins></td>
<td><ins><tt>is_convertible&lt;From,<br/>
 To&gt;::value</tt> is <tt>true</tt> and the<br/>
conversion, as defined by<br/>
<tt>is_convertible</tt>, is known<br/>
not to throw any<br/>
exceptions ([expr.unary.noexcept]).</ins></td>
<td><ins><tt>From</tt> and <tt>To</tt> shall be complete<br/>
types, arrays of unknown bound,<br/>
or (possibly cv-qualified) <tt>void</tt><br/>
types.</ins></td>
</tr>

<tr>
<td colspan="3" style="text-align:center;">&hellip;</td> 
</tr>

</table>
</blockquote>

</li>
</ol>





</body>
</html>
