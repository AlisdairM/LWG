<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>C++ Standard Library Unresolved Issues</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
</style>
</head>
<body>
<h2>Unresolved Issues</h2>
<hr>
<h3><a name="964"></a>964. Various threading bugs #14</h3>
<p><b>Section:</b> 30.5.2 [thread.condition.condvarany] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07 <b>Last modified:</b> 2010-10-27</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.condition.condvarany">issues</a> in [thread.condition.condvarany].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The requirements for the constructor for <tt>condition_variable</tt> has several
error conditions, but the requirements for the constructor for
<tt>condition_variable_any</tt> has none. Is this difference intentional?
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Move to open, pass to Howard. If this is intentional, a note may be
helpful. If the error conditions are to be copied from
<tt>condition_variable</tt>, this depends on LWG <a href="lwg-defects.html#965">965</a>.
</blockquote>

<p><i>[
Post Summit Howard adds:
]</i></p>


<blockquote>
The original intention 
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2447.htm#ConditionVariablesWording">N2447</a>)
was to let the OS return whatever errors it was going to return, and for
those to be translated into exceptions, for both
<tt>condition_variable</tt> and <tt>condition_variable_any</tt>.  I have not
received any complaints about specific error conditions from vendors on
non-POSIX platforms, but such complaints would not surprise me if they surfaced.
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Leave open. Benjamin to provide wording.
</blockquote>

<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote>
<p>
We don't have throw clauses for condition variables.
</p>
<p>
This issue may be dependent on LWG <a href="lwg-defects.html#1268">1268</a>.
</p>
<p>
Leave open. Detlef will coordinate with Benjamin.
</p>
<p>
Consider merging LWG 964, <a href="lwg-active.html#966">966</a>, and <a href="lwg-defects.html#1268">1268</a> into a
single paper.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="966"></a>966. Various threading bugs #16</h3>
<p><b>Section:</b> 30.5.1 [thread.condition.condvar] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2009-01-07 <b>Last modified:</b> 2010-10-27</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.condition.condvar">issues</a> in [thread.condition.condvar].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
30.5.1 [thread.condition.condvar]:
<tt>condition_variable::wait</tt> and
<tt>condition_variable::wait_until</tt> both have a postcondition that
<tt>lock</tt> is locked by the calling thread, and a throws clause that
requires throwing an exception if this postcondition cannot be achieved.
How can the implementation detect that this <tt>lock</tt> can never be
obtained?
</p>

<p><i>[
Summit:
]</i></p>


<blockquote>
Move to open. Requires wording. Agreed this is an issue, and the
specification should not require detecting deadlocks.
</blockquote>

<p><i>[
2009-08-01 Howard provides wording.
]</i></p>


<blockquote>
<p>
The proposed wording is inspired by the POSIX spec which says:
</p>

<blockquote>
<dl>
<dt>[EINVAL]</dt>
<dd>The value specified by cond or mutex is invalid.</dd>
<dt>[EPERM]</dt>
<dd>The mutex was not owned by the current thread at the time of the call.</dd>
</dl>
</blockquote>

<p>
I do not believe [EINVAL] is possible without memory corruption (which we don't
specify).  [EPERM] is possible if this thread doesn't own the mutex, which is
listed as a precondition.  "May" is used instead of "Shall" because not all
OS's are POSIX.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Leave open, Detlef to provide improved wording.
</blockquote>

<p><i>[
2009-10-23 Detlef Provided wording.
]</i></p>


<blockquote>
<p>
Detlef's wording put in Proposed resolution.  Original wording here:
</p>
<blockquote>
<p>
Change 30.5.1 [thread.condition.condvar] p12, p19 and
30.5.2 [thread.condition.condvarany] p10, p16:
</p>

<blockquote>
<i>Throws:</i> <ins>May throw</ins> <tt>std::system_error</tt> 
<ins>
if a precondition is not met.
</ins>
<del>when the effects or postcondition
cannot be achieved.</del>
</blockquote>
</blockquote>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Leave open, Detlef to provide improved wording.
</blockquote>

<p><i>[
2009-11-18 Anthony adds:
]</i></p>


<blockquote>
<p>
<tt>condition_variable::wait</tt> takes a <tt>unique_lock&lt;mutex&gt;</tt>. We
know whether or not a <tt>unique_lock</tt> owns a lock, through use of its
<tt>owns_lock()</tt> member.
</p>

<p>
I would like to propose the following resolution:
</p>

<blockquote>
<p>
Modify the first sentence of 30.5.1 [thread.condition.condvar] p9:
</p>

<blockquote><pre>
void wait(unique_lock&lt;mutex&gt;&amp; lock);
</pre>
<blockquote>
9 <i>Precondition:</i> <del><tt>lock</tt> is locked by the calling thread</del>
<ins><tt>lock.owns_lock()</tt> is <tt>true</tt></ins>, and either
<p>...</p>
</blockquote>
</blockquote>

<p>
Replace 30.5.1 [thread.condition.condvar] p11-13 with:
</p>

<blockquote><pre>
void wait(unique_lock&lt;mutex&gt;&amp; lock);
</pre>
<blockquote>
<p>...</p>
<p>
11 <i>Postcondition:</i> <del><tt>lock</tt> is locked by the calling
thread</del> <ins><tt>lock.owns_lock()</tt> is <tt>true</tt></ins>.
</p>

<p>
12 <i>Throws:</i> <tt>std::system_error</tt> <del>when the effects or
postcondition cannot be achieved</del> <ins>if the implementation detects that
the preconditions are not met or the effects cannot be achieved. Any exception
thrown by <tt>lock.lock()</tt> or <tt>lock.unlock()</tt></ins>.
</p>

<p>
13 <i>Error Conditions:</i> <ins>The error conditions are implementation
defined.</ins>
</p>

<ul>
<li><del>
equivalent error condition from <tt>lock.lock()</tt> or <tt>lock.unlock()</tt>.
</del></li>
</ul>

</blockquote>
</blockquote>
</blockquote>
</blockquote>

<p><i>[
2010 Pittsburgh:
]</i></p>


<blockquote>
<p>
There are heavy conflicts with adopted papers.
</p>
<p>
This issue is dependent on LWG <a href="lwg-defects.html#1268">1268</a>.
</p>
<p>
Leave open pending outstanding edits to the working draft. Detlef will provide
wording.
</p>
<p>
Possibly related to <a href="lwg-active.html#964">964</a>.
</p>

</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Replace 30.5.1 [thread.condition.condvar] p12, p19 and
30.5.2 [thread.condition.condvarany] p10, p16:
</p>

<blockquote>
<p><del>
<i>Throws:</i> <tt>std::system_error</tt> when the effects or
postcondition cannot be achieved.
</del></p>
<p><del>
Error conditions:
</del></p>
<ul>
<li><del>
equivalent error condition from <tt>lock.lock()</tt> or <tt>lock.unlock()</tt>.
</del></li>
</ul>

<p><ins>
<i>Throws:</i> It is implementation-defined whether a <tt>std::system_error</tt>
with implementation-defined error condition is thrown if the
precondition is not met.
</ins></p>
</blockquote>






<hr>
<h3><a name="985"></a>985. Allowing throwing move</h3>
<p><b>Section:</b> 23.2.1 [container.requirements.general] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Rani Sharoni <b>Opened:</b> 2009-02-12 <b>Last modified:</b> 2010-10-27</p>
<p><b>View other</b> <a href="lwg-index-open.html#container.requirements.general">active issues</a> in [container.requirements.general].</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements.general">issues</a> in [container.requirements.general].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<b>Introduction</b>
</p>

<p>This proposal is meant to resolve potential regression of the
<a href ref="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2800.pdf">N2800</a>
draft, see
next section, and to relax the requirements for containers of types with
throwing move constructors.</p>

<p>The basic problem is that some containers operations, like <tt>push_back</tt>,
have a strong exception safety
guarantee (i.e. no side effects upon exception) that are not achievable when
throwing move constructors are used since there is no way to guarantee revert
after partial move. For such operations the implementation can at most provide
the basic guarantee (i.e. valid but unpredictable) as it does with multi
copying operations (e.g. range insert).</p>

<p>For example, <tt>vector&lt;T&gt;::push_back()</tt> (where <tt>T</tt> has a move
constructor) might resize the <tt>vector</tt> and move the objects to the new underlying
buffer. If move constructor throws it might
not be possible to recover the throwing object or to move the old objects back to
the original buffer.</p>

<p>The current draft is explicit by disallowing throwing move
for some operations (e.g. <tt>vector&lt;&gt;::reserve</tt>) and not clear about other
operations mentioned in 23.2.1 [container.requirements.general]/10
(e.g. single element <tt>insert</tt>): it guarantees strong exception
safety without explicitly disallowing a throwing move constructor.
</p>

<p>
<b>Regression</b>
</p>

<p>This section only refers to cases in which the contained object
is by itself a standard container.</p>

<p>Move constructors of standard containers are allowed to throw and therefore
existing operations are broken, compared with C++03, due to move optimization.
(In fact existing implementations like Dinkumware are actually throwing).</p>

<p>For example, <tt>vector&lt; list&lt;int&gt; &gt;::reserve</tt> yields
undefined behavior since <tt>list&lt;int&gt;</tt>'s move constructor is allowed to throw.
On the other hand, the same operation has strong exception safety guarantee in
C++03.</p>

<p>There are few options to solve this regression:</p>

<ol>
<li>
Disallow throwing move and throwing default constructor
</li>

<li>
Disallow throwing move but disallowing usage after move
</li>

<li>
Special casing
</li>

<li>
Disallow throwing move and making it optional
</li>

</ol>

<p>Option 1 is suggested by proposal
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2815.html">N2815</a>
but it might not be applicable for existing implementations for which
containers default constructors are throwing.</p>

<p>Option 2 limits the usage significantly and it's error prone
by allowing zombie objects that are nothing but destructible (e.g. no <tt>clear()</tt>
is allowed after move). It also potentially complicates the implementation by
introducing special state.</p>

<p>Option 3 is possible, for example, using default
construction and <tt>swap</tt> instead of move for standard containers case. The
implementation is also free to provide special hidden operation for non
throwing move without forcing the user the cope with the limitation of option-2
when using the public move.</p>

<p>Option 4 impact the efficiency in all use cases due to rare throwing move.</p>

<p>The proposed wording will imply option 1 or 3 though option 2 is also
achievable using more wording. I personally oppose to option 2 that has impact
on usability.</p>

<p>
<b>Relaxation for user types</b>
</p>

<p>Disallowing throwing move constructors in general seems very restrictive
since, for example, common implementation of move will be default construction
+ <tt>swap</tt> so move will throw if the
default constructor will throw. This is currently the case with the Dinkumware
implementation of node based containers (e.g. <tt>std::list</tt>)
though this section doesn't refer to standard types.</p>

<p>For throwing move constructors it seem that the implementation should have
no problems to provide the basic guarantee instead of the strong one. It's
better to allow throwing move constructors with basic guarantee than to
disallow it silently (compile and run), via undefined behavior.</p>

<p>There might still be cases in which the relaxation will break existing generic
code that assumes the strong guarantee but it's broken either way given a
throwing move constructor since this is not a preserving optimization. </p>

<p><i>[
Batavia (2009-05):
]</i></p>

<blockquote>
<p>
Bjarne comments (referring to his draft paper):
"I believe that my suggestion simply solves that.
Thus, we don't need a throwing move."
</p>
<p>
Move to Open and recommend it be deferred until after the next
Committee Draft is issued.
</p>
</blockquote>

<p><i>[
2009-10 Santa Cruz:
]</i></p>


<blockquote>
Should wait to get direction from Dave/Rani
(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2983.html">N2983</a>).
</blockquote>

<p><i>[
2010-03-28 Daniel updated wording to sync with N3092.
]</i></p>


<blockquote>
<p>
The suggested change of 23.3.2.3 [deque.modifiers]/2 should be removed,
because the current wording does say more general things:
</p>

<blockquote>
2 <i>Remarks:</i> If an exception is thrown other than by the copy constructor,
move constructor, assignment operator, or move assignment operator of <tt>T</tt>
there are no effects. If an exception is thrown by the move constructor of a
non-CopyConstructible <tt>T</tt>, the effects are unspecified.
</blockquote>

<p>
The suggested change of 23.4.1.2 [vector.capacity]/2 should be removed,
because the current wording does say more general things:
</p>

<blockquote>
2 <i>Effects:</i> A directive that informs a <tt>vector</tt> of a planned change
in size, so that it can manage the storage allocation accordingly. After
<tt>reserve()</tt>, <tt>capacity()</tt> is greater or equal to the argument of
<tt>reserve</tt> if reallocation happens; and equal to the previous value of
<tt>capacity()</tt> otherwise. Reallocation happens at this point if and only if
the current capacity is less than the argument of <tt>reserve()</tt>. If an
exception is thrown other than by the move constructor of a
non-<tt>CopyConstructible</tt> type, there are no effects.
</blockquote>

</blockquote>



<p><b>Proposed resolution:</b></p>

<p>
23.2.1 [container.requirements.general]  paragraph 11 add footnote:
</p>

<blockquote>
<p>
-11- Unless otherwise specified (see 23.1.4.1, 23.1.5.1, 23.2.2.3, and
23.2.6.4) all container types defined in this Clause meet the following
additional requirements:
</p>
<ul>
<li>...</li>
</ul>

<p>
<ins>[<i>Note</i>: for compatibility with C++
2003, when "no effect" is required, standard containers should not use the
value_type's throwing move constructor when the contained object is by itself a
standard container. -- <i>end note</i>]</ins>
</p>

</blockquote>

<p>23.2.5.1 [unord.req.except] change paragraph 2 to say: </p>

<blockquote>
<p>
-2- For unordered associative containers, if an exception is
thrown by any operation other than the container's hash function from within an
<tt>insert()</tt> function inserting a single element, the <tt>insert()</tt>
function has no effect<ins> unless the exception is thrown by the contained
object move constructor</ins>.
</p>

<p>
-4- For unordered associative containers, if an exception is
thrown from within a <tt>rehash()</tt> function other than by the container's hash
function or comparison function, the <tt>rehash()</tt> function has no effect
<ins>unless the exception is thrown by the contained
object move constructor</ins>.</p>

</blockquote>

<p>
23.3.2.3 [deque.modifiers] change paragraph 2 to say:
</p>

<blockquote>
-2- <i>Remarks:</i> If an exception is thrown other than by
the copy constructor<ins>, move constructor</ins>
or assignment operator of <tt>T</tt>
there are no effects.
<ins>If an exception is thrown by <tt>push_back()</tt> or <tt>emplace_back()</tt>
function, that function has no effects unless the exception is thrown by
the move constructor of <tt>T</tt>.</ins>
</blockquote>

<p>
23.4.1.2 [vector.capacity] paragraph 2 change to say:
</p>

<blockquote>
-2- <i>Effects:</i> A directive that informs a <tt>vector</tt>
of a planned change in size, so
that it can manage the storage allocation accordingly. After <tt>reserve()</tt>,
<tt>capacity()</tt> is greater or equal to the argument of <tt>reserve</tt>
if reallocation happens; and equal
to the previous value of <tt>capacity()</tt>
otherwise. Reallocation happens at this point if and only if the current
capacity is less than the argument of <tt>reserve()</tt>.
If an exception is thrown, there are no effects<ins>
unless the exception is thrown by the contained object move constructor</ins>.
</blockquote>

<p>
23.4.1.2 [vector.capacity] paragraph 12 change to say:
</p>

<blockquote>
-12- <i>Requires:</i> <del>If <tt>value_type</tt> has a move constructor,
that constructor shall not throw any exceptions.</del>
<ins>If an exception is thrown, there are no effects unless the exception is thrown by
the contained object move constructor.</ins>
</blockquote>

<p>
23.4.1.4 [vector.modifiers] change paragraph 1 to say:
</p>

<blockquote>
-1- <del><i>Requires:</i> If <tt>value_type</tt> has a move constructor,
that constructor shall not throw any exceptions.</del>
<ins><i>Remarks:</i> If an exception is thrown by <tt>push_back()</tt>
or <tt>emplace_back()</tt> function, that function has no effect unless the
exception is thrown by the move constructor of <tt>T</tt>.</ins>
</blockquote>






<hr>
<h3><a name="1169"></a>1169. <tt>num_get</tt> not fully compatible with <tt>strto*</tt></h3>
<p><b>Section:</b> 22.4.2.1.2 [facet.num.get.virtuals] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Cosmin Truta <b>Opened:</b> 2009-07-04 <b>Last modified:</b> 2010-10-27</p>
<p><b>View all other</b> <a href="lwg-index.html#facet.num.get.virtuals">issues</a> in [facet.num.get.virtuals].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
As specified in the latest draft,
<a 
href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2914.pdf">N2914</a>,
<code>num_get</code> is still not fully compatible with the following C
functions: <code>strtoul</code>, <code>strtoull</code>, 
<code>strtof</code> and
<code>strtod</code>.
</p>
<p>
In C, when conversion of a string to an unsigned integer type falls 
outside the
representable range, <code>strtoul</code> and <code>strtoull</code> return
<code>ULONG_MAX</code> and <code>ULLONG_MAX</code>, respectively, 
regardless
whether the input field represents a positive or a negative value.
On the other hand, the result of <code>num_get</code> conversion of 
negative
values to unsigned integer types is zero. This raises a compatibility 
issue.
</p>
<p>
Moreover, in C, when conversion of a string to a floating-point type falls
outside the representable range, <code>strtof</code>, <code>strtod</code> 
and
<code>strtold</code> return <code>&#xB1HUGE_VALF</code>,
<code>&#xB1HUGE_VAL</code> and <code>&#xB1HUGE_VALL</code>, respectively.
On the other hand, the result of <code>num_get</code> conversion of such
out-of-range floating-point values results in the most positive/negative
representable value.
Although many C library implementations do implement <code>HUGE_VAL</code>
(etc.) as the highest representable (which is, usually, the infinity), 
this
isn't required by the C standard. The C library specification makes no
statement regarding the value of <code>HUGE_VAL</code> and friends, which
potentially raises the same compatibility issue as in the above case of
unsigned integers.
In addition, neither C nor C++ define symbolic constants for the maximum
representable floating-point values (they only do so only for the maximum
representable <i>finite</i> floating-point values), which raises a 
usability
issue (it would be hard for the programmer to check the result of
<code>num_get</code> against overflow).
</p>
<p>
As such, we propose to adjust the specification of <code>num_get</code> to
closely follow the behavior of all of its underlying C functions.
</p>



<p><i>[
2010 Rapperswil:
]</i></p>


<blockquote>
Some concern that this is changing the specification for an existing C++03 function, but it was pointed out that this was underspecified as resolved by issue 23.  This is clean-up for that issue in turn.

Some concern that we are trying to solve the same problem in both clause 22 and 27.

Bill: There's a change here as to whether val is stored to in an error case.

Pablo: Don't think this changes whether val is stored to or not, but changes the value that is stored.

Bill: Remembers having skirmishes with customers and testers as to whether val is stored to, and the resolution was not to store in error cases.

Howard: Believes since C++03 we made a change to always store in overflow.

Everyone took some time to review the issue.

Pablo: C++98 definitely did not store any value during an error condition.

Dietmar: Depends on the question of what is considered an error, and whether overflow is an error or not, which was the crux of LWG 23.

Pablo: Yes, but given the "zero, if the conversion function fails to convert the entire field", we are requiring every error condition to store.

Bill: When did this happen?

Alisdair: One of the last two or three meetings.

Dietmar: To store a value in case of failure is a very bad idea.

Move to Open, needs more study.
</blockquote>



<p><b>Proposed resolution:</b></p>

<p>
Change 22.4.2.1.2 [facet.num.get.virtuals] as follows:
</p>
<blockquote>
<p>
<b>Stage 3:</b>
The sequence of <code>char</code>s accumulated in stage 2 (the field) is
converted to a numeric value by the rules of one of the functions declared in
the header <code>&lt;cstdlib&gt;</code>:
</p>
<ul>
<li>For a signed integer value, the function <code>strtoll</code>.</li>
<li>For an unsigned integer value, the function <code>strtoull</code>.</li>
<li><ins>For a <code>float</code> value, the function
    <code>strtof</code>.</ins></li>
<li><ins>For a <code>double</code> value, the function
    <code>strtod</code>.</ins></li>
<li>For a <del>floating-point</del> <ins><code>long double</code></ins>
    value, the function <code>strtold</code>.</li>
</ul>
<p>
The numeric value to be stored can be one of:
</p>
<ul>
<li>zero, if the conversion function fails to convert the entire field.
    <del><code>ios_base::failbit</code> is assigned to <code>err</code>.</del></li>
<li>the most positive <ins>(or negative)</ins> representable value, if
    the field <ins>to be converted to a signed integer type</ins> represents a
    value too large positive <ins>(or negative)</ins> to be represented in
    <code>val</code>.
    <del><code>ios_base::failbit</code> is assigned to <code>err</code>.</del></li>
<li><del>the most negative representable value or zero for an unsigned integer
    type, if the field represents a value too large negative to be represented
    in <code>val</code>.
    <code>ios_base::failbit</code> is assigned to <code>err</code>.</del></li>
<li><ins>the most positive representable value, if the field to be converted to
    an unsigned integer type represents a value that cannot be represented in
    <code>val</code>.</ins></li>
<li>the converted value, otherwise.</li>
</ul>
<p>
The resultant numeric value is stored in <code>val</code>.
<ins>If the conversion function fails to convert the entire field, or if the
field represents a value outside the range of representable values,
<code>ios_base::failbit</code> is assigned to <code>err</code>.</ins>
</p>
</blockquote>






<hr>
<h3><a name="1175"></a>1175. <tt>unordered</tt> complexity</h3>
<p><b>Section:</b> 23.2.5 [unord.req] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Pablo Halpern <b>Opened:</b> 2009-07-17 <b>Last modified:</b> 2010-10-27</p>
<p><b>View other</b> <a href="lwg-index-open.html#unord.req">active issues</a> in [unord.req].</p>
<p><b>View all other</b> <a href="lwg-index.html#unord.req">issues</a> in [unord.req].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
When I look at the <tt>unordered_*</tt> constructors, I think the complexity is poorly
described and does not follow the style of the rest of the standard.
</p>

<p>
The complexity for the default constructor is specified as constant.
 Actually, it is proportional to <tt>n</tt>, but there are no invocations of
<tt>value_type</tt> constructors or other <tt>value_type</tt> operations.
</p>

<p>
For the iterator-based constructor the complexity should be:
</p>

<blockquote>
<i>Complexity:</i> exactly <tt>n</tt> calls to construct <tt>value_type</tt>
from <tt>InputIterator::value_type</tt> (where <tt>n = distance(f,l)</tt>).
The number of calls to <tt>key_equal::operator()</tt> is proportional to
<tt>n</tt> in the average case and <tt>n*n</tt> in the worst case.
</blockquote>



<p><i>[
2010 Rapperswil:
]</i></p>


<blockquote>
Concern that the current wording may require O(1) where that cannot be delivered.  We need to look at both the clause 23 requirements tables and the constructor description of each unodered container to be sure.

Howard suggests NAD Editorial as we updated the container requirement tables since this issue was written.

Daniel offers to look deeper, and hopefully produce wording addressing any outstanding concerns at the next meeting.

Move to Open.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="1213"></a>1213. Meaning of valid and singular iterator underspecified</h3>
<p><b>Section:</b> 24.2 [iterator.requirements] <b>Status:</b> <a href="lwg-active.html#Deferred">Deferred</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2009-09-19 <b>Last modified:</b> 2010-11-14</p>
<p><b>View all other</b> <a href="lwg-index.html#iterator.requirements">issues</a> in [iterator.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Deferred">Deferred</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The terms <em>valid</em> iterator and <em>singular</em> aren't
properly defined. The fuzziness of those terms became even worse
after the resolution of <a href="lwg-defects.html#208">208</a> (including further updates by <a href="lwg-defects.html#278">278</a>). In
24.2 [iterator.requirements] as of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf">N2723</a>
the standard says now:
</p>

<blockquote>
<p>
5 - These values are called past-the-end values. Values of an iterator <tt>i</tt> for
which the expression <tt>*i</tt> is defined are called dereferenceable. The library
never assumes that past-the-end values are dereferenceable. Iterators
can also have singular values that are not associated with any
container. [...] Results of most expressions are undefined for singular
values; the only exceptions are destroying an iterator that holds a
singular value and the assignment of a non-singular value to an iterator
that holds a singular value. [...] Dereferenceable values are always
non-singular.
</p>

<p>
10 - An invalid iterator is an iterator that may be singular.
</p>
</blockquote>

<p>
First, issue <a href="lwg-defects.html#208">208</a> intentionally removed the earlier constraint that past-the-end
values are always non-singular. The reason for this was to support null
pointers as past-the-end iterators of e.g. empty sequences. But there
seem to exist different views on what a singular (iterator) value is. E.g.
according to the <a href="http://www.sgi.com/tech/stl/trivial.html">SGI definition</a>
a null pointer is <em>not</em> a singular value:
</p>

<blockquote>
Dereferenceable iterators are always nonsingular, but the converse is
not true.
For example, a null pointer is nonsingular (there are well defined operations
involving null pointers) even thought it is not dereferenceable.
</blockquote>

<p>
and <a href="http://www.sgi.com/tech/stl/InputIterator.html">proceeds</a>:
</p>

<blockquote>
An iterator is valid if it is dereferenceable or past-the-end.
</blockquote>

<p>
Even if the standard prefers a different meaning of singular here, the
change was
incomplete, because by restricting feasible expressions of singular
iterators to
destruction and assignment isn't sufficient for a past-the-end
iterator: Of-course
it must still be equality-comparable and in general be a readable value.
</p>

<p>
Second, the standard doesn't clearly say whether a past-the-end value is
a valid iterator or not. E.g. 20.9.9 [specialized.algorithms]/1 says:
</p>

<blockquote>
In all of the following algorithms, the formal template parameter
<tt>ForwardIterator</tt>
is required to satisfy the requirements of a forward iterator (24.1.3)
[..], and is
required to have the property that no exceptions are thrown from [..], or
dereference of valid iterators.
</blockquote>

<p>
The standard should make better clear what "singular pointer" and "valid
iterator" means. The fact that the meaning of a valid <em>value</em>
has a core language meaning doesn't imply that for an iterator concept
the term "valid iterator" has the same meaning.
</p>

<p>
Let me add a final example: In X [allocator.concepts.members] of
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2914.pdf">N2914</a>
we find:
</p>

<blockquote><pre>
pointer X::allocate(size_type n);
</pre>

<blockquote>
11 <i>Returns:</i> a pointer to the allocated memory. [<i>Note:</i> if <tt>n == 0</tt>, the return
value is unspecified. &mdash;<i>end note</i>]
</blockquote>

<p>
[..]
</p>

<pre>
void X::deallocate(pointer p, size_type n);
</pre>

<blockquote>
<i>Preconditions:</i> <tt>p</tt> shall be a non-singular pointer value obtained from a call
to <tt>allocate()</tt> on this allocator or one that compares equal to it.
</blockquote>
</blockquote>

<p>
If singular pointer value would include null pointers this make the
preconditions
unclear if the pointer value is a result of <tt>allocate(0)</tt>: Since the return value
is unspecified, it could be a null pointer. Does that mean that programmers
need to check the pointer value for a null value before calling deallocate?
</p>

<p><i>[
2010-11-09 Daniel comments:
]</i></p>


<p>
A later paper is in preparation.
</p>

<p><i>[
2010 Batavia:
]</i></p>


<p>
Doesn't need to be resolved for Ox
</p>


<p><b>Proposed resolution:</b></p>
Consider to await the paper.





<hr>
<h3><a name="1214"></a>1214. Insufficient/inconsistent key immutability requirements for  associative containers</h3>
<p><b>Section:</b> 23.2.4 [associative.reqmts] <b>Status:</b> <a href="lwg-active.html#Deferred">Deferred</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2009-09-20 <b>Last modified:</b> 2010-11-14</p>
<p><b>View other</b> <a href="lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Deferred">Deferred</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Scott Meyers' mentions on a recent posting on <a
href="http://groups.google.de/group/comp.std.c++/msg/6f9160fc428bcbea">c.s.c++</a>
some arguments that point to an incomplete resolution
of <a href="lwg-defects.html#103">103</a> and to an inconsistency of requirements on keys in ordered and
unordered associative
containers:
</p>

<blockquote>
<p>
1) <a href="lwg-defects.html#103">103</a> introduced the term immutable without defining it in a unique manner in
23.2.4 [associative.reqmts]/5:
</p>

<blockquote>
[..] Keys in an associative container are immutable.
</blockquote>

<p>
According to conventional dictionaries immutable is an unconditional way of
saying that something cannot be changed. So without any further explicit
allowance a user <em>always</em> runs into undefined behavior if (s)he attempts
to modify such a key. IMO this was not the intend of the committee to resolve
<a href="lwg-defects.html#103">103</a> in that way because the comments suggest an interpretation that
should give any user the freedom to modify the key in an <em>explicit</em> way
<em>provided</em> it would not affect the sort order in that container.
</p>

<p>
2) Another observation was that surprisingly no similar 'safety guards'
exists against unintentional key changes for the unordered associative
containers, specifically there is no such requirement as in
23.2.4 [associative.reqmts]/6 that "both <tt>iterator</tt> and <tt>const_iterator</tt> are constant
iterators". But the need for such protection against unintentional
changes as well as the constraints in which manner any explicit
changes may be performed are both missing and necessary, because
such changes could potentially change the <em>equivalence</em> of keys that
is measured by the <tt>hasher</tt> and <tt>key_equal</tt>.
</p>

<p>
I suggest to fix the unconditional wording involved with "immutable keys"
by at least adding a hint for the reader that users <em>may</em> perform such
changes in an explicit manner <em>and</em> to perform similar wording changes
as <a href="lwg-defects.html#103">103</a> did for the ordered associative containers also for the unordered
containers.
</p>
</blockquote>

<p><i>[
2010-03-27 Daniel provides wording.
]</i></p>


<blockquote>
This update attempts to provide normative wording that harmonizes the key and
function object constraints of associative and unordered containers.
</blockquote>

<p><i>[
2010 Batavia:
]</i></p>


<p>
We're uncomfortable with the first agenda item, and we can live with the second agenda 
item being applied before or after Madrid. 
</p>


<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
Change 23.2.4 [associative.reqmts]/2 as indicated: <i>[This ensures that
associative containers make better clear what this "arbitrary" type is, as the
unordered containers do in 23.2.5 [unord.req]/3]</i>
</p>

<blockquote>
2 Each associative container is parameterized on <tt>Key</tt> and an ordering
relation <tt>Compare</tt> that induces a strict weak ordering (25.4) on elements
of <tt>Key</tt>. In addition, <tt>map</tt> and <tt>multimap</tt> associate an
arbitrary <ins><em>mapped type</em></ins><del>type</del> <tt>T</tt> with the
<tt>Key</tt>. The object of type <tt>Compare</tt> is called the <em>comparison
object</em> of a container.
</blockquote>
</li>

<li>
<p>
Change 23.2.4 [associative.reqmts]/5 as indicated: <i>[This removes the
too strong requirement that keys must not be changed at all and brings this line
in sync with 23.2.5 [unord.req]/7. We take care about the real
constraints by the remaining suggested changes. The rationale provided by LWG
<a href="lwg-defects.html#103">103</a> didn't really argue why that addition is necessary, and I
believe the remaining additions make it clear that any user changes have strong
restrictions]</i>:
</p>

<blockquote>
5 For <tt>set</tt> and <tt>multiset</tt> the value type is the same as the key
type. For <tt>map</tt> and <tt>multimap</tt> it is equal to <tt>pair&lt;const
Key, T&gt;</tt>. <del>Keys in an associative container are immutable.</del>
</blockquote>
</li>

<li>
<p>
Change 23.2.5 [unord.req]/3+4 as indicated: <i>[The current sentence of
p.4 has doesn't say something really new and this whole subclause misses to
define the concepts of the container-specific hasher <i>object</i> and predicate
<i>object</i>. We introduce the term <em>key equality predicate</em> which is
already used in the requirements table. This change does not really correct part
of this issue, but is recommended to better clarify the nomenclature and the
difference between the function objects and the function object <em>types</em>,
which is important, because both can potentially be stateful.]</i>
</p>

<blockquote>
<p>
3 Each unordered associative container is parameterized by <tt>Key</tt>, by a
function object type <tt>Hash</tt> that meets the <tt>Hash</tt> requirements
(20.2.4) and acts as a hash function for argument values of type <tt>Key</tt>,
and by a binary predicate <tt>Pred</tt> that induces an equivalence relation on
values of type <tt>Key</tt>. Additionally, <tt>unordered_map</tt> and
<tt>unordered_multimap</tt> associate an arbitrary <em>mapped type</em>
<tt>T</tt> with the <tt>Key</tt>.
</p>

<p>
4 <ins>The container's object of type <tt>Hash</tt> - denoted by
<tt>hash</tt> - is called the <em>hash function</em> of the container.
The container's object of type <tt>Pred</tt> - denoted by
<tt>pred</tt> - is called the <em>key equality predicate</em> of the
container.</ins><del>A hash function is a function object that takes a single
argument of type <tt>Key</tt> and returns a value of type
<tt>std::size_t</tt></del>.
</p>
</blockquote>
</li>

<li>
<p>
Change 23.2.5 [unord.req]/5 as indicated: <i>[This adds a similar
safe-guard as the last sentence of 23.2.4 [associative.reqmts]/3]</i>
</p>

<blockquote>
5 Two values <tt>k1</tt> and <tt>k2</tt> of type <tt>Key</tt> are considered
equivalent if the container's <ins>key equality
predicate</ins><del><tt>key_equal</tt> function object</del> returns
<tt>true</tt> when passed those values. If <tt>k1</tt> and <tt>k2</tt> are
equivalent, the <ins>container's</ins> hash function shall return the same value
for both. [<i>Note:</i> thus, when an unordered associative container is
instantiated with a non-default <tt>Pred</tt> parameter it usually needs a
non-default <tt>Hash</tt> parameter as well. &mdash; <i>end note</i>] <ins>For
any two keys <tt>k1</tt> and <tt>k2</tt> in the same container, calling
<tt>pred(k1, k2)</tt> shall always return the same value. For any key <tt>k</tt>
in a container, calling <tt>hash(k)</tt> shall always return the same
value.</ins>
</blockquote>
</li>

<li>
<p>
After 23.2.5 [unord.req]/7 add the following new paragraph: <i>[This
ensures the same level of compile-time protection that we already require for
associative containers. It is necessary for similar reasons, because any change
in the stored key which would change it's equality relation to others or would
change it's hash value such that it would no longer fall in the same bucket,
would break the container invariants]</i>
</p>

<blockquote>
<p>
7 For <tt>unordered_set</tt> and <tt>unordered_multiset</tt> the value type is
the same as the key type. For <tt>unordered_map</tt> and
<tt>unordered_multimap</tt> it is <tt>std::pair&lt;const Key, T&gt;</tt>.
</p>
<p>
<ins>For unordered containers where the value type is the same as the key type,
both <tt>iterator</tt> and <tt>const_iterator</tt> are constant iterators. It is
unspecified whether or not <tt>iterator</tt> and <tt>const_iterator</tt> are the
same type. [<i>Note:</i> <tt>iterator</tt> and <tt>const_iterator</tt> have
identical semantics in this case, and <tt>iterator</tt> is convertible to
<tt>const_iterator</tt>. Users can avoid violating the One Definition Rule by
always using <tt>const_iterator</tt> in their function parameter lists. &mdash;
<i>end note</i>]</ins>
</p>
</blockquote>
</li>

</ol>






<hr>
<h3><a name="1252"></a>1252. <tt>wbuffer_convert::state_type</tt> inconsistency</h3>
<p><b>Section:</b> 22.3.3.2.3 [conversions.buffer] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Bo Persson  <b>Opened:</b> 2009-10-21 <b>Last modified:</b> 2010-11-13</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The synopisis for <tt>wbuffer_convert</tt> 22.3.3.2.3 [conversions.buffer]/2 contains
</p>

<blockquote><pre>
typedef typename Tr::state_type   state_type; 
</pre></blockquote>

<p>
making <tt>state_type</tt> a synonym for (possibly) some
<tt>char_traits&lt;x&gt;::state_type</tt>. 
</p>

<p>
However, in paragraph 9 of the same section, we have 
</p>

<blockquote><pre>
typedef typename Codecvt::state_type state_type;
</pre>

<blockquote>
The type shall be a synonym for <tt>Codecvt::state_type</tt>.
</blockquote>
</blockquote>

<p>
From what I can see, it might be hard to implement
<tt>wbuffer_convert</tt> if the types were not both
<tt>std::mbstate_t</tt>, but I cannot find a requirement that they must
be the same type.
</p>

<p><i>[
Batavia 2010:
]</i></p>


<p>
Howard to draft wording, move to Review. Run it by Bill. Need to move this in Madrid.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1297"></a>1297. <tt>unique_ptr</tt>'s relational operator functions should induce a total order</h3>
<p><b>Section:</b> 20.9.10.4 [unique.ptr.special] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2009-12-23 <b>Last modified:</b> 2010-11-13</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The comparison functions of <tt>unique_ptr</tt> currently directly delegate to
the underlying comparison functions of <tt>unique_ptr&lt;T, D&gt;::pointer</tt>.
This is disadvantageous, because this would not guarantee to induce a total
ordering for native pointers and it is hard to define a total order for mixed
types anyway.
</p>
<p>
The currently suggested resolution for <tt>shared_ptr</tt> comparison as of
<a href="lwg-defects.html#1262">1262</a> uses a normalization strategy: They perform the comparison on
the <em>composite pointer type</em> (5.9 [expr.rel]). This is not
exactly possible for <tt>unique_ptr</tt> in the presence of user-defined
pointer-like types but the existing definition of <tt>std::duration</tt>
comparison as of 20.11.3.6 [time.duration.comparisons] via
<tt>common_type</tt> of both argument types demonstrates a solution of this
problem. The approach can be seen as the general way to define a <em>composite
pointer type</em> and this is the approach which is used for here suggested
wording change.
</p>
<p>
For consistency reasons I would have preferred the same normalization strategy
for <tt>==</tt> and <tt>!=</tt>, but Howard convinced me not to do so (now).
</p>

<p><i>[
2010-11-03 Daniel comments and adjustes the currently proposed wording changes:
]</i></p>


<p>
Issue <a href="lwg-active.html#1401">1401</a> is remotely related. <a href="#1401_extra_bullet">Bullet A</a> of its proposed resolution 
provides an alternative solution for issue discussed here and addresses NB comment GB-99.
Additionally I updated the below suggested wording in regard to the following:
It is an unncessary requirement that the below defined effective composite pointer-like
type <tt>CT</tt> satisfies the <tt>LessThanComparable</tt> requirements. All what is 
needed is, that the function object type <tt>less&lt;CT&gt;</tt> induces a strict
weak ordering on the pointer values.
</p>


<p><b>Proposed resolution:</b></p>

<p>
Change 20.9.10.4 [unique.ptr.special]/4-7 as indicated: <i>[The implicit
requirements and remarks imposed on the last three operators are the same as for
the first one due to the normative "equivalent to" usage within a Requires
element, see 17.5.1.4 [structure.specifications]/4. The effects of this
change are that all real pointers wrapped in a <tt>unique_ptr</tt> will order
like <tt>shared_ptr</tt> does.]</i>
</p>

<blockquote><pre>
template &lt;class T1, class D1, class T2, class D2&gt;
  bool operator&lt;(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
</pre>

<blockquote>
<p>
<ins>? <i>Requires:</i> Let <tt>CT</tt> be <tt>common_type&lt;unique_ptr&lt;T1,
D1&gt;::pointer, unique_ptr&lt;T2, D2&gt;::pointer&gt;::type</tt>. Then
the specialization <tt>less&lt;CT&gt</tt> shall be a function object type ([function.objects]) 
that induces a strict weak ordering ([alg.sorting]) on the pointer values.</ins>
</p>

<p>
4 <i>Returns:</i> <tt><ins>less&lt;CT&gt;()(x.get(), y.get())</ins><del>x.get()
&lt; y.get()</del></tt>.
</p>

<p>
<ins>? <i>Remarks:</i> If <tt>unique_ptr&lt;T1, D1&gt;::pointer</tt> is not
implicitly convertible to <tt>CT</tt> or <tt>unique_ptr&lt;T2,
D2&gt;::pointer</tt> is not implicitly convertible to <tt>CT</tt>, the program
is ill-formed.</ins>
</p>
</blockquote>

<pre>
template &lt;class T1, class D1, class T2, class D2&gt;
  bool operator&lt;=(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
</pre>

<blockquote>
5 <ins><i>Effects:</i> Equivalent to <tt>return !(y &lt; x)</tt></ins>
<del><i>Returns:</i> <tt>x.get() &lt;= y.get()</tt></del>.
</blockquote>

<pre>
template &lt;class T1, class D1, class T2, class D2&gt;
  bool operator&gt;(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
</pre>

<blockquote>
6 <ins><i>Effects:</i> Equivalent to <tt>return (y &lt; x)</tt></ins>
<del><i>Returns:</i> <tt>x.get() &gt; y.get()</tt></del>.
</blockquote>

<pre>
template &lt;class T1, class D1, class T2, class D2&gt;
  bool operator&gt;=(const unique_ptr&lt;T1, D1&gt;&amp; x, const unique_ptr&lt;T2, D2&gt;&amp; y);
</pre>

<blockquote>
7 <ins><i>Effects:</i> Equivalent to <tt>return !(x &lt; y)</tt></ins>
<del><i>Returns:</i> <tt>x.get() &gt;= y.get()</tt></del>.
</blockquote>
</blockquote>






<hr>
<h3><a name="1330"></a>1330. Move container requirements into requirements tables</h3>
<p><b>Section:</b> 23.2 [container.requirements] <b>Status:</b> <a href="lwg-active.html#Deferred">Deferred</a>
 <b>Submitter:</b> Nicolai Josuttis <b>Opened:</b> 2010-03-10 <b>Last modified:</b> 2010-11-16</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements">issues</a> in [container.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Deferred">Deferred</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Abstract:
</p>
<p>
In general, it seems that in a couple of places container behavior is
not described in requirement tables although it is a general behavior.
</p>

<p>
History:
</p>

<p>
Issue <a href="lwg-defects.html#676">676</a> added move semantics to unordered containers.
For the added insert functions the Editor requested to put their
semantic description into a requirements table rather than describing
them for each container individually. The text however was taken from
the associative containers, where we also have the semantics for each
container described. Also, <a href="lwg-defects.html#1034">1034</a> is to some extend
requesting a clarification of the requirement tables and it turned out
that in other places we have the same problem (e.g. we have no general
requirement for type pointer and const_pointer although each container
has them with issue <a href="lwg-defects.html#1306">1306</a>).
</p>

<p>
From my personal list of functions in requirement tables
and containers, the following types/functions are missing in
requirement tables:
</p>

<ul>
<li>
<tt>pointer</tt>, <tt>const_pointer</tt> in Table 91 (container requirements)
</li>
<li>
<p>
all copy constructors, copy constructors with allocator,
 assignment operators, and insert operators
 with move semantics for associative and unordered containers
</p>
<blockquote><pre>
ContType c1(c2&amp;&amp;)
ContType c1(c2&amp;&amp;,alloc)
c1 = c2&amp;&amp;
c.insert(val&amp;&amp;)
c.insert(pos,val&amp;&amp;)
</pre></blockquote>
</li>
</ul>

<p>
As a special case, we lack the following requirements for all sequence
containers BUT array (so special wording or a new container category is
required):
</p>

<ul>
<li>
<p>
constructor with only a size argument
</p>
<blockquote><pre>
ContType c(num)
</pre></blockquote>
</li>
<li>
<p>
copy constructor with allocator and move semantics
</p>
<blockquote><pre>
ContType c1(c2&amp;&amp;,alloc)
</pre></blockquote>
</li>
<li>
<p>
all constructors that insert multiple elements with additional allocator
</p>
<blockquote><pre>
ContType c(num, val,alloc)
ContType c(beg, end,alloc)
ContType c(initlist,alloc)
</pre></blockquote>
</li>
<li>
<p>
all resize functiuons:
</p>
<blockquote><pre>
c.resize(num)
c.resize(num,val)
</pre></blockquote>
</li>
</ul>

<p>
Note that we also might have to add additional requirements on other
places for sequence containers because having an allocator requires
additional statements for the treatment of the allocators. E.g. swap for
containers with allocators is not specified in any requirement table.
</p>

<p>
And finally, if we have the requirements in the requirements tables, we
can remove the corresponding descriptions for the individual container.
However, note that sequence container requirements have NO complexity
column, so that we still need container specific descriptions for the
functions listed there.
</p>

<p><i>[
2010 Batavia
]</i></p>

<p>
While there is consensus that further cleaning up the container requirement
tables would be a good thing, there is no feeling that this <em>must</em>
be done in time for 0x.  The issue remains open, but Deferred.
</p>




<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1345"></a>1345. [FCD] Library classes should have <tt>noexcept</tt> move operations</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-31</p>
<p><b>View other</b> <a href="lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-61</b></p>
<p>
All library types should have non-throwing move
constructors and move-assignment operators unless
wrapping a type with a potentially throwing move operation.
When such a type is a class-template, these
operations should have a conditional <tt>noexcept</tt>
specification.
</p>
<p>
There are many other places where a <tt>noexcept</tt>
specification may be considered, but the move operations
are a special case that must be called out, to effectively
support the <tt>move_if_noexcept</tt> function template.
</p>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<p>
Review every class and class template in the
library. If noexcept move constructor/assignment
operators can be implicitly declared, then they
should be implicitly declared, or explicitly
defaulted. Otherwise, a move constructor/moveassingment
operator with a <tt>noexcept</tt> exception
specification should be provided.
</p>

<p><i>[
2010-10-31 Daniel comments:
]</i></p>


<blockquote>
The proposed resolution of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3157.html">n3157</a>
would satisfy this request.
</blockquote>


<p><b>Proposed resolution:</b></p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3157.html">n3157</a>





<hr>
<h3><a name="1348"></a>1348. [FCD] Exception safety of unspecified types</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-27</p>
<p><b>View other</b> <a href="lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-64</b></p>
<p>
There are a number of unspecified types used throughout
the library, such as the container iterators. Many of these
unspecified types have restrictions or expectations on
their behaviour in terms of exceptions. Are they permitted
or required to use exception specifications, more
specifically the new <tt>noexcept</tt> specification? For example,
if <tt>vector&lt;T>::iterator</tt> is implemented as a native pointer,
all its operations will have an (effective) <tt>noexcept</tt>
specification. If the implementation uses a class type to
implement this iterator, is it permitted or required to
support that same guarantee?
</p>

<p><i>[
Resolution proposed by ballot comment
]</i></p>

<p>
Clearly state the requirements for exception
specifications on all unspecified library types. For
example, all container iterator operations should
be conditionally <tt>noexcept</tt>, with the condition
matching the same operation applied to the
allocator's <tt>pointer_type</tt>, a certain subset of which
are already required not to throw.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1349"></a>1349. [FCD] <tt>swap</tt> should not throw</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-27</p>
<p><b>View other</b> <a href="lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-65</b></p>
<p>
Nothrowing <tt>swap</tt> operations are key to many C++ idioms,
notably the common copy/swap idiom to provide the
strong exception safety guarantee.
</p>

<p><i>[
Resolution proposed by ballot comment
]</i></p>

<p>
Where possible, all library types should provide a
<tt>swap</tt> operation with an exception specification
guaranteeing no exception shall propagate.
Where <tt>noexcept(true)</tt> cannot be guaranteed to
not terminate the program, and the <tt>swap</tt> in
questions is a template, an exception specification
with the appropriate conditional expression could
be specified.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1353"></a>1353. [FCD] Clarify the state of a <i>moved-from</i> object</h3>
<p><b>Section:</b> 17 [library] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Switzerland <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-14</p>
<p><b>View other</b> <a href="lwg-index-open.html#library">active issues</a> in [library].</p>
<p><b>View all other</b> <a href="lwg-index.html#library">issues</a> in [library].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses CH-18</b></p>
<p>
The general approach on moving is that a library object
after moving out is in a "valid but unspecified state". But
this is stated at the single object specifications, which is
error prone (especially if the move operations are implicit)
and unnecessary duplication.
</p>

<p><i>[
Resolution propsed by ballot comment
]</i></p>

<p>
Consider putting a general statement to the same
effect into clause 17.
</p>

<p><i>[2010-11-05 Beman provides exact wording.
The wording was inspired by Dave Abrahams'
message c++std-lib-28958, and refined with help from Alisdair, Daniel, and Howard.
]</i></p>




<p><b>Proposed resolution:</b></p>
    <p><i>Add a new definition to 17.3 Definitions [definitions]:</i></p>
    
    <blockquote>
    <p>17.3.24 [defns.valid.unspecified]<br/>
    <b>valid but unspecified state</b><br/>
    an object state that is not specified except that the object's invariants are met, and operations 
    on the object perform as specified, 
    subject only to the operation's normal preconditions.</p>
    <p>
    [<i>Example:</i> If an object <tt>x</tt> of type <tt>std::vector&lt;int&gt;</tt> is in a valid but 
    unspecified state, <tt>x.empty()</tt> can be called unconditionally, and
    <tt>x.front()</tt> can be called provided <tt>x.empty()</tt> returns
    <tt>false</tt>. <i>--end example</i>]</p>
    </blockquote>
    
    <p><i>Change Table 34 - MoveConstructible requirements [moveconstructible] as 
    indicated:</i></p>
    <blockquote>
    <p><del>[ <i>Note:</i> <tt>rv</tt> remains a valid object. Its state is 
    unspecified&nbsp; <i>--end note</i> ]</del><br/>
    <ins><i>Postcondition:</i><tt> rv</tt> is in a valid but 
    unspecified state ([defns.valid.unspecified]).</ins></p>
    </blockquote>
    
    <p><i>Change Table 36 - MoveAssignable requirements [moveassignable] as 
    indicated:</i></p>
    <blockquote>
    <p><del>[ <i>Note:</i> <tt>rv</tt> remains a valid object. Its state is 
    unspecified&nbsp; <i>--end note</i> ]</del><br/>
    <ins><i>Postcondition:</i><tt> rv</tt> is in a valid but 
    unspecified state ([defns.valid.unspecified]).</ins></p>
    </blockquote>
    
    <p><i>No change in the half-dozen or so places in the standard library that 
    use &quot;valid but unspecified state&quot; directly, and no change in the many places 
    that require <tt>MoveCostructible</tt> or <tt>MoveAssignable</tt>, 
    since <tt>MoveCostructible</tt> and <tt>MoveAssignable</tt> will now 
    normatively require &quot;valid but unspecified state&quot;.</i></p>






<hr>
<h3><a name="1358"></a>1358. [FCD] Add <tt>&lt;chrono></tt> and <tt>&lt;ratio></tt> to
freestanding implementations</h3>
<p><b>Section:</b> 17.6.1.3 [compliance] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="lwg-index.html#compliance">issues</a> in [compliance].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-55</b></p>
<p>
The <tt>&lt;thread></tt> header uses <tt>duration</tt> types, found in the
<tt>&lt;chrono></tt> header, and which rely on the <tt>ratio</tt> types
declared in the <tt>&lt;ratio></tt> header.
</p>

<p><i>[
Extracts from lengthy Rapperswil discussion:
]</i></p>

<p>
There is a concern that this issue is a misunderstanding of the actual
requirements of a free-standing implementation to support the <tt>&lt;thread></tt>
header.  In general, a free-standanding implementation will provide an <em>empty</em>
header, specifically so that a user can test for the absence of the 
<tt>_ _ STDCPP_THREADS _ _</tt> macro.  This idiom as used as there is no portable way to test for the lack of a header.
</p>
<p>
At this point, it was suggested the NB comment is trying to solve the wrong problem, and that <tt>_ _ STDCPP_THREADS _ _</tt> should be a pre-defined macro in clause 16 that can be tested before including <tt>&lt;thread></tt>.  That would remove the need to add additional headers to the free-standanding requirements.
</p>
<p>
It is worth noting that Japan requested <tt>&lt;ratio></tt> as a free-standing header in their CD1 comments.  No-one seemed keen to require clocks of a free-standing implementation though.
</p>

<p>Detlef volunteers to look at a way to redraft 17.6.1.3 p3.</p> 

<p><i>[
Original resolution proposed by NB comment:
]</i></p>


<blockquote>
<p>
Add the <tt>&lt;chrono></tt> and <tt>&lt;ratio></tt> headers to the
freestanding requirements.
</p>
<p>
It might be necessary to address scaled-down
expectations of clock support in a freestanding
environment, much like <tt>&lt;thread></tt>.
</p>
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1364"></a>1364. [FCD] It is not clear how <tt>exception_ptr</tt> is synchronized</h3>
<p><b>Section:</b> 18.8.6 [propagation] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Switzerland <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-27</p>
<p><b>View other</b> <a href="lwg-index-open.html#propagation">active issues</a> in [propagation].</p>
<p><b>View all other</b> <a href="lwg-index.html#propagation">issues</a> in [propagation].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses CH-19</b></p>
<p>
It is not clear how <tt>exception_ptr</tt> is synchronized.
</p>

<p><i>[
Resolution proposed by ballot comment
]</i></p>

<p>
Make clear that accessing in different threads
multiple <tt>exception_ptr</tt> objects that all refer to the
same exception introduce a race.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1369"></a>1369. [FCD] <tt>rethrow_exception</tt> may introduce data races</h3>
<p><b>Section:</b> 18.8.6 [propagation] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-27</p>
<p><b>View other</b> <a href="lwg-index-open.html#propagation">active issues</a> in [propagation].</p>
<p><b>View all other</b> <a href="lwg-index.html#propagation">issues</a> in [propagation].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-74</b></p>
<p>
One idea for the <tt>exception_ptr</tt> type was that a reference-counted
implementation could simply 'reactivate' the same
exception object in the context of a call to
<tt>rethrow_exception</tt>. Such an implementation would allow
the same exception object to be active in multiple threads
(such as when multiple threads join on a <tt>shared_future</tt>)
and introduce potential data races in any exception
handler that catches exceptions by reference - notably
existing library code written before this capability was
added. <tt>rethrow_exception</tt> should <em>always</em> make a copy
of the target exception object.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add the following to 18.8.5, [propogation]
</p>
<blockquote><ins>
<i>Throws</i>: a copy of the exception object to which <tt>p</tt> refers.
</ins></blockquote>






<hr>
<h3><a name="1374"></a>1374. [FCD] Clarify moved-from objects are &quot;toxic&quot;</h3>
<p><b>Section:</b> 20.2.1 [utility.arg.requirements] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View all other</b> <a href="lwg-index.html#utility.arg.requirements">issues</a> in [utility.arg.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-85</b></p>
<p>
20.2.1 Table 34 "MoveConstructible requirements" says
"Note: rv remains a valid object. Its state is unspecified".
Some components give stronger guarantees. For
example, moved-from <tt>shared_ptr</tt>s are guaranteed <tt>empty</tt>
(20.9.11.2.1/25).
In general, what the standard really should say (preferably
as a global blanket statement) is that moved-from objects
can be destroyed and can be the destination of an
assignment. Anything else is radioactive. For example,
containers can be "emptier than empty". This needs to be
explicit and required generally.
</p>
<p>
Note: The last time that one of us mentioned "emptier
than empty" (i.e. containers missing sentinel nodes, etc.)
the objection was that containers can store sentinel nodes
inside themselves in order to avoid dynamically allocating
them. This is unacceptable because
</p>
<p>
(a) it forces existing implementations (i.e. Dinkumware's, Microsoft's,
IBM's,  etc.) to change for no good reason (i.e. permitting more
operations on moved-from objects), and 
</p>
<p>
(b) it invalidates end-iterators when swapping containers. (The Working
Paper currently permits end-iterator invalidation, which we
consider to be wrong, but that's a separate argument. In
any event, <em>mandating</em> end-iterator invalidation is very
different from permitting it.)
</p>

<p><i>[
Resolution proposed in ballot comment
]</i></p>

<p>
State as a general requirement that moved-from
objects can be destroyed and can be the
destination of an assignment. Any other use is
undefined behavior.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1396"></a>1396. [FCD] <tt>regex</tt> should support allocators</h3>
<p><b>Section:</b> 28.8 [re.regex] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-07</p>
<p><b>View all other</b> <a href="lwg-index.html#re.regex">issues</a> in [re.regex].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Duplicate of:</b> <a href="lwg-closed.html#1451">1451</a></p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-104, US-141</b></p>
<p>
<tt>std::basic_regex</tt> should have an allocator for all the
reasons that a <tt>std::string</tt> does. For example, I can use
<tt>boost::interprocess</tt> to put a <tt>string</tt> or <tt>vector</tt>
in shared memory, but not a <tt>regex</tt>.
</p>

<p><i>[
Resolution proposed by ballot comment
]</i></p>

<p>
Add allocators to regexes
</p>

<p><i>[
2010-10-24 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3171.pdf">n3171</a> would solve this issue.
</blockquote>



<p><b>Proposed resolution:</b></p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3171.pdf">n3171</a>.





<hr>
<h3><a name="1421"></a>1421. [FCD] Accidental move-only library types due to new core language rules</h3>
<p><b>Section:</b> 23.5 [container.adaptors] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> DIN <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-27</p>
<p><b>View all other</b> <a href="lwg-index.html#container.adaptors">issues</a> in [container.adaptors].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Duplicate of:</b> <a href="lwg-closed.html#1350">1350</a></p>
<p><b>Discussion:</b></p>

<p><b>Addresses DE-22, CH-15</b></p>
<p>
With the final acceptance of move operations as special
members and introduction of corresponding suppression
rules of implicitly generated copy operations the some
library types that were copyable in C++03 are no longer
copyable (only movable) in C++03, among them <tt>queue</tt>,
<tt>priority_queue</tt>, and <tt>stack</tt>.
</p>

<p><i>[
2010-10-26: Daniel comments:
]</i></p>


<p>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3112.pdf">n3112</a> should fix this.
</p>



<p><b>Proposed resolution:</b></p>
See <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3112.pdf">n3112</a>





<hr>
<h3><a name="1438"></a>1438. [FCD] No definition for <tt>base()</tt></h3>
<p><b>Section:</b> 26.5.4.1 [rand.adapt.disc] <b>Status:</b> <a href="lwg-active.html#Review">Review</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-12</p>
<p><b>View all other</b> <a href="lwg-index.html#rand.adapt.disc">issues</a> in [rand.adapt.disc].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-126</b></p>

Each adaptor has a member function called <tt>base()</tt> which has no definition.

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote>
Give it the obvious definition.
</blockquote>

<p><i>[
2010-11-03 Daniel comments and provides a proposed resolution:
]</i></p>


<p>The following proposal adds <tt>noexcept</tt> specifiers to the declarations of
the <tt>base()</tt> functions as replacement for a &quot;<i>Throws</i>: Nothing&quot; element.
</p>

<p><i>[
2010 Batavia: The working group reviewed this issue, and recommended to add the following to the Proposed Resolution.
<ul><li>
Append to paragraph 1 of [rand.req.adapt] (or at the Editor's discretion insert as a new paragraph following that paragraph): 
The expression <tt>a.base()</tt> shall be valid and shall return a const reference to <tt>a</tt>'s base engine. 
</li>
</ul>
After further review, the working group concurred with the Proposed Resolution.
]</i></p>


<p><i>[Batavia: waiting for WEB to review wording]</i></p>




<p><b>Proposed resolution:</b></p>
<ol>
<li>Change in [rand.adapt.disc]/3, class template <tt>discard_block_engine</tt> synopsis, the following declaration:
<blockquote><pre>
// <em>property functions</em>
const Engine&amp; base() const <ins>noexcept</ins>;
</pre></blockquote>
</li>
<li>Add the following new prototype description at the end of sub-clause [rand.adapt.disc]:
<blockquote>
<pre><ins>const Engine&amp; base() const noexcept;</ins>
</pre>
<blockquote>
<ins>? <i>Returns</i>: <tt>e</tt>.</ins>
</blockquote>
</blockquote>
</li>
<li>Change in [rand.adapt.ibits]/4, class template <tt>independent_bits_engine</tt> synopsis, the following declaration:
<blockquote><pre>
// <em>property functions</em>
const Engine&amp; base() const <ins>noexcept</ins>;
</pre></blockquote>
</li>
<li>Add the following new prototype description at the end of sub-clause [rand.adapt.ibits]:
<blockquote>
<pre><ins>const Engine&amp; base() const noexcept;</ins>
</pre>
<blockquote>
<ins>? <i>Returns</i>: <tt>e</tt>.</ins>
</blockquote>
</blockquote>
</li>
<li>Change in [rand.adapt.shuf]/3, class template <tt>shuffle_order_engine</tt> synopsis, the following declaration:
<blockquote><pre>
// <em>property functions</em>
const Engine&amp; base() const <ins>noexcept</ins>;
</pre></blockquote>
</li>
<li>Add the following new prototype description at the end of sub-clause [rand.adapt.shuf]:
<blockquote>
<pre><ins>const Engine&amp; base() const noexcept;</ins>
</pre>
<blockquote>
<ins>? <i>Returns</i>: <tt>e</tt>.</ins>
</blockquote>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="1448"></a>1448. [FCD] Concerns about <tt>basic_stringbuf::str(basic_string)</tt> postconditions</h3>
<p><b>Section:</b> 27.8.1.3 [stringbuf.members] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-14</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-124</b></p>

<p>
N3092 27.8.1.3 [stringbuf.members] contains this textcspecifying the postconditions of
<tt>basic_stringbuf::str(basic_string)</tt>:
</p>
<blockquote>
Postconditions: If <tt>mode &amp; ios_base::out</tt> is <tt>true</tt>,
<tt>pbase()</tt> points to the first underlying character and <tt>epptr() >=
pbase() + s.size()</tt> holds; in addition, if <tt>mode &amp; ios_base::in</tt>
is <tt>true</tt>, <tt>pptr() == pbase() + s.data()</tt> holds, otherwise
<tt>pptr() == pbase()</tt> is <tt>true</tt>. [...]
</blockquote>
<p>
Firstly, there's a simple mistake: It should be <tt>pbase() + s.length()</tt>,
not <tt>pbase() + s.data()</tt>.
</p>
<p>
Secondly, it doesn't match existing implementations. As far as I can tell,
GCC 4.5 does not test for <tt>mode &amp; ios_base::in</tt> in the second part
of that sentence, but for <tt>mode &amp; (ios_base::app | ios_base_ate)</tt>,
and Visual C++ 9 for <tt>mode &amp; ios_base::app</tt>. Besides, the wording of
the C++0x draft doesn't make any sense to me. I suggest changing the second part
of the sentence to one of the following:
</p>
<p>
Replace <tt>ios_base::in</tt> with <tt>(ios_base::ate | ios_base::app)</tt>,
but this would require Visual C++ to change (replacing only with
<tt>ios_base::ate</tt> would require GCC to change, and would make
<tt>ios_base::app</tt> completely useless with <tt>stringstreams</tt>):
</p>
<p>
in addition, if <tt>mode &amp; (ios_base::ate | ios_base::app)</tt> is <tt>true</tt>,
<tt>pptr() == pbase() + s.length()</tt> holds, otherwise <tt>pptr() == pbase()</tt>
is <tt>true</tt>.
</p>
<p>
Leave <tt>pptr()</tt> unspecified if <tt>mode &amp; ios_base::app</tt>, but not
<tt>mode &amp; ios_base::ate</tt> (implementations already differ in this case, and it
is always possible to use <tt>ios_base::ate</tt> to get the effect of appending, so it
is not necessary to require any implementation to change):
</p>
<p>
in addition, if <tt>mode &amp; ios_base::ate</tt> is <tt>true</tt>,
<tt>pptr() == pbase() + s.length()</tt> holds, if neither <tt>mode &amp; ios_base::ate</tt>
nor <tt>mode &amp; ios_base::app</tt> is <tt>true</tt>, <tt>pptr() == pbase()</tt> holds,
otherwise <tt>pptr() >= pbase() &amp;&amp; pptr() &lt;= pbase() + s.length()</tt>
(which of the values in this range is unspecified).
</p>
<p>
Slightly stricter:
</p>
<p>
in addition, if <tt>mode &amp; ios_base::ate</tt> is <tt>true</tt>,
<tt>pptr() == pbase() + s.length()</tt> holds, if neither
<tt>mode &amp; ios_base::ate</tt> nor <tt>mode &amp; ios_base::app</tt> is <tt>true</tt>,
<tt>pptr() == pbase()</tt> holds, otherwise <tt>pptr() == pbase() || pptr() == pbase() + s.length()</tt>
(which of these two values is unspecified). A small table might help to better explain the three cases.
BTW, at the end of the postconditions is this text: &quot;<tt>egptr() == eback() + s.size()</tt> hold&quot;.
Is there a perference for <tt>basic_string::length</tt> or <tt>basic_string::size</tt>? It doesn't really
matter, but it looks a bit inconsistent.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1450"></a>1450. [FCD] Contradiction in regex_constants</h3>
<p><b>Section:</b> 28.5.2 [re.matchflag] <b>Status:</b> <a href="lwg-active.html#Deferred">Deferred</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-13</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Deferred">Deferred</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-127</b></p>

The Bitmask Type requirements in 17.5.2.1.3 [bitmask.types] p.3 say that
all elements on a bitmask type have distinct values, but
28.5.2 [re.matchflag] defines <tt>regex_constants::match_default</tt> and
<tt>regex_constants::format_default</tt> as elements of the
bitmask type <tt>regex_constants::match_flag_type</tt>, both with
value 0. This is a contradiction.

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote>
One of the bitmask elements should be removed
from the declaration and should be defined
separately, in the same manner as
<tt>ios_base::adjustfield</tt>, <tt>ios_base::basefield</tt> and
<tt>ios_base::floatfield</tt> are defined by 27.5.2.1.2 [ios::fmtflags] p.2
and Table 120. These are constants of a bitmask
type, but are not distinct elements, they have
more than one value set in the bitmask.
<tt>regex_constants::format_default</tt> should be
specified as a constant with the same value as
<tt>regex_constants::match_default</tt>.
</blockquote>

<p><i>[
2010-10-31 Daniel comments:
]</i></p>

<p>
Strictly speaking, a bitmask type cannot have any element of value 0 at all, because
any such value would contradict the requirement expressed in 17.5.2.1.3 [bitmask.types] p. 3:
<blockquote>
for any pair <em>Ci</em> and <em>Cj</em>, <em>Ci</em> &amp; <em>Ci</em> is nonzero
</blockquote>
So, actually <em>both</em> <tt>regex_constants::match_default</tt> and
<tt>regex_constants::format_default</tt> are only constants of the type
<tt>regex_constants::match_flag_type</tt>, and no bitmask elements.
</p>

<p><i>[
2010-11-03 Daniel comments and provides a proposed resolution:
]</i></p>


<p>The proposed resolution is written against N3126 and considered as a further improvement
of the fixes suggested by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3110.html">n3110</a>.
</p>


<p><b>Proposed resolution:</b></p>
Add the following sentence to 28.5.2 [re.matchflag]  paragraph 1:
<blockquote>
1 The type <tt>regex_constants::match_flag_type</tt> is an implementation-defined bitmask type (17.5.2.1.3).
Matching a regular expression against a sequence of characters [first,last) proceeds according to the
rules of the grammar specified for the regular expression object, modified according to the effects listed in
Table 136 for any bitmask elements set. <ins>Type <tt>regex_constants::match_flag_type</tt> also defines the 
constants <tt>regex_constants::match_default</tt> and <tt>regex_constants::format_default</tt>.</ins>
</blockquote>





<hr>
<h3><a name="1452"></a>1452. [FCD] "target sequence" is not defined</h3>
<p><b>Section:</b> 28.10.3 [re.results.acc] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-01</p>
<p><b>View all other</b> <a href="lwg-index.html#re.results.acc">issues</a> in [re.results.acc].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-125</b></p>

The term "target sequence" is not defined (28.10.3 [re.results.acc] p. 2).

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<p>
Replace "target sequence" with "string being searched/matched"
</p>

<p><i>[
2010-11-01 Daniel comments:
]</i></p>

<p>
The proposed resolution looks incomplete to me, there are more normative
usages of the term <em>target sequence</em> in clause 28, e.g.
28.12.2 [re.tokiter] p. 7.
</p>



<p><b>Proposed resolution:</b></p>
Wording changes are against N3126. They are intended not to conflict with the wording changes
suggested by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3158.html">n3158</a>.
<p/>
Change 28.10.3 [re.results.acc] p. 2 as indicated:
<blockquote><pre>
difference_type position(size_type sub = 0) const;
</pre><blockquote>
2 <em>Returns</em>: The distance from the start of the <del>target sequence</del><ins>string being matched</ins> to <tt>(*this)[sub].first</tt>.
</blockquote></blockquote>





<hr>
<h3><a name="1456"></a>1456. [FCD] Missing fixed-size atomic_ typedefs</h3>
<p><b>Section:</b> 29 [atomics] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-29</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics">active issues</a> in [atomics].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics">issues</a> in [atomics].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-129</b></p>

Table 143 lists the typedefs for various atomic types
corresponding to the various standard integer typedefs,
such as atomic_int_least8_t for int_least8_t, and
atomic_uint_fast64_t for uint_fast64_t. However, there are
no atomic typedefs corresponding to the fixed-size
standard typedefs int8_t, int16_t, and so forth.

<p><i>[
2010-10-24 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3164.html">n3164</a> would solve this issue.
</blockquote>



<p><b>Proposed resolution:</b></p>
Add the following entries to table 143:

<blockquote>
<table border="1">
<caption>Table 143 &mdash; Atomics for standard typedef types</caption>
<tr>
<th>atomic typedef name</th>
<th><tt>&lt;cstdint&gt;</tt> typedef name</th>
</tr>
<tr>
<td><tt>...</tt></td>
<td><tt>...</tt></td>
</tr>
<tr>
<td><tt>atomic_uintmax_t</tt></td>
<td><tt>uintmax_t</tt></td>
</tr>
<tr>
<td><ins><tt>atomic_int8_t</tt></ins></td>
<td><ins><tt>int8_t</tt> (optional)</ins></td>
</tr>
<tr>
<td><ins><tt>atomic_int16_t</tt></ins></td>
<td><ins><tt>int16_t</tt> (optional)</ins></td>
</tr>
<tr>
<td><ins><tt>atomic_int32_t</tt></ins></td>
<td><ins><tt>int32_t</tt> (optional)</ins></td>
</tr>
<tr>
<td><ins><tt>atomic_int64_t</tt></ins></td>
<td><ins><tt>int64_t</tt> (optional)</ins></td>
</tr>
<tr>
<td><ins><tt>atomic_uint8_t</tt></ins></td>
<td><ins><tt>uint8_t</tt> (optional)</ins></td>
</tr>
<tr>
<td><ins><tt>atomic_uint16_t</tt></ins></td>
<td><ins><tt>uint16_t</tt> (optional)</ins></td>
</tr>
<tr>
<td><ins><tt>atomic_uint32_t</tt></ins></td>
<td><ins><tt>uint32_t</tt> (optional)</ins></td>
</tr>
<tr>
<td><ins><tt>atomic_uint64_t</tt></ins></td>
<td><ins><tt>uint64_t</tt> (optional)</ins></td>
</tr>
</table>
</blockquote> 





<hr>
<h3><a name="1457"></a>1457. [FCD] Splitting lock-free properties</h3>
<p><b>Section:</b> 29.2 [atomics.syn] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-27</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-130</b></p>

The synopsis for the <tt>&lt;atomic&gt;</tt> header lists the macros
<tt>ATOMIC_INTEGRAL_LOCK_FREE</tt> and <tt>ATOMIC_ADDRESS_LOCK_FREE</tt>.
<p>
The <tt>ATOMIC_INTEGRAL_LOCK_FREE</tt> macro has been replaced with a set of macros 
for each integral type, as listed in 29.4 [atomics.lockfree].
</p>


<p><i>[
2010-10-26: Daniel adds:
]</i></p>


<p>
The proposed resolution below is against the FCD working draft. After application
of the editorial issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3162.html#US144">US-144</a>
and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3162.html#US146">US-146</a> the remaining difference
against the working draft is the usage of <em>implementation-defined</em> instead of <em>unspecified</em>, effectively
resulting in this delta:

<blockquote><pre>
// 29.4, lock-free property
#define ATOMIC_CHAR_LOCK_FREE <del><em>unspecified</em></del><ins><em>implementation-defined</em></ins>
#define ATOMIC_CHAR16_T_LOCK_FREE <del><em>unspecified</em></del><ins><em>implementation-defined</em></ins>
#define ATOMIC_CHAR32_T_LOCK_FREE <del><em>unspecified</em></del><ins><em>implementation-defined</em></ins>
#define ATOMIC_WCHAR_T_LOCK_FREE <del><em>unspecified</em></del><ins><em>implementation-defined</em></ins>
#define ATOMIC_SHORT_LOCK_FREE <del><em>unspecified</em></del><ins><em>implementation-defined</em></ins>
#define ATOMIC_INT_LOCK_FREE <del><em>unspecified</em></del><ins><em>implementation-defined</em></ins>
#define ATOMIC_LONG_LOCK_FREE <del><em>unspecified</em></del><ins><em>implementation-defined</em></ins>
#define ATOMIC_LLONG_LOCK_FREE <del><em>unspecified</em></del><ins><em>implementation-defined</em></ins>
#define ATOMIC_ADDRESS_LOCK_FREE <em>unspecified</em>
</pre></blockquote>
</p>

<p>
It is my understanding that the intended wording should be <em>unspecified</em> as for <tt>ATOMIC_ADDRESS_LOCK_FREE</tt>
but if this is right, we need to use the same wording in 29.4 [atomics.lockfree], which consequently uses
the term <em>implementation-defined</em>. I recommend to keep 29.2 [atomics.syn] as it currently is and to
fix 29.4 [atomics.lockfree] instead as indicated (against N3126):
</p>
<p>
New proposed resolution:
</p>
<p>
Change 29.4 [atomics.lockfree] as indicated:
<blockquote><pre>
#define ATOMIC_CHAR_LOCK_FREE <del><em>implementation-defined</em></del><ins><em>unspecified</em></ins>
#define ATOMIC_CHAR16_T_LOCK_FREE <del><em>implementation-defined</em></del><ins><em>unspecified</em></ins>
#define ATOMIC_CHAR32_T_LOCK_FREE <del><em>implementation-defined</em></del><ins><em>unspecified</em></ins>
#define ATOMIC_WCHAR_T_LOCK_FREE <del><em>implementation-defined</em></del><ins><em>unspecified</em></ins>
#define ATOMIC_SHORT_LOCK_FREE <del><em>implementation-defined</em></del><ins><em>unspecified</em></ins>
#define ATOMIC_INT_LOCK_FREE <del><em>implementation-defined</em></del><ins><em>unspecified</em></ins>
#define ATOMIC_LONG_LOCK_FREE <del><em>implementation-defined</em></del><ins><em>unspecified</em></ins>
#define ATOMIC_LLONG_LOCK_FREE <del><em>implementation-defined</em></del><ins><em>unspecified</em></ins>
#define ATOMIC_ADDRESS_LOCK_FREE <del><em>implementation-defined</em></del><ins><em>unspecified</em></ins>
</pre></blockquote>
</p>
<p><b>Proposed resolution:</b></p>
Against FCD, N3092:
<p>
In [atomics.syn], header <tt>&lt;atomic&gt;</tt> synopsis replace as indicated:
</p>
<blockquote><pre>
// 29.4, lock-free property
<del>#define ATOMIC_INTEGRAL_LOCK_FREE <em>unspecified</em></del>
<ins>#define ATOMIC_CHAR_LOCK_FREE <em>implementation-defined</em></ins>
<ins>#define ATOMIC_CHAR16_T_LOCK_FREE <em>implementation-defined</em></ins>
<ins>#define ATOMIC_CHAR32_T_LOCK_FREE <em>implementation-defined</em></ins>
<ins>#define ATOMIC_WCHAR_T_LOCK_FREE <em>implementation-defined</em></ins>
<ins>#define ATOMIC_SHORT_LOCK_FREE <em>implementation-defined</em></ins>
<ins>#define ATOMIC_INT_LOCK_FREE <em>implementation-defined</em></ins>
<ins>#define ATOMIC_LONG_LOCK_FREE <em>implementation-defined</em></ins>
<ins>#define ATOMIC_LLONG_LOCK_FREE <em>implementation-defined</em></ins>
#define ATOMIC_ADDRESS_LOCK_FREE <em>unspecified</em>
</pre></blockquote>






<hr>
<h3><a name="1459"></a>1459. [FCD] Overlapping evaluations are allowed</h3>
<p><b>Section:</b> 29.3 [atomics.order] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Canada <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-29</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.order">issues</a> in [atomics.order].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Duplicate of:</b> <a href="lwg-closed.html#1458">1458</a></p>
<p><b>Discussion:</b></p>
<p><b>Addresses CA-21, GB-131</b></p>

29.4 [atomics.lockfree] p.8 states:
<p><blockquote>
An atomic store shall only store a value that has
been computed from constants and program input values
by a finite sequence of program evaluations, such
that each evaluation observes the values of variables
as computed by the last prior assignment in the
sequence.
</blockquote></p>
<p>
... but 1.9 [intro.execution] p.13 states:
</p>
<p><blockquote>
If A is not sequenced before B and B is not
sequenced before A, then A and B are unsequenced.
[ <em>Note</em>: The execution of unsequenced
evaluations can overlap. &mdash; <em>end note</em> ]
</blockquote></p>
<p>
Overlapping executions can make it impossible to
construct the sequence described in 29.4 [atomics.lockfree] p.8. We are not
sure of the intention here and do not offer a suggestion for
change, but note that 29.4 [atomics.lockfree] p.8 is the condition that prevents
out-of-thin-air reads.
</p>
<p>
For an example, suppose we have a function invocation
f(e1,e2). The evaluations of e1 and e2 can overlap.
Suppose that the evaluation of e1 writes y and reads x
whereas the evaluation of e2 reads y and writes x, with
reads-from edges as below (all this is within a single
thread).
<PRE>
 e1           e2
Wrlx y--   --Wrlx x
      rf\ /rf
         X
        / \
Rrlx x&lt;-   -&gt;Rrlx y
</PRE>
This seems like it should be allowed, but there seems to
be no way to produce a sequence of evaluations with the
property above.
</p>
In more detail, here the two evaluations, e1 and e2, are
being executed as the arguments of a function and are
consequently not sequenced-before each other. In
practice we'd expect that they could overlap (as allowed
by 1.9 [intro.execution] p.13), with the two writes taking effect before the two
reads. However, if we have to construct a linear order of
evaluations, as in 29.4 [atomics.lockfree] p.8, then the execution above is not
permited. Is that really intended?

<p><i>[
Resolution proposed by ballot comment
]</i></p>

<p>
Please clarify.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1460"></a>1460. [FCD] Missing lock-free property for type <tt>bool</tt> should be added</h3>
<p><b>Section:</b> 29.4 [atomics.lockfree] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.lockfree">issues</a> in [atomics.lockfree].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-154</b></p>

There is no <tt>ATOMIC_BOOL_LOCK_FREE</tt> macro.


<p><b>Proposed resolution:</b></p>
Add <tt>ATOMIC_BOOL_LOCK_FREE</tt> to 29.4 [atomics.lockfree] and to 29.2 [atomics.syn]:
<p>
<blockquote><pre>
[..]
<ins>#define ATOMIC_BOOL_LOCK_FREE <em>unspecified</em></ins>
#define ATOMIC_CHAR_LOCK_FREE <em>unspecified</em>
#define ATOMIC_CHAR16_T_LOCK_FREE <em>unspecified</em>
#define ATOMIC_CHAR32_T_LOCK_FREE <em>unspecified</em>
[..]
</pre></blockquote>
</p>





<hr>
<h3><a name="1461"></a>1461. [FCD] Rename all <tt>ATOMIC_*</tt> macros as <tt>STD_ATOMIC_*</tt></h3>
<p><b>Section:</b> 29 [atomics] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Canada <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-27</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics">active issues</a> in [atomics].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics">issues</a> in [atomics].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses CA-1</b></p>

All <tt>ATOMIC_</tt>... macros should be prefixed with <tt>STD_</tt> as
in <tt>STD_ATOMIC_</tt>... to indicate they are <tt>STD</tt> macros as
other standard macros. The rationale that they all seem too long seems weak.


<p><b>Proposed resolution:</b></p>
<ol>
<li>Change sub-clause 29.2 [atomics.syn] as indicated:
<p>
<blockquote><pre>
[..]
// <em>29.4, lock-free property</em>
#define <ins>STD_</ins>ATOMIC_CHAR_LOCK_FREE <em>unspecified</em>
#define <ins>STD_</ins>ATOMIC_CHAR16_T_LOCK_FREE <em>unspecified</em>
#define <ins>STD_</ins>ATOMIC_CHAR32_T_LOCK_FREE <em>unspecified</em>
#define <ins>STD_</ins>ATOMIC_WCHAR_T_LOCK_FREE <em>unspecified</em>
#define <ins>STD_</ins>ATOMIC_SHORT_LOCK_FREE <em>unspecified</em>
#define <ins>STD_</ins>ATOMIC_INT_LOCK_FREE <em>unspecified</em>
#define <ins>STD_</ins>ATOMIC_LONG_LOCK_FREE <em>unspecified</em>
#define <ins>STD_</ins>ATOMIC_LLONG_LOCK_FREE <em>unspecified</em>
#define <ins>STD_</ins>ATOMIC_ADDRESS_LOCK_FREE <em>unspecified</em>

// <em>29.6, operations on atomic types</em>
#define <ins>STD_</ins>ATOMIC_VAR_INIT(value) <em>see below</em>
[..]
</pre></blockquote>
</p>
</li>
<li>
Change 29.4 [atomics.lockfree] p. 1 as indicated:
<blockquote><pre>
#define <ins>STD_</ins>ATOMIC_CHAR_LOCK_FREE <em>implementation-defined</em>
#define <ins>STD_</ins>ATOMIC_CHAR16_T_LOCK_FREE <em>implementation-defined</em>
#define <ins>STD_</ins>ATOMIC_CHAR32_T_LOCK_FREE <em>implementation-defined</em>
#define <ins>STD_</ins>ATOMIC_WCHAR_T_LOCK_FREE <em>implementation-defined</em>
#define <ins>STD_</ins>ATOMIC_SHORT_LOCK_FREE <em>implementation-defined</em>
#define <ins>STD_</ins>ATOMIC_INT_LOCK_FREE <em>implementation-defined</em>
#define <ins>STD_</ins>ATOMIC_LONG_LOCK_FREE <em>implementation-defined</em>
#define <ins>STD_</ins>ATOMIC_LLONG_LOCK_FREE <em>implementation-defined</em>
#define <ins>STD_</ins>ATOMIC_ADDRESS_LOCK_FREE <em>implementation-defined</em>
</pre><blockquote>
1 The <tt><ins>STD_</ins>ATOMIC_..._LOCK_FREE</tt> macros indicate the lock-free property of the corresponding atomic types, [..]
</blockquote></blockquote>
</li>
<li>
Change 29.6 [atomics.types.operations] p. 5 as indicated:
<blockquote><pre>
#define <ins>STD_</ins>ATOMIC_VAR_INIT(value) <em>see below</em>
</pre><blockquote>
5 <em>Remarks</em>: A macro that expands to a token sequence suitable for initializing an atomic variable of
a type that is initializion-compatible with value. Concurrent access to the variable being initialized,
even via an atomic operation, constitutes a data race. [ <em>Example:</em>
<blockquote><pre>
atomic_int v = <ins>STD_</ins>ATOMIC_VAR_INIT(5);
</pre></blockquote>
&mdash; <em>end example</em> ]
</blockquote></blockquote>
</li>
<li>
Change 29.7 [atomics.flag] p. 1+4 as indicated:
<blockquote><pre>
namespace std {
  [..]
  #define <ins>STD_</ins>ATOMIC_FLAG_INIT <em>see below</em>
}
</pre><blockquote>
[..]
4 The macro <tt><ins>STD_</ins>ATOMIC_FLAG_INIT</tt> shall be defined in such a way that it can be used to initialize an object of
type <tt>atomic_flag</tt> to the clear state. For a static-duration object, that initialization shall be static. It is
unspecified whether an unitialized <tt>atomic_flag</tt> object has an initial state of set or clear. [ <em>Example:</em>
<blockquote><pre>
atomic_flag guard = <ins>STD_</ins>ATOMIC_FLAG_INIT;
</pre></blockquote>
&mdash; <em>end example</em> ]
</blockquote></blockquote>
</li>
</ol>





<hr>
<h3><a name="1474"></a>1474. [FCD] weak compare-and-exchange confusion</h3>
<p><b>Section:</b> 29.6 [atomics.types.operations] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.types.operations">active issues</a> in [atomics.types.operations].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.types.operations">issues</a> in [atomics.types.operations].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Duplicate of:</b> <a href="lwg-closed.html#1470">1470</a>, <a href="lwg-closed.html#1475">1475</a>, <a href="lwg-closed.html#1476">1476</a>, <a href="lwg-closed.html#1477">1477</a></p>
<p><b>Discussion:</b></p>



<p><b>Addresses US-175, US-165, CH-23, GB-135</b></p>

29.6 [atomics.types.operations] p. 23: The first sentence is grammatically incorrect.

<p><i>[
2010-10-28 Daniel adds:
]</i></p>

<p>
Proposed resolution of duplicate issue <a href="lwg-closed.html#1475">1475</a>:
</p>
Change 29.6 [atomics.types.operations] p. 23 as indicated:
<blockquote>
23 <em>Remark</em>: <del>The weak compare-and-exchange operations may fail spuriously, that is, return false while
leaving the contents of memory pointed to by <tt>expected</tt> before the operation is the same that same
as that of the <tt>object</tt> and the same as that of <tt>expected</tt> after the operation</del><ins>The weak 
compare-and-exchange operations may fail spuriously, that is, return false while leaving the contents of memory 
pointed to by <tt>expected</tt> unchanged.</ins>. [ <em>Note</em>: This spurious failure enables implementation of 
compare-and-exchange on a broader class of machines, e.g., loadlocked store-conditional machines. A consequence of 
spurious failure is that nearly all uses of weak compare-and-exchange will be in a loop.
<p/>
When a compare-and-exchange is in a loop, the weak version will yield better performance on some
platforms. When a weak compare-and-exchange would require a loop and a strong one would not, the
strong one is preferable. &mdash; <em>end note</em> ]
</blockquote>


<p><b>Proposed resolution:</b></p>
Change 29.6 [atomics.types.operations] p. 23 as indicated:
<blockquote>
23 <em>Remark</em>: <del>The weak compare-and-exchange operations may fail spuriously, that is, return false while
leaving the contents of memory pointed to by <tt>expected</tt> before the operation is the same that same
as that of the <tt>object</tt> and the same as that of <tt>expected</tt> after the operation</del><ins>The weak
compare-and-exchange operations may fail spuriously. That is, it may return false while leaving the contents of 
memory pointed to by <tt>expected</tt> the same as it was before the operation</ins>. [ <em>Note</em>: This spurious
failure enables implementation of compare-and-exchange on a broader class of machines, e.g., loadlocked
store-conditional machines. A consequence of spurious failure is that nearly all uses of weak
compare-and-exchange will be in a loop.
<p/>
When a compare-and-exchange is in a loop, the weak version will yield better performance on some
platforms. When a weak compare-and-exchange would require a loop and a strong one would not, the
strong one is preferable. &mdash; <em>end note</em> ]
</blockquote>





<hr>
<h3><a name="1478"></a>1478. [FCD] Clarify race conditions in atomics initialization</h3>
<p><b>Section:</b> 29.6 [atomics.types.operations] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-10-29</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.types.operations">active issues</a> in [atomics.types.operations].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.types.operations">issues</a> in [atomics.types.operations].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-136</b></p>

GB requests normative clarification in 29.6 [atomics.types.operations] p.4 that
concurrent access constitutes a race, as already done on p.6 and p.7.

<p><i>[
Resolution proposed in ballot comment:
]</i></p>


<blockquote>
Initialisation of atomics:
<p/>
We believe the intent is that for any atomics there is a distinguished
initialisation write, but that this need not happens-before all the
other operations on that atomic - specifically so that the
initialisation write might be non-atomic and hence give rise to a data
race, and hence undefined behaviour, in examples such as this (from
Hans):
<blockquote><pre>
atomic&lt;atomic&lt;int&gt; *&gt; p
f()                      |
{ atomic&lt;int&gt;x;          | W_na x
  p.store(&ampx,mo_rlx); | W_rlx p=&amp;x
}                        |
</pre></blockquote>
(where na is nonatomic and rlx is relaxed). We suspect also that no
other mixed atomic/nonatomic access to the same location is intended
to be permitted. Either way, a note would probably help.
</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1479"></a>1479. [FCD] Fence functions should be <tt>extern "C"</tt></h3>
<p><b>Section:</b> 29.8 [atomics.fences] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.fences">active issues</a> in [atomics.fences].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.fences">issues</a> in [atomics.fences].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-179</b></p>

The fence functions (29.8 [atomics.fences] p.5 + p.6) should be <tt>extern "C"</tt>, for <tt>C</tt> compatibility.


<p><b>Proposed resolution:</b></p>
<ol>
<li>Change 29.2 [atomics.syn], header <tt>&lt;atomic&gt;</tt> synopsis as indicated:
<blockquote><pre>
namespace std {
  [..]
  // <em>29.8, fences</em>
  <ins>extern "C"</ins> void atomic_thread_fence(memory_order);
  <ins>extern "C"</ins> void atomic_signal_fence(memory_order);  
}
</pre></blockquote>
</li>
<li>Change 29.8 [atomics.fences], p. 5 and p. 6 as indicated:
<blockquote><pre>
<ins>extern "C"</ins> void atomic_thread_fence(memory_order);
</pre><blockquote>
5 <em>Effects</em>: depending on the value of <tt>order</tt>, this operation: [..]
</blockquote></blockquote>
<blockquote><pre>
<ins>extern "C"</ins> void atomic_signal_fence(memory_order);  
</pre><blockquote>
6 <em>Effects</em>: equivalent to <tt>atomic_thread_fence(order)</tt>, except that synchronizes with relationships are
established only between a thread and a signal handler executed in the same thread.
</blockquote></blockquote>
</li>
</ol>





<hr>
<h3><a name="1480"></a>1480. [FCD] Atomic fences don't have <em>synchronizes with</em> relation</h3>
<p><b>Section:</b> 29.8 [atomics.fences] <b>Status:</b> <a href="lwg-active.html#Review">Review</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-14</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.fences">active issues</a> in [atomics.fences].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.fences">issues</a> in [atomics.fences].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-137</b></p>

Thread fence not only establish synchronizes with relationships,
there are semantics of fences that are expressed not in
terms of <em>synchronizes with</em> relationships (for example see 29.3 [atomics.order] p.5).
These semantics also need to apply to the use of
<tt>atomic_signal_fence</tt> in a restricted way.

<p><i>[Batavia: Concurrency group discussed issue, and is OK with the proposed resolution.]</i></p>



<p><b>Proposed resolution:</b></p>
Change 29.8 [atomics.fences] p. 6 as indicated:
<blockquote><pre>
void atomic_signal_fence(memory_order);  
</pre><blockquote>
6 <em>Effects</em>: equivalent to <tt>atomic_thread_fence(order)</tt>, except that <del>synchronizes 
with relationships</del><ins>the resulting ordering constraints</ins> are established only between a 
thread and a signal handler executed in the same thread.
</blockquote></blockquote>





<hr>
<h3><a name="1485"></a>1485. [FCD] Unclear <tt>thread::id</tt> specification</h3>
<p><b>Section:</b> 30.3.1.1 [thread.thread.id] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.thread.id">issues</a> in [thread.thread.id].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-184</b></p>

It is unclear when a <tt>thread::id</tt> ceases to be meaningful.
The sentence "The library may reuse the value of a
<tt>thread::id</tt> of a terminated thread that can no longer be
joined." implies that some terminated threads can be
joined. It says nothing about detached threads.

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote>
Require a unique <tt>thread::id</tt> for every thread that is
(1) detached and not terminated or (2) has an associated <tt>std::thread</tt> 
object.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1486"></a>1486. [FCD] Value of <tt>this_thread::get_id()</tt> underspecified for detached thread</h3>
<p><b>Section:</b> 30.3.2 [thread.thread.this] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Switzerland <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-01</p>
<p><b>View other</b> <a href="lwg-index-open.html#thread.thread.this">active issues</a> in [thread.thread.this].</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.thread.this">issues</a> in [thread.thread.this].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses CH-24</b></p>

What would be the value <tt>this_thread::get_id()</tt> when called from a detached thread?

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<p>
Add some text to clarify that get_id() still returns
the same value even after detaching.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1487"></a>1487. [FCD] Clock related operations exception specifications conflict</h3>
<p><b>Section:</b> 30.3.2 [thread.thread.this] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Switzerland <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-01</p>
<p><b>View other</b> <a href="lwg-index-open.html#thread.thread.this">active issues</a> in [thread.thread.this].</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.thread.this">issues</a> in [thread.thread.this].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses CH-25</b></p>

Clock related operations are currently not required not to
throw. So "Throws: Nothing." is not always true.

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote>
Either require clock related operations not to throw
(in 20.10) or change the Throws clauses in 30.3.2.
Also possibly add a note that <tt>abs_time</tt> in the past
or negative <tt>rel_time</tt> is allowed.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1494"></a>1494. [FCD] Term "are serialized" not defined</h3>
<p><b>Section:</b> 30.4.5.2 [thread.once.callonce] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-190</b></p>

The term "are serialized" is never defined (30.4.5.2 [thread.once.callonce] p. 2).

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<p>
Remove the sentence with "are serialized" from
paragraph 2. Add "Calls to <tt>call_once</tt> on the same
<tt>once_flag</tt> object shall not introduce data races
(17.6.4.8)." to paragraph 3.
</p>

<p><i>[
2010-11-01 Daniel translates NB comment into wording
]</i></p>




<p><b>Proposed resolution:</b></p>
Change 30.4.5.2 [thread.once.callonce] p.2+3 as indicated:
<blockquote><pre>
template&lt;class Callable, class ...Args&gt;
void call_once(once_flag&amp; flag, Callable&amp;&amp; func, Args&amp;&amp;... args);
</pre><blockquote>
[..]
<p/>
2 <em>Effects</em>: <del>Calls to <tt>call_once</tt> on the same <tt>once_flag</tt> object are serialized.</del>
If there has been a prior effective call to <tt>call_once</tt> on the same <tt>once_flag object</tt>, 
the call to <tt>call_once</tt> returns without invoking <tt>func</tt>. If there has been no prior 
effective call to <tt>call_once</tt> on the same <tt>once_flag</tt> object,
<tt>INVOKE(decay_copy( std::forward&lt;Callable&gt;(func)), decay_copy(std::forward&lt;Args&gt;(args))...)</tt>
is executed. The call to <tt>call_once</tt> is effective if and only if 
<tt>INVOKE(decay_copy( std::forward&lt;Callable&gt;(func)), decay_copy(std::forward&lt;Args&gt;(args))...)</tt> 
returns without throwing an exception. If an exception is thrown it is propagated to the caller.
<p/>
3 <em>Synchronization</em>: The completion of an effective call to <tt>call_once</tt> on a <tt>once_flag</tt> 
object synchronizes with (1.10) all subsequent calls to <tt>call_once</tt> on the same <tt>once_flag</tt> object.
<ins>Calls to <tt>call_once</tt> on the same <tt>once_flag</tt> object shall not introduce data races ([res.on.data.races]).</ins>
</blockquote></blockquote>





<hr>
<h3><a name="1502"></a>1502. [FCD] Specification of [futures.state]</h3>
<p><b>Section:</b> 30.6.4 [futures.state] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures.state">active issues</a> in [futures.state].</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.state">issues</a> in [futures.state].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-195</b></p>

The intent and meaning of the paragraph is not apparent.


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1503"></a>1503. [FCD] "associated asynchronous state" must go</h3>
<p><b>Section:</b> 30.6.4 [futures.state] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Switzerland <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-01</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures.state">active issues</a> in [futures.state].</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.state">issues</a> in [futures.state].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses CH-35</b></p>

The term "associated asynchronous state" is long, ugly
and misleading terminology. When introduced we agreed
upon that we should come up with a better name. Here it
is: "liaison state". Since the state is hidden and provides
synchronization of a future with its corresponding promise,
we believe "liaison state" is a much better and shorter
name (liaison ~ (typically hidden) relationship)

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote>
Change all occurrences of "associated
asynchronous state" to "liaison state".
</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1504"></a>1504. [FCD] Term "are serialized" is not defined</h3>
<p><b>Section:</b> 30.6.5 [futures.promise] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures.promise">active issues</a> in [futures.promise].</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.promise">issues</a> in [futures.promise].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-196</b></p>

The term "are serialized" is not defined (30.6.5 [futures.promise] p. 21, 25).

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote>
Replace "are serialized" with "shall not introduce a data race (17.6.4.8)".
</blockquote>

<p><i>[
2010-11-02 Daniel translates proposal into proper wording changes
]</i></p>



<p><b>Proposed resolution:</b></p>
<ol>
<li>Change 30.6.5 [futures.promise] p. 21 as indicated:
<blockquote>
21 <em>Synchronization</em>: calls to <tt>set_value</tt> and <tt>set_exception</tt> on a single 
<tt>promise</tt> object <del>are serialized</del><ins>shall not introduce a data race ([res.on.data.races])</ins>.
[ <em>Note</em>: and they synchronize and serialize with other functions through the referred associated asynchronous
state. &mdash; <em>end note</em> ]
</blockquote>
</li>
<li>Change 30.6.5 [futures.promise] p. 25 as indicated:
<blockquote>
25 <em>Synchronization</em>: calls to <tt>set_value</tt> and <tt>set_exception</tt> on a single 
<tt>promise</tt> object <del>are serialized</del><ins>shall not introduce a data race ([res.on.data.races])</ins>.
[ <em>Note</em>: and they synchronize and serialize with other functions through the referred associated asynchronous
state. &mdash; <em>end note</em> ]
</blockquote>
</li>
</ol>





<hr>
<h3><a name="1505"></a>1505. [FCD] Synchronization between
<tt>promise::set_value</tt> and <tt>future::get</tt></h3>
<p><b>Section:</b> 30.6.5 [futures.promise] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures.promise">active issues</a> in [futures.promise].</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.promise">issues</a> in [futures.promise].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-197</b></p>

There is no defined synchronization between
<tt>promise::set_value</tt> and <tt>future::get</tt> (30.6.5 [futures.promise] p. 21, 25).

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote>
Replace "[Note: and they synchronize and
serialize with other functions through the referred
associated asynchronous state. --end note]" with
the normative "They synchronize with (1.10) any
operation on a future object with the same
associated asynchronous state marked ready."
</blockquote>

<p><i>[
2010-11-02 Daniel translates proposal into proper wording changes
]</i></p>



<p><b>Proposed resolution:</b></p>
<ol>
<li>Change 30.6.5 [futures.promise] p. 21 as indicated:
<blockquote>
21 <em>Synchronization</em>: calls to <tt>set_value</tt> and <tt>set_exception</tt> on a single 
<tt>promise</tt> object are serialized.
<del>[ <em>Note</em>: and they synchronize and serialize with other functions through the referred associated asynchronous
state. &mdash; <em>end note</em> ]</del><ins>They <em>synchronize with</em> ([intro.multithread]) any
operation on a future object with the same associated asynchronous state marked ready.</ins>
</blockquote>
</li>
<li>Change 30.6.5 [futures.promise] p. 25 as indicated:
<blockquote>
25 <em>Synchronization</em>: calls to <tt>set_value</tt> and <tt>set_exception</tt> on a single 
<tt>promise</tt> object are serialized.
<del>[ <em>Note</em>: and they synchronize and serialize with other functions through the referred associated asynchronous
state. &mdash; <em>end note</em> ]</del><ins>They <em>synchronize with</em> ([intro.multithread]) any
operation on a future object with the same associated asynchronous state marked ready.</ins>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="1507"></a>1507. [FCD] <tt>promise::<i>XXX</i>_at_thread_exit</tt> functions have no
synchronization requirements</h3>
<p><b>Section:</b> 30.6.5 [futures.promise] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures.promise">active issues</a> in [futures.promise].</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.promise">issues</a> in [futures.promise].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-199</b></p>

<tt>promise::<i>XXX</i>_at_thread_exit</tt> functions have no
synchronization requirements. Specifying synchronization
for these member functions requires coordinating with the
words in 30.6.5/21 and 25, which give synchronization
requirements for <tt>promise::set_value</tt> and
<tt>promise::set_exception</tt> (30.6.5 [futures.promise] p. 26 ff., p. 29 ff.).

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote>
Change 30.6.5/21 to mention
set_value_at_thread_exit and
set_exception_at_thread_exit; with this text,
replace 30.6.5/25 and add two new paragraphs,
after 30.6.5/28 and 30.6.5/31.
</blockquote>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1514"></a>1514. [FCD] <tt>packaged_task</tt> constructors need review</h3>
<p><b>Section:</b> 30.6.10.1 [futures.task.members] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures.task.members">active issues</a> in [futures.task.members].</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.task.members">issues</a> in [futures.task.members].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-207</b></p>

The constructor that takes R(*)(ArgTypes...) is not
needed; the constructor that takes a callable type works
for this argument type. More generally, the constructors
for packaged_task should parallel those for function.

<p><i>[
US-207 Suggested Resolution:
]</i></p>


<blockquote>
Review the constructors for packaged_task and
provide the same ones as function, except where
inappropriate.
</blockquote>

<p><i>[
2010-10-22 Howard provides wording, as requested by the LWG in Rapperswil.
]</i></p>




<p><b>Proposed resolution:</b></p>
Alter the list of constructors in both [futures.task] and in [futures.task.members] as indicated:

<blockquote>
<pre><del>template &lt;class F&gt;
explicit packaged_task(F f);
template &lt;class F, class Allocator&gt;
explicit packaged_task(allocator_arg_t, const Allocator&amp; a, F f);
explicit packaged_task(R(*f)(ArgTypes...));</del>
template &lt;class F&gt;
explicit packaged_task(F&amp;&amp; f);
template &lt;class F, class Allocator&gt;
explicit packaged_task(allocator_arg_t, const Allocator&amp; a, F&amp;&amp; f);
</pre>
</blockquote>





<hr>
<h3><a name="1515"></a>1515. [FCD] <tt>packaged_task::make_ready_at_thread_exit</tt> has no
synchronization requirements</h3>
<p><b>Section:</b> 30.6.10.1 [futures.task.members] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-04</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures.task.members">active issues</a> in [futures.task.members].</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.task.members">issues</a> in [futures.task.members].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-208</b></p>

<p>
<tt>packaged_task::make_ready_at_thread_exit</tt> has no
synchronization requirements.
</p>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<p>
Figure out what the synchronization requirements
should be and write them.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1521"></a>1521. Requirements on internal pointer representations in containers</h3>
<p><b>Section:</b> 23.2.1 [container.requirements.general] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Mike Spertus <b>Opened:</b> 2010-10-16 <b>Last modified:</b> 2010-11-04</p>
<p><b>View other</b> <a href="lwg-index-open.html#container.requirements.general">active issues</a> in [container.requirements.general].</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements.general">issues</a> in [container.requirements.general].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-104, US-141</b></p>

<p>
The standard doesn't say that containers should use abstract pointer 
types internally. Both Howard and Pablo agree that this is the intent. 
Further, it is necessary for containers to be stored, for example, in 
shared memory with an interprocess allocator (the type of scenario that 
allocators are intended to support).
</p>
<p>
In spite of the (possible) agreement on intent, it is necessary to make 
this explicit:
</p>
<p>
An implementations may like to store the result of dereferencing the 
pointer (which is a raw reference) as an optimization, but that prevents 
the data structure from being put in shared memory, etc. In fact, a 
container could store raw references to the allocator, which would be a 
little weird but conforming as long as it has one by-value copy. 
Furthermore, pointers to locales, ctypes, etc. may be there, which also 
prevents the data structure from being put in shared memory, so we 
should make explicit that a container does not store raw pointers or 
references at all.
</p>

<p><i>[
Pre-batavia
]</i></p>

<p>
This issue is being opened as part of the response to NB comments US-104/141. 
See paper <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3171.pdf">N3171</a>
in the pre-Batavia mailing. 
</p>



<p><b>Proposed resolution:</b></p>
<p>
Add to the end of 23.2.1 [container.requirements.general] p. 8:
</p>
<blockquote>
[..] In all container types defined in this Clause, the member <tt>get_allocator()</tt> returns 
a copy of the allocator used to construct the container or, if that allocator has been replaced, 
a copy of the most recent replacement. <ins>The container may not store internal objects whose 
types are of the form  <tt>T *</tt> or <tt>T &amp;</tt> except insofar as they are part of the 
item type or members.</ins>
</blockquote>





<hr>
<h3><a name="1523"></a>1523. [FCD] <tt>noexcept</tt> for Clause 29</h3>
<p><b>Section:</b> 29 [atomics] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Hans Boehm <b>Opened:</b> 2010-11-13 <b>Last modified:</b> 2010-11-14</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics">active issues</a> in [atomics].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics">issues</a> in [atomics].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-63 for Clause 29</b></p>

<p>Clause 29 does not specify noexcept for any of the atomic operations.
It probably should, though that's not completely clear.
In particular, atomics may want to throw in implementations that support transactional memory.
</p>


<p><b>Proposed resolution:</b></p>
<p>
</p>





<hr>
<h3><a name="2001"></a>2001. Class template <tt>basic_regex</tt> uses non existent <tt>string_type</tt></h3>
<p><b>Section:</b> 28.8.3 [re.regex.assign] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Volker Lukas <b>Opened:</b> 2010-10-21 <b>Last modified:</b> 2010-11-13</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In working draft N3126, subclause 28.8.3 [re.regex.assign], paragraphs 12, 13 and 19, 
the name <tt>string_type</tt> is used. This is presumably a typedef for <tt>basic_string&lt;value_type&gt;</tt>, where 
<tt>value_type</tt> is the character type used by <tt>basic_regex</tt>. The <tt>basic_regex</tt> 
template however defines no such typedef, and neither does the <tt>&lt;regex&gt;</tt> 
header or the <tt>&lt;initializer_list&gt;</tt> header included by <tt>&lt;regex&gt;</tt>.
</p>

<p><i>[
2010-11-03 Daniel comments and suggests alternative wording:
]</i></p>

<blockquote>
The proposed resolution needs to use <tt>basic_string&lt;<strong>charT</strong>&gt;</tt> instead of <tt>basic_string&lt;char&gt;</tt>
</blockquote>

<p>Proposed Resolution:</p>

Make the following changes to [re.regex.assign]:<p/>

<blockquote>
<pre>
basic_regex&amp; assign(const charT* ptr, flag_type f = regex_constants::ECMAScript);
</pre>
<blockquote>
12 <i>Returns</i>: <tt>assign(<del>string_type</del><ins>basic_string&lt;charT&gt;</ins>(ptr), f)</tt>. 
</blockquote>

<pre>
basic_regex&amp; assign(const charT* ptr, size_t len,
  flag_type f = regex_constants::ECMAScript);
</pre>
<blockquote>
13 <i>Returns</i>: <tt>assign(<del>string_type</del><ins>basic_string&lt;charT&gt;</ins>(ptr, len), f)</tt>.
</blockquote>

<pre>
[..]

template &lt;class InputIterator&gt; 
  basic_regex&amp; assign(InputIterator first, InputIterator last, 
                          flag_type f = regex_constants::ECMAScript);
</pre>

<blockquote>
18 <i>Requires</i>: The type <tt>InputIterator</tt> shall satisfy the requirements for an Input Iterator (24.2.3).
</blockquote>

<blockquote>
19 <i>Returns</i>: <tt>assign(<del>string_type</del><ins>basic_string&lt;charT&gt;</ins>(first, last), f)</tt>.
</blockquote>

</blockquote>

<p><i>[
2010 Batavia 
]</i></p>


<p>
Unsure if we should just give <tt>basic_regex</tt> a <tt>string_type</tt> typedef. Looking for when <tt>string_type</tt> was 
introduced into <tt>regex</tt>. Howard to draft wording for <tt>typedef typename traits::string_type string_type</tt>, then move to Review. 
</p>


<p><b>Proposed resolution:</b></p>
<p>
Make the following changes to [re.regex.assign]:</p>

<blockquote>

<pre>
basic_regex&amp; assign(const charT* ptr, flag_type f = regex_constants::ECMAScript);
</pre>
<blockquote>
12 <i>Returns</i>: <tt>assign(<del>string_type</del><ins>basic_string&lt;char&gt;</ins>(ptr), f)</tt>. 
</blockquote>

<pre>
basic_regex&amp; assign(const charT* ptr, size_t len,
  flag_type f = regex_constants::ECMAScript);
</pre>
<blockquote>
13 <i>Returns</i>: <tt>assign(<del>string_type</del><ins>basic_string&lt;char&gt;</ins>(ptr, len), f)</tt>.
</blockquote>

<pre>
[..]

template &lt;class InputIterator&gt; 
  basic_regex&amp; assign(InputIterator first, InputIterator last, 
                          flag_type f = regex_constants::ECMAScript);
</pre>

<blockquote>
18 <i>Requires</i>: The type <tt>InputIterator</tt> shall satisfy the requirements for an Input Iterator (24.2.3).
</blockquote>

<blockquote>
19 <i>Returns</i>: <tt>assign(<del>string_type</del><ins>basic_string&lt;char&gt;</ins>(first, last), f)</tt>.
</blockquote>

</blockquote>






<hr>
<h3><a name="2003"></a>2003. String exception inconsistency in erase.</h3>
<p><b>Section:</b> 21.4.1 [string.require] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> José Daniel García Sánchez <b>Opened:</b> 2010-10-21 <b>Last modified:</b> 2010-11-13</p>
<p><b>View all other</b> <a href="lwg-index.html#string.require">issues</a> in [string.require].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Clause 21.4.1 [string.require]p3 states:
</p>
<blockquote>
No <tt>erase()</tt> or <tt>pop_back()</tt> member function shall throw
any exceptions.
</blockquote>
<p>
However in 21.4.6.5 [string::erase] p2 the first version of <tt>erase</tt> has
</p>
<blockquote>
<i>Throws</i>: <tt>out_of_range</tt> if <tt>pos > size()</tt>.
</blockquote>



<p><b>Proposed resolution:</b></p>
<p>
Update [string.require]p/3:
</p>
<blockquote>
3 No <del><tt>erase()</tt> or</del> <tt>pop_back()</tt> member function
shall throw any exceptions.
</blockquote>





<hr>
<h3><a name="2005"></a>2005. <tt>unordered_map::insert(T&amp;&amp;)</tt> protection should apply to <tt>map</tt> too</h3>
<p><b>Section:</b> 23.6.1.3 [map.modifiers], 23.6.2.2 [multimap.modifiers] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2010-10-14 <b>Last modified:</b> 2010-11-13</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In [unord.map.modifiers], the signature:
<blockquote><pre>
template &lt;class P&gt;
    pair&lt;iterator, bool&gt; insert(P&amp;&amp; obj);
</pre></blockquote>
now has an added Remarks paragraph:
</p>
<blockquote>
<i>Remarks</i>: This signature shall not participate in overload resolution unless <tt>P</tt>
is implicitly convertible to <tt>value_type</tt>.
</blockquote>
<p>
The same is true for <tt>unordered_multimap</tt>.
</p>
<p>
But neither <tt>map</tt> nor <tt>multimap</tt> have this constraint, even though it is a
Good Thing(TM) in those cases as well.
</p>

<p><i>[
The submitter suggests: Add the same Remarks clause to [map.modifiers] and [multimap.modifiers].
]</i></p>


<p><i>[
2010-10-29 Daniel comments:
]</i></p>


<p>
I believe both paragraphs need more cleanup: First, the current Requires element conflict with the Remark; 
second, it seems to me that the whole single Requires element is intended to be split into a Requires
and an Effects element; third, the reference to <tt>tuple</tt> is incorrect (noticed by Paolo Carlini);
fourth, it refers to some non-existing <tt>InputIterator</tt> parameter relevant for a completely different
overload; sixth, the return type of the overload with hint is wrong.
The following proposed resolution tries to solve these issues as well and uses similar wording as for
the corresponding unordered containers. Unfortunately it has some redundancy over Table&nbsp;99, but I did
not remove the specification because of the more general template parameter <tt>P</tt> - the Table&nbsp;99 
requirements apply only for an argument <em>identical</em> to <tt>value_type</tt>.
</p>

<p>
Proposed resolution:
</p>

<p>
<ol>
<li>Change 23.6.1.3 [map.modifiers] around p. 1 as indicated:
<blockquote><pre>
template &lt;class P&gt; pair&lt;iterator, bool&gt; insert(P&amp;&amp; x);
template &lt;class P&gt; <del>pair&lt;</del>iterator<del>, bool&gt;</del> insert(const_iterator position, P&amp;&amp; x);
</pre><blockquote>
1 <em>Requires</em>: <del><tt>P</tt> shall be convertible to </del><tt>value_type</tt><ins> is constructible 
from <tt>std::forward&lt;P&gt;(x)</tt>.</ins>.
<p/>
<del>If <tt>P</tt> is instantiated as a reference type, then the argument <tt>x</tt> is copied from. Otherwise <tt>x</tt> is considered
to be an rvalue as it is converted to <tt>value_type</tt> and inserted into the map. Specifically, in
such cases <tt>CopyConstructible</tt> is not required of <tt>key_type</tt> or <tt>mapped_type</tt> unless the conversion
from <tt>P</tt> specifically requires it (e.g., if <tt>P</tt> is a <tt>tuple&lt;const key_type, mapped_type&gt;</tt>, then <tt>key_type</tt>
must be <tt>CopyConstructible</tt>). The signature taking <tt>InputIterator</tt> parameters does not require
<tt>CopyConstructible</tt> of either <tt>key_type</tt> or <tt>mapped_type</tt> if the dereferenced <tt>InputIterator</tt> returns a
non-const rvalue <tt>pair&lt;key_type,mapped_type&gt;</tt>. Otherwise <tt>CopyConstructible</tt> is required for both
<tt>key_type</tt> and <tt>mapped_type</tt>.</del><br/>
<ins>? <em>Effects</em>: Inserts <tt>x</tt> converted to <tt>value_type</tt> if and only if there is no element in the container with
key equivalent to the key of <tt>value_type(x)</tt>. For the second form, the iterator <tt>position</tt> is a hint pointing to where the
search should start.</ins>
<p/>
<ins>? <em>Returns</em>: For the first form, the <tt>bool</tt> component of the returned <tt>pair</tt> object indicates whether the 
insertion took place and the iterator component - or for the second form the returned iterator - points to the element with key equivalent 
to the key of <tt>value_type(x)</tt>.</ins>
<p/>
<ins>? <em>Complexity</em>: Logarithmic in general, but amortized constant if <tt>x</tt> is inserted right before <tt>position</tt>.</ins>
<p/>
<ins>? <em>Remarks</em>: These signatures shall not participate in overload resolution unless <tt>P</tt> 
is implicitly convertible to <tt>value_type</tt>.</ins>
</blockquote></blockquote>
</li>
<li>Change 23.6.2.2 [multimap.modifiers] around p. 1 as indicated:
<blockquote><pre>
template &lt;class P&gt; iterator insert(P&amp;&amp; x);
template &lt;class P&gt; iterator insert(const_iterator position, P&amp;&amp; x);
</pre><blockquote>
1 <em>Requires</em>: <del><tt>P</tt> shall be convertible to </del><tt>value_type</tt> <ins>is constructible from 
<tt>std::forward&lt;P&gt;(x)</tt></ins>.
<p/>
<del>If <tt>P</tt> is instantiated as a reference type, then the argument <tt>x</tt> is copied from. Otherwise 
<tt>x</tt> is considered to be an rvalue as it is converted to <tt>value_type</tt> and inserted into the map. 
Specifically, in such cases <tt>CopyConstructible</tt> is not required of <tt>key_type</tt> or <tt>mapped_type</tt> 
unless the conversion from <tt>P</tt> specifically requires it (e.g., if <tt>P</tt> is a <tt>tuple&lt;const key_type, mapped_type&gt;</tt>, 
then <tt>key_type</tt> must be <tt>CopyConstructible</tt>). The signature taking <tt>InputIterator</tt> parameters 
does not require <tt>CopyConstructible</tt> of either <tt>key_type</tt> or <tt>mapped_type</tt> if the dereferenced 
<tt>InputIterator</tt> returns a non-const rvalue <tt>pair&lt;key_type, mapped_type&gt;</tt>. Otherwise <tt>CopyConstructible</tt> 
is required for both <tt>key_type</tt> and <tt>mapped_type</tt>.</del><br/>
<ins>? <em>Effects</em>: Inserts <tt>x</tt> converted to <tt>value_type</tt>. For the second form, the iterator <tt>position</tt> 
is a hint pointing to where the search should start.</ins>
<p/>
<ins>? <em>Returns</em>: An iterator that points to the element with key equivalent to the key of <tt>value_type(x)</tt>.</ins>
<p/>
<ins>? <em>Complexity</em>: Logarithmic in general, but amortized constant if <tt>x</tt> is inserted right before <tt>position</tt>.</ins>
<p/>
<ins>? <em>Remarks</em>: These signatures shall not participate in overload resolution unless <tt>P</tt> 
is implicitly convertible to <tt>value_type</tt>.</ins>
</blockquote></blockquote>
</li>
</ol>
</p>

<p><i>[
2010 Batavia:
]</i></p>


<p>
We need <tt>is_convertible</tt>, not <tt>is_constructible</tt>, both in ordered and unordered containers. 
</p>



<p><b>Proposed resolution:</b></p>
<ol>
<li>Add a new Remarks element after 23.6.1.3 [map.modifiers] p. 1:
<blockquote><pre>
template &lt;class P&gt; pair&lt;iterator, bool&gt; insert(P&amp;&amp; x);
template &lt;class P&gt; pair&lt;iterator, bool&gt; insert(const_iterator position, P&amp;&amp; x);
</pre><blockquote>
1 <em>Requires</em>: <tt>P</tt> shall be convertible to <tt>value_type</tt>.
<p/>
If <tt>P</tt> is instantiated as a reference type, then the argument <tt>x</tt> is copied from. Otherwise <tt>x</tt> is considered
to be an rvalue as it is converted to <tt>value_type</tt> and inserted into the map. Specifically, in
such cases <tt>CopyConstructible</tt> is not required of <tt>key_type</tt> or <tt>mapped_type</tt> unless the conversion
from <tt>P</tt> specifically requires it (e.g., if <tt>P</tt> is a <tt>tuple&lt;const key_type, mapped_type&gt;</tt>, then <tt>key_type</tt>
must be <tt>CopyConstructible</tt>). The signature taking <tt>InputIterator</tt> parameters does not require
<tt>CopyConstructible</tt> of either <tt>key_type</tt> or <tt>mapped_type</tt> if the dereferenced <tt>InputIterator</tt> returns a
non-const rvalue <tt>pair&lt;key_type,mapped_type&gt;</tt>. Otherwise <tt>CopyConstructible</tt> is required for both
<tt>key_type</tt> and <tt>mapped_type</tt>.
<p/>
<ins>? <em>Remarks</em>: These signatures shall not participate in overload resolution unless <tt>P</tt> 
is implicitly convertible to <tt>value_type</tt>.</ins>
</blockquote></blockquote>
</li>
<li>Change 23.6.2.2 [multimap.modifiers] around p. 1 as indicated:
<blockquote><pre>
template &lt;class P&gt; iterator insert(P&amp;&amp; x);
template &lt;class P&gt; iterator insert(const_iterator position, P&amp;&amp; x);
</pre><blockquote>
1 <em>Requires</em>: <tt>P</tt> shall be convertible to <tt>value_type</tt>.
<p/>
If <tt>P</tt> is instantiated as a reference type, then the argument <tt>x</tt> is copied from. Otherwise 
<tt>x</tt> is considered to be an rvalue as it is converted to <tt>value_type</tt> and inserted into the map. 
Specifically, in such cases <tt>CopyConstructible</tt> is not required of <tt>key_type</tt> or <tt>mapped_type</tt> 
unless the conversion from <tt>P</tt> specifically requires it (e.g., if <tt>P</tt> is a <tt>tuple&lt;const key_type, mapped_type&gt;</tt>, 
then <tt>key_type</tt> must be <tt>CopyConstructible</tt>). The signature taking <tt>InputIterator</tt> parameters 
does not require <tt>CopyConstructible</tt> of either <tt>key_type</tt> or <tt>mapped_type</tt> if the dereferenced 
<tt>InputIterator</tt> returns a non-const rvalue <tt>pair&lt;key_type, mapped_type&gt;</tt>. Otherwise <tt>CopyConstructible</tt> 
is required for both <tt>key_type</tt> and <tt>mapped_type</tt>.
<p/>
<ins>? <em>Remarks</em>: These signatures shall not participate in overload resolution unless <tt>P</tt> 
is implicitly convertible to <tt>value_type</tt>.</ins>
</blockquote></blockquote>
</li>
</ol>





<hr>
<h3><a name="2008"></a>2008. Conflicting Error Conditions for <tt>packaged_task::operator()</tt></h3>
<p><b>Section:</b> 30.6.10.1 [futures.task.members] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2010-06-21 <b>Last modified:</b> 2010-11-07</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures.task.members">active issues</a> in [futures.task.members].</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.task.members">issues</a> in [futures.task.members].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The Throws clause for <tt>packaged_task::operator()</tt> says that it throws "a
<tt>future_error</tt> exception object if there is no associated asynchronous
state or the stored task has already been invoked." However, the Error
Conditions clause does not define an error condition when the stored task has
already been invoked, only when the associated state is already ready (i.e. the
invocation has completed).
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change the first bullet item in 30.6.10.1 [futures.task.members] /22:
</p>

<blockquote><pre>
void operator()(ArgTypes... args);
</pre>
<blockquote>
<p>
20 ...
</p>
<p>
21 ...
</p>
<p>
22 <i>Error conditions:</i>
</p>
<ul>
<li>
<tt>promise_already_satisfied</tt> if <del>the associated asynchronous state is
already ready</del> <ins><tt>operator()</tt> has already been called</ins>.
</li>
<li>
<tt>no_state</tt> if <tt>*this</tt> has no associated asynchronous state.
</li>
</ul>
</blockquote>
</blockquote>





<hr>
<h3><a name="2009"></a>2009. Reporting out-of-bound values on numeric string conversions</h3>
<p><b>Section:</b> 21.5 [string.conversions] <b>Status:</b> <a href="lwg-active.html#Review">Review</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2010-07-19 <b>Last modified:</b> 2010-11-13</p>
<p><b>View all other</b> <a href="lwg-index.html#string.conversions">issues</a> in [string.conversions].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Review">Review</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The functions (<tt>w</tt>)<tt>stoi</tt> and (<tt>w</tt>)<tt>stof</tt>
are specified in terms of calling C library APIs for potentially wider
types.  The integer and floating-point versions have subtly different
behaviour when reading values that are too large to convert.  The
floating point case will throw <tt>out_of_bound</tt> if the read value
is too large to convert to the wider type used in the implementation,
but behaviour is undefined if the converted value cannot narrow to a
float.  The integer case will throw <tt>out_of_bounds</tt> if the
converted value cannot be represented in the narrower type, but throws
<tt>invalid_argument</tt>, rather than <tt>out_of_bounds</tt>, if the
conversion to the wider type fails due to overflow.
</p>

<p>
Suggest that the Throws clause for both specifications should be
consistent, supporting the same set of fail-modes with the matching set
of exceptions.
</p>



<p><b>Proposed resolution:</b></p>
<p>
21.5p3 [string.conversions]
</p>

<blockquote><pre>
int stoi(const string&amp; str, size_t *idx = 0, int base = 10);
long stol(const string&amp; str, size_t *idx = 0, int base = 10);
unsigned long stoul(const string&amp; str, size_t *idx = 0, int base = 10);
long long stoll(const string&amp; str, size_t *idx = 0, int base = 10);
unsigned long long stoull(const string&amp; str, size_t *idx = 0, int base = 10);
</pre>

<blockquote>
<p>
...
</p>
<p>
3 <i>Throws:</i> <tt>invalid_argument</tt> if <tt>strtol</tt>,
<tt>strtoul</tt>, <tt>strtoll</tt>, or <tt>strtoull</tt> reports that no
conversion could be performed. Throws <tt>out_of_range</tt> if
<ins><tt>strtol</tt>, <tt>strtoul</tt>, <tt>strtoll</tt> or
<tt>strtoull</tt> sets <tt>errno</tt> to <tt>ERANGE</tt>, or if</ins>
the converted value is outside the range of representable values for the
return type.
</p>
</blockquote>
</blockquote>

<p>
21.5p6 [string.conversions]
</p>

<blockquote><pre>
float stof(const string&amp; str, size_t *idx = 0);
double stod(const string&amp; str, size_t *idx = 0);
long double stold(const string&amp; str, size_t *idx = 0);
</pre>

<blockquote>
<p>
...
</p>
<p>
6 <i>Throws:</i> <tt>invalid_argument</tt> if <tt>strtod</tt> or
<tt>strtold</tt> reports that no conversion could be performed. Throws
<tt>out_of_range</tt> if <tt>strtod</tt> or <tt>strtold</tt> sets
<tt>errno</tt> to <tt>ERANGE</tt> <ins> or if the converted value is
outside the range of representable values for the return type</ins>.
</p>
</blockquote>
</blockquote>






<hr>
<h3><a name="2010"></a>2010. <tt>is_* traits</tt> for binding operations can't be meaningfully specialized</h3>
<p><b>Section:</b> 20.8.10.1.1 [func.bind.isbind] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> Sean Hunt <b>Opened:</b> 2010-07-19 <b>Last modified:</b> 2010-11-16</p>
<p><b>View all other</b> <a href="lwg-index.html#func.bind.isbind">issues</a> in [func.bind.isbind].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.8.10.1.1 [func.bind.isbind] says for <tt>is_bind_expression</tt>:
</p>

<blockquote>
Users may specialize this template to indicate that a type should be
treated as a subexpression in a <tt>bind</tt> call.
</blockquote>

<p>
But it also says:
</p>

<blockquote>
If <tt>T</tt> is a type returned from <tt>bind</tt>,
<tt>is_bind_expression&lt;T&gt;</tt> shall be publicly derived from
<tt>integral_constant&lt;bool, true&gt;</tt>, otherwise from
<tt>integral_constant&lt;bool, false&gt;</tt>.
</blockquote>

<p>
This means that while the user is free to specialize, any specialization
would have to be <tt>false</tt> to avoid violating the second
requirement. A similar problem exists for <tt>is_placeholder</tt>.
</p>


<p><i>[
2010 Batavia (post meeting session)
]</i></p>

<p>
Alisdair recognises this is clearly a bug introduced by some wording he
wrote, the sole purpose of this metafunction is as a customization point
for users to write their own <tt>bind</tt>-expression types that participate
in the standard library <tt>bind</tt> protocol.  The consensus was that this
should be fixed in Madrid, moved to Open.
</p>

<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2011"></a>2011. unexpected output required of strings</h3>
<p><b>Section:</b> 21.4.8.9 [string.io] <b>Status:</b> <a href="lwg-active.html#Open">Open</a>
 <b>Submitter:</b> James Kanze <b>Opened:</b> 2010-07-23 <b>Last modified:</b> 2010-11-16</p>
<p><b>View all other</b> <a href="lwg-index.html#string.io">issues</a> in [string.io].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Open">Open</a> status.</p>
<p><b>Discussion:</b></p>
<p>
What should the following code output? 
</p>

<blockquote><pre>
#include &lt;string>
#include &lt;iostream>
#include &lt;iomanip>

int 
main() 
{ 
   std::string test("0X1Y2Z"); 
   std::cout.fill('*'); 
   std::cout.setf(std::ios::internal, std::ios::adjustfield); 
   std::cout &lt;&lt; std::setw(8) &lt;&lt; test &lt;&lt; std::endl; 
} 
</pre></blockquote>

<p>
I would expect "<tt>**0X1Y2Z</tt>", and this is what the compilers I have access
to (VC++, g++ and Sun CC) do.  But according to the standard, it should be
"<tt>0X**1Y2Z</tt>":
</p>

<p>
21.4.8.9 [string.io]/5: 
</p>

<blockquote><pre>
template&lt;class charT, class traits, class Allocator&gt;
  basic_ostream&lt;charT, traits&gt;&amp;
    operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os, const basic_string&lt;charT,traits,Allocator&gt;&amp; str);
</pre><blockquote>
<i>Effects:</i> Behaves as a formatted output function (27.7.2.6.1 [ostream.formatted.reqmts]). After constructing a <tt>sentry</tt>
object, if this object returns <tt>true</tt> when converted to a value of type
<tt>bool</tt>, determines padding as described in 22.4.2.2.2 [facet.num.put.virtuals], then inserts the resulting sequence of
characters seq as if by calling <tt>os.rdbuf()-&gt;sputn(seq, n)</tt>, where
<tt>n</tt> is the larger of <tt>os.width()</tt> and <tt>str.size()</tt>; then
calls <tt>os.width(0)</tt>.
</blockquote>
</blockquote>

<p>
22.4.2.2.2 [facet.num.put.virtuals]/5: 
</p>

<blockquote>
<p>
[...] 
</p>

<p>
<b>Stage 3:</b> A local variable is initialized as
</p>

<blockquote><pre>
fmtflags adjustfield= (flags &amp; (ios_base::adjustfield));
</pre></blockquote>

<p>
The location of any padding is determined according to Table 88. 
</p>

<p>
If <tt>str.width()</tt> is nonzero and the number of <tt>charT</tt>'s in the
sequence after stage 2 is less than <tt>str.width()</tt>, then enough fill
characters are added to the sequence at the position indicated for padding to
bring the length of the sequence to <tt>str.width()</tt>. <tt>str.width(0)</tt>
is called.
</p>

<table border="1">
<caption>Table 88 &mdash; Fill padding</caption>
<tr>
<th>State</th>
<th>Location</th>
</tr>

<tr>
<td><tt>adjustfield == ios_base::left</tt></td>
<td>pad after</td>
</tr>

<tr>
<td><tt>adjustfield == ios_base::right</tt></td>
<td>pad before</td>
</tr>

<tr>
<td><tt>adjustfield == internal</tt> and a sign occurs in the representation</td>
<td>pad after the sign</td>
</tr>

<tr>
<td><tt>adjustfield == internal</tt> and representation after stage 1 began with 0x or 0X</td>
<td>pad after x or X</td>
</tr>

<tr>
<td><i>otherwise</i></td>
<td>pad before</td>
</tr>
</table>

</blockquote>

<p>
Although it's not 100% clear what "the sequence after stage 2" should mean here,
when there is no stage 2, the only reasonable assumption is that it is the
contents of the string being output.  In the above code, the string being output
is "<tt>0X1Y2Z</tt>", which starts with "<tt>0X</tt>", so the padding should be
inserted "after x or X", and not before the string. I believe that this is a
defect in the standard, and not in the three compilers I tried.
</p>




<p><i>[
2010 Batavia (post meeting session)
]</i></p>

<p>
Consensus that all known implementations are consistent, and disagree with the
standard.  Preference is to fix the standard before implementations start trying
to conform to the current spec, as the current implementations have the preferred
form.  Howard volunteered to drught for Madrid, move to Open.
</p>

<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2012"></a>2012. Associative maps should insert <tt>pair</tt>, not <tt>tuple</tt></h3>
<p><b>Section:</b> 23.6 [associative] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Paolo Carlini <b>Opened:</b> 2010-10-29 <b>Last modified:</b> 2010-11-07</p>
<p><b>View all other</b> <a href="lwg-index.html#associative">issues</a> in [associative].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I'm seeing something strange in the paragraphs 23.6.1.3 [map.modifiers] and 23.6.2.2 [multimap.modifiers]:
they both talk about <tt>tuple&lt;const key_type, mapped_type&gt;</tt> but I think they
should be talking about <tt>pair&lt;const key_type, mapped_type&gt;</tt> because, among
other reasons, a <tt>tuple</tt> is not convertible to a <tt>pair</tt>. If I replace <tt>tuple</tt>
with <tt>pair</tt> everything makes sense to me.

The proposed resolution is obvious. 
</p>

<p><i>[
2010-11-07 Daniel comments
]</i></p>


<p>
This is by far not the only necessary fix within both sub-clauses. For details see the 2010-10-29 comment in 
<a href="lwg-active.html#2005">2005</a>.
</p>


<p><b>Proposed resolution:</b></p>
Apply the resolution proposed by the 2010-10-29 comment in <a href="lwg-active.html#2005">2005</a>.





<hr>
<h3><a name="2013"></a>2013. Do library implementers have the freedom to add <tt>constexpr</tt>?</h3>
<p><b>Section:</b> 17.6.4.6 [constexpr.functions] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2010-11-12 <b>Last modified:</b> 2010-11-13</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
<p>Suppose that a particular function is not tagged as constexpr in the standard,
but that, in some particular implementation, it is possible to write it within
the constexpr constraints. If an implementer tags such a function as constexpr,
is that a violation of the standard or is it a conforming extension?</p>

<p>There are two questions to consider. First, is this allowed under the
as-if rule? Second, if it does not fall under as-if, is there
(and should there be) any special license granted to implementers
to do this anyway, sort of the way we allow elision of copy constructors
even though it is detectable by users?</p>

<p>I believe that this does not fall under "as-if", so implementers
probably don't have that freedom today. I suggest changing the WP
to grant it. Even if we decide otherwise, however, I suggest that
we make it explicit.</p>



<p><b>Proposed resolution:</b></p>
<p><i>In 17.6.4.6 [constexpr.functions], change paragraph 1 to:</i></p>

<blockquote>
<ins>This standard explicitly requires that certain standard library functions
are <tt>constexpr</tt> [dcl.constexpr].
Additionally, an implementation may declare any function to be <tt>constexpr</tt>
if that function's definition satisfies the necessary constraints.</ins>
Within any header that provides any non-defining declarations of <tt>constexpr</tt>
functions or constructors an implementation shall provide corresponding definitions. 
</blockquote>






<hr>
<h3><a name="2014"></a>2014. More restrictions on macro names</h3>
<p><b>Section:</b> 17.6.3.3.1 [macro.names] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Alberto Ganesh Barbati <b>Opened:</b> 2010-11-16 <b>Last modified:</b> 2010-11-17</p>
<p><b>View all other</b> <a href="lwg-index.html#macro.names">issues</a> in [macro.names].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
A program is currently forbidden to use keywords as macro names. This restriction should be strengthened to include all identifiers 
that could be used by the library as attribute-tokens (for example <tt>noreturn</tt>, which is used by header <tt>&lt;cstdlib&gt;</tt>) 
and the special identifiers introduced recently for override control (these are not currently used in the library public interface,
but could potentially be used by the implementation or in future revisions of the library).



<p><b>Proposed resolution:</b></p>
<p>Modify 17.6.3.3.1 [macro.names] paragraph 2 as follows:</p>

<blockquote>
A translation unit shall not <tt>#define</tt> or <tt>#undef</tt> names lexically identical to keywords<ins>, to the identifiers 
listed in Table X [Identifiers with special meaning] or to the <i>attribute-tokens</i> described in clause 7.6 [dcl.attr]</ins>.
</blockquote>






<hr>
<h3><a name="2015"></a>2015. Incorrect pre-conditions for some type traits</h3>
<p><b>Section:</b> 20.7.4 [meta.unary] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Nikolay Ivchenkov <b>Opened:</b> 2010-11-08 <b>Last modified:</b> 2010-11-17</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.unary">issues</a> in [meta.unary].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
According to N3126&nbsp;&#x2011;&nbsp;3.9/9,

<p>&quot;Scalar types, trivial class types (Clause 9), arrays of such types
and <i>cv</i>&#x2011;qualified versions of these types (3.9.3) are collectively
called <i>trivial types</i>.&quot;</p>

<p>Thus, an array (possibly of unknown bound) can be trivial type, non&#x2011;trivial type, 
or an array type whose triviality cannot be determined because its element type is incomplete.</p>

<p>According to N3126&nbsp;&#x2011;&nbsp;Table 45, preconditions for <tt>std::is_trivial</tt> are
defined as follows:</p>

<p>&quot;<tt>T</tt> shall be a complete type, (possibly <i>cv</i>-qualified) <tt>void</tt>, 
or an array of unknown bound&quot;</p>

<p>It seems that &quot;an array of unknown bound&quot; should be changed to &quot;an
array of unknown bound of a complete element type&quot;. Preconditions for
some other templates (e.g., <tt>std::is_trivially_copyable</tt>,
<tt>std::is_standard_layout</tt>, <tt>std::is_pod</tt>, and <tt>std::is_literal_type</tt>) should
be changed similarly.</p>

<p>On the other hand, some preconditions look too restrictive. For
example, <tt>std::is_empty</tt> and <tt>std::is_polymorphic</tt> might accept any
incomplete non-class type.</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2016"></a>2016. <tt>Allocators</tt> must be no-throw <i>swappable</i></h3>
<p><b>Section:</b> 20.2.5 [allocator.requirements] <b>Status:</b> <a href="lwg-active.html#New">New</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2010-11-17 <b>Last modified:</b> 2010-11-18</p>
<p><b>View all other</b> <a href="lwg-index.html#allocator.requirements">issues</a> in [allocator.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#New">New</a> status.</p>
<p><b>Discussion:</b></p>
During the Batavia meeting it turned out that there is a definition
hole for types satisfying the <tt>Allocators</tt> requirements: The problem
became obvious when it was discussed whether all <tt>swap</tt> functions 
of <tt>Containers</tt> with internal data handles can be safely tagged
with <tt>noexcept</tt> or not. While it is correct that the implicit
<tt>swap</tt> function of an allocator is required to be a no-throw
operation (because move/copy-constructors and assignment operators are
required to be <tt>noexcept</tt> functions), there are no such requirements
for specialized <tt>swap</tt> overloads for a particular allocator.

But this requirement is essential because the <tt>Containers</tt> are
required to support <i>swappable</i> <tt>Allocators</tt>, when the value
<tt>allocator_traits&lt;&gt;::propagate_on_container_swap</tt> evaluates
to <tt>true</tt>.


<p><b>Proposed resolution:</b></p>





</body>
</html>
