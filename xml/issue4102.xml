<?xml version='1.0' encoding='utf-8' standalone='no'?>
<!DOCTYPE issue SYSTEM "lwg-issue.dtd">

<issue num="4102" status="New">
<title>`string_view(Iter, Iter)` constructor breaks existing code</title>
<section><sref ref="[string.view.cons]"/></section>
<submitter>Derek Zhang</submitter>
<date>14 May 2024</date>
<priority>99</priority>

<discussion>
<p>
As a result of the new constructor added by <paper num="P1391"/>,
this stopped working in C++20: 
</p>
<pre><code>
void fun(string_view);
void fun(vector&lt;string_view&gt;);
fun({"a", "b"});
</code></pre>
<p>
Previously the first `fun` wasn't viable, so it constructed a
<code>vector&lt;string_view&gt;</code>
of two elements using its initializer-list constructor
and then called the second `fun`.
Now `{"a", "b"}` could also be a call to the new `string_view(Iter, Iter)`,
so it's ambiguous and fails to compile.
</p>
<p>
The following case is arguably worse as it doesn't become ill-formed in C++20,
it still compiles but now has undefined behaviour:
</p>
<pre><code>
fun({{"a", "b"}});
</code></pre>
<p>
Previously the first `fun` wasn't viable, so this constructed a
<code>vector&lt;string_view&gt;</code> of two elements
(via somewhat bizarre syntax, but using the same initializer-list constructor
as above).
Now it constructs a `vector` from an `initializer_list` with <em>one</em>
element, where that element is constructed from the two `const char*`
using `string_view(Iter, Iter)`.
But those two pointers are unrelated and do not form a valid range,
so this violates the constructor's precondition and has undefined behaviour.
If you're lucky it crashes at runtime when trying to reach `"b"` from `"a"`,
but it could also form a `string_view` that reads arbitrary secrets from the
memory between the two pointers.
</p>
<note>Jonathan comments</note>
<p>
At the very least, we should have an Annex C entry documenting the change.
Making the new `string_view(Iter, Iter)` constructor `explicit` would prevent
the runtime behaviour change for the second example,
but GCC thinks the first example would still be ambiguous
(it seems to depend on how list-initialization handles explicit constructors,
which has implementation divergence).
</p>
</discussion>

<resolution>
<p>
</p>
</resolution>

</issue>
