<?xml version='1.0' encoding='utf-8' standalone='no'?>
<!DOCTYPE issue SYSTEM "lwg-issue.dtd">

<issue num="2963" status="New">
<title>Algorithms with underspecified iterator requirements</title>
<section><sref ref="[algorithms]"/><sref ref="[numerics]"/></section>
<submitter>Ga&scaron;per A&zcaron;man</submitter>
<date>10 May 2017</date>
<priority>99</priority>

<discussion>
<p>
While researching whether the proposed resolution of Iterators of Containers of move-only types do not model <tt>InputIterator</tt>
(LWG <iref ref="2962"/>), I came across several algorithms that underspecify their requirements, mostly with regard to some associated type of the iterator type they operate on. A list can be found below.
<p/>
The list of algorithms with underspecified requirements from <tt>&lt;algorithm&gt;</tt> and <tt>&lt;numeric&gt;</tt> follows.
<p/>
With the advent of concepts, these algorithms will need better specifications if we are ever hoping to be allowed to overload based on them. I want this issue to bring the standard algorithms closer to having their concept requirements directly transcribable to library annotations.
<p/>
Suggested resolution:
</p>
<ol>
<li>
<p><tt>copy</tt>, <tt>copy_if</tt>, <tt>copy_n</tt>, <tt>copy_backward</tt></p>
<p>Add to description: <tt>reference</tt> of <tt>first</tt> must be <tt>CopyAssignable</tt> to <tt>*result</tt>.</p>
</li>
<li>
<p><tt>move</tt>, <tt>move_if</tt>, <tt>move_backward</tt></p>
<p>Add to description: <tt>reference</tt> of <tt>first</tt> must be <tt>CopyAssignable</tt> to <tt>*result</tt>.</p>
</li>
<li>
<p><tt>transform</tt></p>
<p>Add to description: <tt>OutputIterator</tt> must be writable with <tt>op</tt> or <tt>binary_op</tt>'s return type.</p>
</li>
<li>
<p><tt>rotate_copy</tt></p>
<p>Add to description: <tt>reference</tt> of <tt>InputIterator</tt> must be writable to <tt>OutputIterator</tt>.</p>
</li>
<li>
<p><tt>merge</tt></p>
<p>Add to description: <tt>reference</tt> of both <tt>InputIterator1</tt> and <tt>InputIterator2</tt> must be writable 
to <tt>OutputIterator</tt>.</p>
</li>
<li>
<p><tt>set_union</tt>, <tt>set_intersection</tt>, <tt>set_difference</tt>, <tt>set_symmetric_difference</tt></p>
<p>Add to description: <tt>reference</tt> of both <tt>InputIterator1</tt> and <tt>InputIterator2</tt> must be writable to 
<tt>OutputIterator</tt>.</p>
</li>
<li>
<p><tt>partial_sum</tt></p>
<p>
<tt>acc</tt> is not defined.
<p/>
Change description: <tt>acc</tt>, a variable of <tt>InputIterator</tt>'s value type, shall be constructible
</p>
</li>
<li>
<p><tt>exclusive_scan</tt>, <tt>inclusive_scan</tt></p>
<p>Forgets to specify that <tt>OutputIterator</tt> must be assignable from the result type of <tt>BinaryOperation</tt>. Also, 
forgets to specify the traversal characteristic of <tt>OutputIterator</tt>.</p>
</li>
<li>
<p><tt>adjacent_difference</tt></p>
<p>
<tt>acc</tt> is not defined.
<p/>
Change description: <tt>acc</tt>, a variable of <tt>InputIterator</tt>'s value type, shall be <tt>MoveAssignable</tt> and shall be 
<tt>constructible</tt> from the type of <tt>*first</tt>.
</p>
</li>
<li>
<p><tt>iota</tt></p>
<p>
<tt>iota</tt> is mis-specified. Since the expression we need to support is <tt>*first = value</tt>: <tt>*first</tt> 
is required to be of type <tt>InputIterator::reference</tt>, and value is an lvalue of type <tt>T</tt>. The current 
specification allows calling iota with a non-mutable iterator. More-over this description needn't change if we ever 
get smart references.
<p/>
<del><tt>T</tt> shall be convertible to <tt>ForwardIterator</tt>'s value type</del><ins><tt>ForwardIterator</tt>'s 
<tt>reference</tt> type shall be <tt>CopyAssignable</tt> from <tt>T</tt></ins>.
</p>
</li>
</ol>
</discussion>

<resolution>
</resolution>

</issue>
