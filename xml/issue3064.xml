<?xml version='1.0' encoding='utf-8' standalone='no'?>
<!DOCTYPE issue SYSTEM "lwg-issue.dtd">

<issue num="3064" status="New">
<title>How do uninitialized memory algorithms obtain pointer without undefined behavior?</title>
<section><sref ref="[specialized.algorithms]"/></section>
<submitter>Alisdair Meredith</submitter>
<date>12 Feb 2018</date>
<priority>99</priority>

<discussion>
<p>
A typical specification of the algorithms for initializing raw memory in <tt>&lt;memory&gt;</tt> looks like:
</p>
<blockquote>
<p>
<i>Effects:</i> Equivalent to:
</p>
<blockquote><pre>
for (; first != last; ++first)
  ::new (static_cast&lt;void*&gt;(addressof(*first)))
    typename iterator_traits&lt;ForwardIterator&gt;::value_type;
</pre></blockquote>
</blockquote>
<p>
However, this hides a nasty question:
<p/>
How do we bind a reference to an uninitialized object when dereferencing our iterator,
so that <tt>static_cast&lt;void*&gt;(addressor(*first))</tt> does not trigger undefined behavior on
the call to <tt>*first</tt>?
<p/>
When pointers are the only iterators we cared about, we could simply cast the iterator
value to <tt>void*</tt> without dereferencing. I don't see how to implement this spec safely
without introducing another customization point for iterators that performs the same
function as casting a pointer to <tt>void*</tt> in order to get the address of the element.
</p>
</discussion>

<resolution>
</resolution>

</issue>
