<?xml version='1.0' encoding='utf-8' standalone='no'?>
<!DOCTYPE issue SYSTEM "lwg-issue.dtd">

<issue num="3099" status="New">
<title><tt>is_assignable&lt;Incomplete&amp;, Incomplete&amp;&gt;</tt></title>
<section><sref ref="[meta.type.synop]"/></section>
<submitter>Casey Carter</submitter>
<date>10 Apr 2018</date>
<priority>99</priority>

<discussion>
<p>
LWG <iref ref="2939"/> suggests that the the preconditions of the type traits need reevaluation.
This issue focuses specifically on <tt>is_assignable</tt> and, by extension, its variants:
<ul>
<li><tt>is_copy_assignable&lt;T&gt;</tt>, equivalent to <tt>is_assignable&lt;T&amp;, const T&amp;&gt;</tt>,
</li>
<li><tt>is_move_assignable&lt;T&gt;</tt>, equivalent to <tt>is_assignable&lt;T&amp;, T&gt;</tt>,
</li>
<li><tt>is_trivially_assignable&lt;T, U&gt;</tt>, equivalent to <tt>is_assignable&lt;T, U&gt; &amp;&amp;
  /* magic */</tt>,
</li>
<li><tt>is_trivially_copy_assignable&lt;T&gt;</tt>, equivalent to <tt>is_assignable&lt;T&amp;, const T&amp;&gt; &amp;&amp;
  /* magic */</tt>,
</li>
<li><tt>is_trivially_move_assignable&lt;T&gt;</tt>, equivalent to <tt>is_assignable&lt;T&amp;, T&gt; &amp;&amp;
  /* magic */</tt>,
</li>
<li><tt>is_nothrow_assignable&lt;T, U&gt;</tt>, equivalent to <tt>is_assignable&lt;T, U&gt; &amp;&amp;
    noexcept(declval&lt;T&gt;() = declval&lt;U&gt;())</tt>,
</li>
<li><tt>is_nothrow_copy_assignable&lt;T&gt;</tt>, equivalent to <tt>is_assignable&lt;T&amp;, const T&amp;&gt; &amp;&amp;
    noexcept(declval&lt;T&amp;&gt;() = declval&lt;const T&amp;&gt;())</tt>,
</li>
<li><tt>is_nothrow_move_assignable&lt;T&gt;</tt>, equivalent to <tt>is_assignable&lt;T&amp;, T&gt; &amp;&amp;
    noexcept(declval&lt;T&amp;&gt;() = declval&lt;T&gt;())</tt>, and
</li>
</ul>
</p>
<p>
Firstly, we note a discrepancy: <tt>is_copy_assignable&lt;T&gt;</tt> requires <tt>T</tt> to be a complete type, but the
equivalent form <tt>is_assignable&lt;T&amp;, const T&amp;&gt;</tt> <em>does not</em>. The requirement for
<tt>is_copy_assignable&lt;T&gt;</tt> seems sensible, since there's no way to determine whether or not the assignment
<tt>declval&lt;T&amp;&gt;() = declval&lt;const T&amp;&gt;()</tt> is well-formed when <tt>T</tt> is incomplete.
It seems that the same argument should apply to all of the above "assignable" traits, and that they must require that
the referent type is complete when given a reference type parameter to be implementable.
</p>
<p>
LWG <iref ref="2729"/> constrained the copy and move assignment operators of <tt>pair</tt> and <tt>tuple</tt> to
participate in overload resolution only when all field types are copy or move assignable. These constraints interact
with the proposed fix to the preconditions of the assignable traits since both <tt>pair</tt> and <tt>tuple</tt> support
members of reference type. If we agree that (1) the assignable traits aren't implementable without the stronger
precondition, and (2) it's necessary to check the constraints at class instantiation time to constrain the assignments
(which is the case for an implementation that does not support Concepts, or wants to provide conditionally trivial
special member functions), then <tt>pair&lt;F, S&gt;</tt> (respectively <tt>tuple&lt;Ts...&gt;</tt>) must require that
<tt>remove_cvref_t&lt;F&gt;</tt> and <tt>remove_cvref_t&lt;S&gt;</tt> (respectively <tt>remove_cvref_t&lt;Ts&gt;...</tt>)
are complete types.
</p>
</discussion>

<resolution>
<p>This wording is relative to <a href="http://wg21.link/n4741">N4741</a>.</p>
<blockquote>
<ol>
<li><p>Add a new paragraph to <sref ref="[pairs.pair]"/> before paragraph 1:</p>
<blockquote>
<p><ins>-?- Both <tt>remove_cvref_t&lt;T1&gt;</tt> and <tt>remove_cvref_t&lt;T2&gt;</tt> shall be complete types.</ins></p>
<p>-1- Constructors and member functions of <tt>pair</tt> shall not throw exceptions [&hellip;]</p>
</blockquote>
</li>

<li><p>Add a new paragraph to <sref ref="[tuple.tuple]"/> after the class synopsis:</p>
<blockquote>
<p><ins>-?- All types in <tt>remove_cvref_t&lt;Types&gt;...</tt> shall be complete types.</ins></p>
</blockquote>
</li>

<li>In <sref ref="[meta.unary.prop]"/> Table 42, change the Precondition text for <tt>is_assignable</tt>,
<tt>is_trivially_assignable</tt>, and <tt>is_nothrow_assignable</tt> as follows:
<blockquote>
<ins><tt>remove_cvref_t&lt;</tt></ins><tt>T</tt><ins><tt>&gt;</tt></ins> and
<ins><tt>remove_cvref_t&lt;</tt></ins><tt>U</tt><ins><tt>&gt;</tt></ins> shall be complete types, <del><i>cv</i></del>
<tt>void</tt>, or arrays of unknown bound.
</blockquote>
</li>

<li>In <sref ref="[meta.unary.prop]"/> Table 42, change the Precondition text for <tt>is_copy_assignable</tt>,
<tt>is_move_assignable</tt>, <tt>is_trivially_copy_assignable</tt>, <tt>is_trivially_move_assignable</tt>,
<tt>is_nothrow_copy_assignable</tt>, and <tt>is_nothrow_move_assignable</tt> as follows:
<blockquote>
<ins><tt>remove_cvref_t&lt;</tt></ins><tt>T</tt><ins><tt>&gt;</tt></ins> shall be a complete type, <del><i>cv</i></del>
<tt>void</tt>, or an array of unknown bound.
</blockquote>
</li>
</ol>
</blockquote>
</resolution>

</issue>
