<?xml version='1.0' encoding='utf-8' standalone='no'?>
<!DOCTYPE issue SYSTEM "lwg-issue.dtd">

<issue num="3645" status="New">
<title><tt>resize_and_overwrite</tt> is overspecified to call its callback with lvalues</title>
<section><sref ref="[string.capacity]"/></section>
<submitter>Arthur O'Dwyer</submitter>
<date>28 Nov 2021</date>
<priority>99</priority>

<discussion>
<p>
<sref ref="[string.capacity]"/> p7 says:
</p>
<ul>
<li><p>[Let] <tt><i>OP</i></tt> be the expression <tt>std::move(op)(p, n)</tt>.</p></li>
<li><p>[<i>Precondition:</i>] <tt><i>OP</i></tt> does not throw an exception or modify <tt>p</tt> or <tt>n</tt>.</p></li>
</ul>
<p>
Notice that <tt>p</tt> and <tt>n</tt> above are lvalue expressions.
<p/>
Discussed with Mark Zeren, Casey Carter, Jonathan Wakely. We observe that:
<p/>
A. This wording requires vendors to reject
</p>
<blockquote><pre>
s.resize_and_overwrite(100, [](char*&amp;&amp;, size_t&amp;&amp;){ return 0; });
</pre></blockquote>
<p>
which is surprising.
<p/>
B. This wording requires vendors to accept
</p>
<blockquote><pre>
s.resize_and_overwrite(100, [](char*&amp;, size_t&amp;){ return 0; });
</pre></blockquote>
<p>
which is even more surprising, and also threatens to allow the user to corrupt 
the internal state (which is why we need to specify the Precondition above).
<p/>
C. A user who writes
</p>
<blockquote><pre>
s.resize_and_overwrite(100, [](auto&amp;&amp;, auto&amp;&amp;){ return 0; });
</pre></blockquote>
<p>
can detect that they're being passed lvalues instead of rvalues. If we change 
the wording to permit implementations to pass either lvalues or rvalues (their choice), 
then this will be detectable by the user, so we don't want that if we can help it.
</p>
<ol style="list-style-type:none">
<li><p>X. We want to enable implementations to say <tt>move(op)(__p, __n)</tt> 
and then use <tt>__p</tt> and <tt>__n</tt>.</p></li>
<li><p>Y. We have one implementation which wants to say <tt>move(op)(data(), __n)</tt>, 
which is not currently allowed, but arguably should be.</p></li>
<li><p>Z. We have to do or say something about disallowing writes to any 
internal state to which <tt>Op</tt> might get a reference.</p></li>
</ol>
<p>
Given all of this, Mark and Arthur think that the simplest way out is to say that the 
arguments are prvalues. It prevents X, but fixes the surprises in A, B, Y, Z. We 
could do this in the Let bullets. Either like so:
</p>
<ul>
<li><p>[Let] <tt>p</tt> be a prvalue of type <tt>charT*</tt> &hellip;</p></li>
<li><p><tt>m</tt> be a prvalue of type <tt>size_type</tt> equal to <tt>n</tt>,</p></li>
<li><p><tt><i>OP</i></tt> be the expression <tt>std::move(op)(p, m)</tt>.</p></li>
</ul>
<p>
or (Arthur's preference) by specifying prvalues in the expression <tt><i>OP</i></tt> itself:
</p>
<ul>
<li><p>[Let] <tt><i>OP</i></tt> be the expression <tt>std::move(op)(auto(p), auto(n))</tt>.</p></li>
</ul>
<p>
No matter which specification approach we adopt, we can also simplify the Preconditions bullet to:
</p>
<ul>
<li><p>[<i>Precondition:</i>] <tt><i>OP</i></tt> does not throw an exception.</p></li>
</ul>
<p>
because once the user is receiving prvalue copies, it will no longer be physically possible for the 
user to modify the library's original variables <tt>p</tt> and <tt>n</tt>.
</p>
</discussion>

<resolution>
</resolution>

</issue>
