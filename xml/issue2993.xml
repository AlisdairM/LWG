<?xml version='1.0' encoding='utf-8' standalone='no'?>
<!DOCTYPE issue SYSTEM "lwg-issue.dtd">

<issue num="2993" status="New">
<title><tt>reference_wrapper&lt;T&gt;</tt> conversion from <tt>T&amp;&amp;</tt></title>
<section><sref ref="[refwrap]"/></section>
<submitter>Tim Song</submitter>
<date>28 Jun 2017</date>
<priority>99</priority>

<discussion>
<p>
<tt>reference_wrapper&lt;T&gt;</tt> has a deleted constructor taking <tt>T&amp;&amp;</tt> in order to
prevent accidentally wrapping an rvalue (which can otherwise happen with the 
<tt>reference_wrapper(T&amp;)</tt> constructor if <tt>T</tt> is a non-<tt>volatile</tt>
<tt>const</tt>-qualified type). Unfortunately, a deleted constructor can still
be used to form implicit conversion sequences, so the deleted <tt>T&amp;&amp;</tt>
constructor has the (presumably unintended) effect of creating an implicit conversion sequence from 
a <tt>T</tt> rvalue to a <tt>reference_wrapper&lt;T&gt;</tt>, even though such a conversion would be
ill-formed if actually used. This is visible in overload resolution:
</p>
<blockquote><pre>
void meow(std::reference_wrapper&lt;int&gt;); //#1
void meow(convertible_from_int); //#2
meow(0); // <span style="color:#C80000;font-weight:bold">ambiguous;</span> would call #2 if #1 instead took int&amp;
</pre></blockquote>
<p>
and in conditional expressions (and hence <tt>std::common_type</tt>) after core
issue <a href="https://wg21.link/cwg1895">CWG 1895</a>:
</p>
<blockquote><pre>
std::reference_wrapper&lt;int&gt; purr();

auto x = true? purr() : 0; // <span style="color:#C80000;font-weight:bold">error, ambiguous:</span> ICS exists from int prvalue to 
     // reference_wrapper&lt;int&gt; and from reference_wrapper&lt;int&gt; to int
using t = std::common_type_t&lt;std::reference_wrapper&lt;int&gt;, int&gt;; // <span style="color:#C80000;font-weight:bold">error</span>, no member 
     // type because the conditional expression is ill-formed
</pre></blockquote>
<p>
The latter in turn interferes with the use of <tt>reference_wrapper</tt> as a
proxy reference type with proxy iterators.
<p/>
We should ensure that there is no implicit conversion sequence from <tt>T</tt>
rvalues to <tt>reference_wrapper&lt;T&gt;</tt>, not just that the conversion will be
ill-formed when used. This can be done by using a suitably constrained
constructor template taking a forwarding reference instead of the
current pair of constructors taking <tt>T&amp;</tt> and <tt>T&amp;&amp;</tt>.
</p>
</discussion>

<resolution>
</resolution>
</issue>
