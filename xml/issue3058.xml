<?xml version='1.0' encoding='utf-8' standalone='no'?>
<!DOCTYPE issue SYSTEM "lwg-issue.dtd">

<issue num="3058" status="New">
<title>Parallel <tt>adjacent_difference</tt> shouldn't require creating temporaries</title>
<section><sref ref="[adjacent.difference]"/></section>
<submitter>Billy O'Neal III</submitter>
<date>2 Feb 2018</date>
<priority>99</priority>

<discussion>
<p>
Parallel <tt>adjacent_difference</tt> is presently specified to "create a temporary object whose 
type is <tt>ForwardIterator1</tt>'s value type". Serial <tt>adjacent_difference</tt> does that 
because it needs to work with input iterators, and needs to work when the destination range 
exactly overlaps the input range. The parallel version requires forward iterators and doesn't 
allow overlap, so it can avoid making these temporaries.
</p>
</discussion>

<resolution>
<p>This wording is relative to <a href="http://wg21.link/n4713">N4713</a>.</p>

<ol>
<li><p>Modify <sref ref="[adjacent.difference]"/> as indicated:</p>

<blockquote>
<pre>
template&lt;class InputIterator, class OutputIterator&gt;
  OutputIterator
    adjacent_difference(InputIterator first, InputIterator last, OutputIterator result);
template&lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2&gt;
  ForwardIterator2
    adjacent_difference(ExecutionPolicy&amp;&amp; exec,
                        ForwardIterator1 first, ForwardIterator1 last, ForwardIterator2 result);
                        
template&lt;class InputIterator, class OutputIterator, class BinaryOperation&gt;
  OutputIterator
    adjacent_difference(InputIterator first, InputIterator last,
                        OutputIterator result, BinaryOperation binary_op);
template&lt;class ExecutionPolicy, class ForwardIterator1, class ForwardIterator2,
         class BinaryOperation&gt;
  ForwardIterator2
    adjacent_difference(ExecutionPolicy&amp;&amp; exec,
                        ForwardIterator1 first, ForwardIterator1 last,
                        ForwardIterator2 result, BinaryOperation binary_op);
</pre>
<blockquote>
<p>
-1- <i>Requires:</i>
<ol style="list-style-type: none">
<li><p>(1.1) &mdash; [&hellip;]</p></li>
<li><p>(1.2) &mdash; For the overloads with an <tt>ExecutionPolicy</tt>, the <del>value type of 
<tt>ForwardIterator1</tt> shall be <tt>CopyConstructible</tt> (Table 24), constructible from the 
expression <tt>*first - *first</tt> or <tt>binary_op(*first, *first)</tt>, and assignable to 
the value type of <tt>ForwardIterator2</tt></del><ins>result of the expressions <tt>*first - *first</tt> 
(for the first overload) or <tt>binary_op(*first, *first)</tt> (for the second overload) and 
<tt>*first</tt> shall be writable to <tt>result</tt></ins>.</p></li>
<li><p>(1.3) &mdash; [&hellip;]</p></li>
</ol>
<p/>
-2- <i>Effects:</i> [&hellip;]
<p/>
-3- For the overloads with an <tt>ExecutionPolicy</tt> and a non-empty range, <del>first the function 
creates an object whose type is <tt>ForwardIterator1</tt>'s value type, initializes it with <tt>*first</tt>, 
and assigns the result to <tt>*result</tt>. Then for every <tt>d</tt> in <tt>[1, last - first - 1]</tt>, 
creates an object <tt>val</tt> whose type is <tt>ForwardIterator1</tt>'s value type, initializes it 
with <tt>*(first + d) - *(first + d - 1)</tt> or <tt>binary_op(*(first + d), *(first + d - 1))</tt>, 
and assigns the result to <tt>*(result + d)</tt></del><ins>performs <tt>*result = *first</tt>. Then, 
for every <tt>d</tt> in <tt>[1, last - first - 1]</tt>, performs <tt>*(result + d) = *(first + d) - 
*(first + d - 1)</tt> or <tt>*(result + d) = binary_op(*(first + d), *(first + d - 1))</tt></ins>.
</p>
</blockquote>
</blockquote>
</li>
</ol>
</resolution>

</issue>
