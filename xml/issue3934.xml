<?xml version='1.0' encoding='utf-8' standalone='no'?>
<!DOCTYPE issue SYSTEM "lwg-issue.dtd">

<issue num="3934" status="New">
<title><tt>std::complex&lt;T&gt;::operator=(const T&amp;)</tt> has no specification</title>
<section><sref ref="[complex]"/></section>
<submitter>Daniel Kr&uuml;gler</submitter>
<date>20 May 2023</date>
<priority>99</priority>

<discussion>
<p>
The class template <tt>complex</tt> synopsis in <sref ref="[complex]"/> shows the following member function:
</p>
<blockquote><pre>
constexpr complex&amp; operator= (const T&amp;);
</pre></blockquote>
<p>
but does not specify its semantics. This affects a code example such as the following one:
</p>
<blockquote><pre>
#include &lt;complex&gt;
#include &lt;iostream&gt;

int main()
{
  std::complex&lt;double&gt; z(1, 1);
  z = 2;
  std::cout &lt;&lt; z &lt;&lt; std::endl;
}
</pre></blockquote>
<p>
This problem exists since the 1998 version of the standard (at that time this was declared in subclause [lib.complex]),
but fortunately the three major implementations all behave consistently by assigning the provided value to the real
part and nullifying the imaginary part, causing the output <tt>(2, 0)</tt>, which is consistent with the expected
behaviour of usual mathematical convention and that of C's built-in <tt>complex</tt> types. We should specify this.
<p/>
The lack of this member specification was observed while a proposed wording for LWG <iref ref="3933"/> was prepared.
</p>

</discussion>

<resolution>
<p>
This wording is relative to <paper num="N4950"/>.
</p>

<blockquote class="note">
<p>
[<i>Drafting Note:</i> Two mutually exclusive options are prepared, depicted below by <b>Option A</b> and 
<b>Option B</b>, respectively.] 
</p>
</blockquote>

<p>
<b>Option A:</b> This assumes that LWG <iref ref="3933"/> is considered as NAD and just adds the missing prototype
specification assuming that the parameter style of the current working draft is intended.
</p>

<ol>

<li>
<p>Add a new prototype specification at the very beginning of <sref ref="[complex.member.ops]"/> as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note</i>: The wording form used below intentionally deviates from the rest of the [complex.member.ops]
wording forms, because it seems much simpler and clearer to follow the wording forms used that specify the effects
of <tt>imag</tt> and <tt>real</tt> functions.]
</p>
</blockquote>

<blockquote>
<pre>
<ins>constexpr complex&amp; operator=(const T&amp; rhs);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects</i>: Assigns the value <tt>rhs</tt> to the real component and the value <tt>T()</tt> 
to the imaginary component of the complex value <tt>*this</tt>.</ins>
<p/>
<ins>-?- <i>Returns</i>: <tt>*this</tt>.</ins>
</p>
</blockquote>
<pre>
constexpr complex&amp; operator+=(const T&amp; rhs);
</pre>
<blockquote>
<p>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>

</ol>

<p>
<b>Option b:</b> This assumes that LWG <iref ref="3933"/> will be resolved as initially presented and just adds the missing prototype
specification assuming that the parameter style suggesting two mutually excluded overloads is intended.
</p>

<ol>

<li>
<p>Add a new prototype specification at the very beginning of <sref ref="[complex.member.ops]"/> as indicated:</p>

<blockquote class="note">
<p>
[<i>Drafting note</i>: The wording form used below intentionally deviates from the rest of the [complex.member.ops]
wording forms, because it seems much simpler and clearer to follow the wording forms used that specify the effects
of <tt>imag</tt> and <tt>real</tt> functions instead.]
</p>
</blockquote>

<blockquote>
<pre>
<ins>constexpr complex&amp; operator=(T rhs) requires floating_point&lt;T&gt;;
constexpr complex&amp; operator=(const T&amp; rhs) requires (!floating_point&lt;T&gt;);</ins>
</pre>
<blockquote>
<p>
<ins>-?- <i>Effects</i>: Assigns the value <tt>rhs</tt> to the real component and the value <tt>T()</tt> 
to the imaginary component of the complex value <tt>*this</tt>.</ins>
<p/>
<ins>-?- <i>Returns</i>: <tt>*this</tt>.</ins>
</p>
</blockquote>
<pre>
constexpr complex&amp; operator+=(T) requires floating_point&lt;T&gt;;
constexpr complex&amp; operator+=(const T&amp;) requires (!floating_point&lt;T&gt;);
</pre>
<blockquote>
<p>
[&hellip;]
</p>
</blockquote>
</blockquote>
</li>

</ol>
</resolution>

</issue>
