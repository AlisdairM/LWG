<?xml version='1.0' encoding='utf-8' standalone='no'?>
<!DOCTYPE issue SYSTEM "lwg-issue.dtd">

<issue num="3690" status="New">
<title><tt>std::make_from_tuple</tt> etc. should find all tuple-like <tt>std::get</tt> overloads</title>
<section><sref ref="[contents]"/><sref ref="[tuple.apply]"/></section>
<submitter>Jiang An</submitter>
<date>06 Apr 2022</date>
<priority>99</priority>

<discussion>
<p>
Currently it is not clear in <sref ref="[contents]"/>/3 whether all possible overloads in the 
standard library are considered to be found "in the context of <tt>D</tt>". As a result, it 
seems underspecified whether a certain <tt>std::get</tt> overload is found by <tt>std::tuple_cat</tt>, 
<tt>std::make_from_tuple</tt>, <tt>std::apply</tt>, or exposition-only concept <tt><i>pair-like</i></tt> 
or <tt><i>has-tuple-element</i></tt>.
<p/>
There is implementation divergence: MSVC STL's <tt>std::make_from_tuple</tt> accepts 
<tt>std::ranges::subrange</tt>, but libstdc++'s doesn't, which is originally discussed in 
<a href="https://gcc.gnu.org/bugzilla/show_bug.cgi?id=102301">GCC bug #102301</a>.
<p/>
IMO <tt>std::get</tt> overloads need some special rules: when referred by tuple-like facilities, 
overloads for <tt>std::variant</tt> should be excluded (or at least leave whether it's found 
unspecified), and all other overloads should be found; and the opposite rule should be used 
when referred in <sref ref="[variant]"/>.
</p>
</discussion>

<resolution>
</resolution>

</issue>
