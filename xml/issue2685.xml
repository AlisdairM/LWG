<?xml version='1.0' encoding='utf-8' standalone='no'?>
<!DOCTYPE issue SYSTEM "lwg-issue.dtd">

<issue num="2685" status="New">
<title>shared_ptr deleters must not not throw on move construction</title>
<section><sref ref="[section.ref.here]"/></section>
<submitter>Jonathan Wakely</submitter>
<date>3 May 2016</date>
<priority>99</priority>

<discussion>
<p>In [util.smartptr.shared.const] p8 the shared_ptr constructors taking
a deleter say:</p>

<p>"The copy constructor and destructor of D shall not throw exceptions."</p>

<p>It's been pointed out that this doesn't forbid throwing moves, which
makes it difficult to avoid a leak here:</p>

<p><pre>
struct D {
  D() = default;
  D(const D&) noexcept = default;
  D(D&&) { throw 1; }
  void operator()(int* p) const { delete p; }
};

shared_ptr&lt;int&gt; p{new int, D{}};
</pre></p>

<p>"The copy constructor" should be changed to reflect that the chosen
constructor might not be a copy constructor, and that copies made
using any constructor must not throw.</p>

<p>N.B. the same wording is used for the allocator argument, but that's
redundant because the Allocator requirements already forbid exceptions
when copying or moving.
</p>
</discussion>

<resolution>
<p>
[Drafting note: the relevant expressions we're concerned about are
enumerated in the CopyConstructible and MoveConstructible
requirements, so I see no need to repeat them by saying something
clunky like "Initialization of an object of type D from an expression
of type (possibly const) D shall not throw exceptions", we can just
refer to them. An alternative would be to define
NothrowCopyConstructible, which includes CopyConstructible but
requires that construction and destruction do not throw.]
</p>

<p>
Change [util.smartptr.shared.const] p8
</p>

<p>
<tt>D</tt> shall be CopyConstructible <ins>and such construction shall not
throw exceptions.</ins> The <del>copy constructor and</del> destructor
of <tt>D</tt> shall not throw exceptions.
</p>
</resolution>

</issue>
