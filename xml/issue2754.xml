<?xml version='1.0' encoding='utf-8' standalone='no'?>
<!DOCTYPE issue SYSTEM "lwg-issue.dtd">

<issue num="2754" status="New">
<title>The <tt>in_place</tt> constructors and <tt>emplace</tt> functions added by P0032R3 don't require <tt>CopyConstructible</tt></title>
<section><sref ref="[any.cons]"/><sref ref="[any.assign]"/><sref ref="[any.modifiers]"/></section>
<submitter>Ville Voutilainen</submitter>
<date>5 Jul 2016</date>
<priority>1</priority>

<discussion>
<p>
The <tt>in_place</tt> constructors and <tt>emplace</tt> functions
added by <a href="http://wg21.link/p0032r3">P0032R3</a> don't require <tt>CopyConstructible</tt>.
<p/>
They must. Otherwise copying an <tt>any</tt> that's made to hold a non-<tt>CopyConstructible</tt>
type must fail with a run-time error. Since that's crazy, we want to prevent
storing non-<tt>CopyConstructible</tt> types in an <tt>any</tt>.
<p/>
Previously, the requirement for <tt>CopyConstructible</tt> was just on the converting
constructor template and the converting assignment operator template on <tt>any</tt>.
Now that we are adding two <tt>in_place</tt> constructor overloads and two
<tt>emplace</tt> overloads, it seems reasonable to require <tt>CopyConstructible</tt> in some more 
general location, in order to avoid repeating that requirement all over the place.
</p>

<note>2016-07 &mdash; Chicago</note>
<p>Monday: P1</p>
<p>Tuesday: Ville/Billy/Billy provide wording</p>

<note>2016-08-02: Daniel comments</note>
<p>
The P/R wording of this issue brought to my intention that the recently added <tt>emplace</tt> functions
of <tt>std::any</tt> introduced a breakage of a previous class invariant that only a <tt>decay</tt>ed type could
be stored as object into an <tt>any</tt>, this prevented storing arrays, references, functions, and <i>cv</i>-qualified
types. The new constraints added my Ville do prevent some of these types (e.g. neither arrays nor functions meet
the <tt>CopyConstructible</tt> requirements), but we need to cope with <i>cv</i>-qualified types and reference types.
</p>

<note>2016-08-02: Ville adjusts the P/R to cope with the problems pointed out by Daniel's comment</note>
</discussion>

<resolution>
<p>
This wording is relative to N4606.
</p>
<blockquote class="note">
<p>
Drafting note: this P/R doesn't turn the <i>Requires</i>-clauses into <i>Remarks</i>-clauses.
We might want to do that separately, because SFINAEing the constructors
allows users to query for <tt>is_constructible</tt> and get the right answer. Failing
to mandate the SFINAE will lead to non-portable answers for <tt>is_constructible</tt>.
Currently, libstdc++ SFINAEs. That should be done as a separate issue,
as this issue is an urgent bug-fix but the mandated SFINAE is not.
</p>
</blockquote>

<ol>
<li><p>Change <sref ref="[any.class]"/>, class <tt>any</tt> synopsis, as indicated:</p>

<blockquote>
<pre>
class any {
public:
  [&hellip;]
  template &lt;class <del>T</del><ins>ValueType</ins>, class... Args&gt;
    void emplace(Args&amp;&amp; ...);
  template &lt;class <del>T</del><ins>ValueType</ins>, class U, class... Args&gt;
    void emplace(initializer_list&lt;U&gt;, Args&amp;&amp;...);
  [&hellip;]
};
</pre>
</blockquote>
</li>

<li><p>Change <sref ref="[any.cons]"/> as indicated:</p>

<blockquote>
<pre>
template&lt;class ValueType&gt;
  any(ValueType&amp;&amp; value);
</pre>
<blockquote>
<p>
-6- Let <tt>T</tt> be equal to <tt>decay_t&lt;ValueType&gt;</tt>.
<p/>
-7- <i>Requires:</i> <tt>T</tt> shall satisfy the <tt>CopyConstructible</tt> requirements. 
<del>If <tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>false</tt>, the program is ill-formed.</del>
<p/>
[&hellip;]
<p/>
-9- <i>Remarks:</i> This constructor shall not participate in overload resolution <del>if</del><ins>unless</ins> 
<tt>decay_t&lt;ValueType&gt;</tt> is <ins>not</ins> the same type as <tt>any</tt> <ins>and 
<tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt></ins>.
</p>
</blockquote>
<pre>
template &lt;class T, class... Args&gt;
  explicit any(in_place_type_t&lt;T&gt;, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-11- <i>Requires:</i> <ins><tt>T</tt> shall satisfy the <tt>CopyConstructible</tt> requirements</ins>
<del><tt>is_constructible_v&lt;T, Args...&gt;</tt> is <tt>true</tt></del>.
<p/>
[&hellip;]
<p/>
<ins>-?- <i>Remarks:</i> This constructor shall not participate in overload resolution
unless <tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt> and <tt>is_constructible_v&lt;T, Args...&gt;</tt>
is <tt>true</tt>.</ins>
</p>
</blockquote>
<pre>
template &lt;class T, class U, class... Args&gt;
  explicit any(in_place_type_t&lt;T&gt;, initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
-15- <i>Requires:</i> <ins><tt>T</tt> shall satisfy the <tt>CopyConstructible</tt> requirements</ins>
<del><tt>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args...&gt;</tt> is <tt>true</tt></del>.
<p/>
[&hellip;]
<p/>
-19- <i>Remarks:</i> The function shall not participate in overload resolution unless 
<ins><tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt> and</ins>
<tt>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args...&gt;</tt> is <tt>true</tt>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Change <sref ref="[any.assign]"/> as indicated:</p>

<blockquote>
<pre>
template&lt;class ValueType&gt;
  any&amp; operator=(ValueType&amp;&amp; rhs);
</pre>
<blockquote>
<p>
-7- Let <tt>T</tt> be equal to <tt>decay_t&lt;ValueType&gt;</tt>.
<p/>
-8- <i>Requires:</i> <tt>T</tt> shall satisfy the <tt>CopyConstructible</tt> requirements. <del>If 
<tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>false</tt>, the program is ill-formed.</del>
<p/>
[&hellip;]
<p/>
-11- <i>Remarks:</i> This operator shall not participate in overload resolution <del>if</del><ins>unless</ins> 
<tt>decay_t&lt;ValueType&gt;</tt> is <ins>not</ins> the same type as <tt>any</tt> <ins>and
<tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt></ins>.
</p>
</blockquote>
</blockquote>
</li>

<li><p>Change <sref ref="[any.modifiers]"/> as indicated:</p>

<blockquote>
<pre>
template &lt;class <del>T</del><ins>ValueType</ins>, class... Args&gt;
  void emplace(Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
<ins>Let <tt>T</tt> be equal to <tt>remove_cv_t&lt;ValueType&gt;</tt>.</ins>
<p/>
-1- <i>Requires:</i> <ins><tt>T</tt> shall satisfy the <tt>CopyConstructible</tt> requirements</ins>
<del><tt>is_constructible_v&lt;T, Args...&gt;</tt> is <tt>true</tt></del>.
<p/>
[&hellip;]
<p/>
-5- <i>Remarks:</i> If an exception is thrown during the call to <tt>T</tt>'s constructor, <tt>*this</tt> does not 
contain a value, and any previously contained object has been destroyed. <ins>This function shall not participate 
in overload resolution unless <tt>is_reference_v&lt;T&gt;</tt> is <tt>false</tt>, <tt>is_array_v&lt;T&gt;</tt> is 
<tt>false</tt>, <tt>is_function_v&lt;T&gt;</tt> is <tt>false</tt>, <tt>is_copy_constructible_v&lt;T&gt;</tt> is 
<tt>true</tt> and <tt>is_constructible_v&lt;T, Args...&gt;</tt> is <tt>true</tt>.</ins>
</p>
</blockquote>

<pre>
template &lt;class <del>T</del><ins>ValueType</ins>, class U, class... Args&gt;
  void emplace(initializer_list&lt;U&gt; il, Args&amp;&amp;... args);
</pre>
<blockquote>
<p>
<ins>Let <tt>T</tt> be equal to <tt>remove_cv_t&lt;ValueType&gt;</tt>.</ins>
<p/>
<ins>-?- <i>Requires</i>: <tt>T</tt> shall satisfy the <tt>CopyConstructible</tt> requirements.</ins>
<p/>
-6- <i>Effects:</i> [&hellip;]
<p/>
[&hellip;]
<p/>
-9- <i>Remarks:</i> If an exception is thrown during the call to <tt>T</tt>'s constructor, <tt>*this</tt> does 
not contain a value, and any previously contained object has been destroyed. The function shall not participate in overload
resolution unless <ins><tt>is_reference_v&lt;T&gt;</tt> is <tt>false</tt>, <tt>is_array_v&lt;T&gt;</tt> is <tt>false</tt>,
<tt>is_function_v&lt;T&gt;</tt> is <tt>false</tt>, <tt>is_copy_constructible_v&lt;T&gt;</tt> is <tt>true</tt> and</ins> 
<tt>is_constructible_v&lt;T, initializer_list&lt;U&gt;&amp;, Args...&gt;</tt> is <tt>true</tt>.
</p>
</blockquote>
</blockquote>
</li>
</ol>
</resolution>

</issue>
