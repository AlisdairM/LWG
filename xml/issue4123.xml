<?xml version='1.0' encoding='utf-8' standalone='no'?>
<!DOCTYPE issue SYSTEM "lwg-issue.dtd">

<issue num="4123" status="New">
<title>Container effects use "the assignment operator or move assignment operator"</title>
<section>
<sref ref="[deque.modifiers]"/>
<sref ref="[vector.modifiers]"/>
<sref ref="[inplace.vector.modifiers]"/>
</section>
<submitter>Jonathan Wakely</submitter>
<date>25 Jul 2024</date>
<priority>3</priority>

<discussion>
<p>
The spec for `deque::erase` talks about a exception
"thrown by the assignment operator of `T`" but it's unclear which
assignment operator this means.
Arguably, this is fine because it means "the assignment operator that
is used when repositioning the remaining elements".
However, `deque::append_range`, `vector::append_range`, `vector::erase`,
`inplace_vector::append_range`, and `inplace_vector::erase` talk about
"the assignment operator or move assignment operator" which is just odd.
In C++03 this just said "the assignment operator" and move semantics
added "or the move assignment operator" but we could improve it.
</p>

<p>
What we should talk about is "an assignment operator", or "the assignment
operator selected by overload resolution for the assignment expressions
performed by the operation", or something like that.
</p>

<p>
This is potentially a bigger issue than just assignment:
for `append_range` we say
"If an exception is thrown other than by the copy constructor,
move constructor, assignment operator, or move assignment operator [...]"
and there's no guarantee that the constructor used for initializing a
<i>Cpp17CopyInsertable</i> type is a copy constructor or move constructor.
It could be some templated constructor that is a better match than any
of the special member functions.
</p>

<note>2024-08-02; Reflector poll</note>
<p>
Set priority to 3 after reflector poll. Arthur to draft wording.
</p>

<note>2024-12-06; LWG telecon</note>
<p>
<sref ref="[list.modifiers]"/> p1 says:
<blockquote>
<i>Complexity</i>:
Insertion of a single element into a list takes constant time and exactly
one call to a constructor of `T`.
Insertion of multiple elements into a list is linear in the number of elements inserted,
and the number of calls to the copy constructor or move constructor of `T`
is exactly equal to the number of elements inserted.
</blockquote>
In addition to incorrectly talking about "the copy constructor or move
constructor", it should not should not talk about any "call to a constructor"
because scalars and aggregates do not have constructors at all.
We should talk about calls to `allocator_traits::construct` not constructors.
</p>
<p>
Similarly, p5 says:
<blockquote>
<i>Complexity</i>:
Erasing a single element is a constant time operation with
a single call to the destructor of `T`.
Erasing a range in a list is linear time in the size of the range
and the number of calls to the destructor of type `T`
is exactly equal to the size of the range.
</blockquote>
This should talk about calls to `allocator_traits::destroy`.
</p>
<p>
Look for similar problems elsewhere.
</p>
</discussion>

<resolution>
<p>
</p>
</resolution>

</issue>
