<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>C++ Standard Library Issues Resolved Directly In [INSERT CURRENT MEETING HERE]</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
</style>
</head>
<body>
<p>Revised 2014-02-13 at 15:02:01 UTC</p>
<h2>Immediate Issues</h2>
<hr>
<h3><a name="2182"></a>2182. <tt>Container::[const_]reference</tt> types are misleadingly specified</h3>
<p><b>Section:</b> 23.2.1 [container.requirements.general] <b>Status:</b> <a href="lwg-active.html#Immediate">Immediate</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2012-08-20 <b>Last modified:</b> 2014-02-12</p>
<p><b>View other</b> <a href="lwg-index-open.html#container.requirements.general">active issues</a> in [container.requirements.general].</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements.general">issues</a> in [container.requirements.general].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Immediate">Immediate</a> status.</p>
<p><b>Discussion:</b></p>

<p>
According to Table 96 (Container requirements) the return type of <tt>X::reference</tt> and
<tt>X::const_reference</tt> is "lvalue of <tt>T</tt>" and "<tt>const</tt> lvalue of <tt>T</tt>",
respectively. This does not make much sense, because an lvalue is an expression category, not a type.
It could also refer to an expression that has a type, but this doesn't make sense either in this
context, because obviously <tt>X::[const_]reference</tt> are intended to refer to types. 
<p/>
Given the fact that <tt>vector&lt;bool&gt;</tt> has no real reference type for <tt>X::[const_]reference</tt> 
and this definition presumably is intended to cover such situations as well, one might think that the wording is
just a sloppy form of "type that represents a [const] lvalue of <tt>T</tt>". But this is also problematic,
because basically all proxy reference expressions are rvalues.
<p/>
It is unclear what the intention is. A straightward way of fixing this wording could make
<tt>X::[const_]reference</tt> identical to <tt>[const] T&amp;</tt>. This holds for all Library containers
except for <tt>vector&lt;bool&gt;</tt>.
<p/>
Another way of solving this definition problem would be to impose a requirement that holds for both
references and reference-like proxies. Both <tt>X::reference</tt> and <tt>X::const_reference</tt>
would need to be convertible to <tt>const T&amp;</tt>. Additionally <tt>X::reference</tt> would need to
support for a mutable container an assignment expression of the form 
<tt>declval&lt;X::reference&gt;() = declval&lt;T&gt;()</tt> (this presentation intentionally does not require 
<tt>declval&lt;X::reference<span style="color:#C80000;font-weight:bold">&amp;</span>&gt;() = declval&lt;T&gt;()</tt>).
<p/>
Further, the Table 96 does not impose any relations between <tt>X::reference</tt> and <tt>X::const_reference</tt>.
It seems that at least <tt>X::reference</tt> needs to be convertible to <tt>X::const_reference</tt>.
<p/>
A related question is whether <tt>X::reference</tt> is supposed to be a mutable reference-like type,
irrespective of whether the container is an immutable container or not. The way, type <tt>match_results</tt>
defines <tt>reference</tt> identical to <tt>const_reference</tt> indicates one specific interpretation (similarly,
the <tt>initializer_list</tt> template also defines member type <tt>reference</tt> equal to <tt>const value_type&amp;</tt>).
Note that this can be a different decision as that for <tt>iterator</tt> and <tt>const_iterator</tt>,
e.g. for sets the type <tt>X::reference</tt> still is a mutable reference, even though <tt>iterator</tt>
is described as constant iterator.
<p/>
The proposed resolution is incomplete in regard to the last question.
</p>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Review.
</p>
<p>
Alisdair notes that this looks like wording in the right direction.  Wonders about congruence of these
typedefs and the similar ones for iterators.
</p>

<p><i>[2013-09 Chicago]</i></p>

<p>
Moved to Ready.
</p>
<p>
Consensus that the requirements should require real references, just like iterators, as containers are
required to support at least ForwardIterators, which have the same restriction on references.
</p>

<p>
Matt will file a new issue for some additional concerns with regex <tt>match_results</tt>.
</p>

<p><i>[2014-02-10, Daniel comments]</i></p>


<p>
The new issue opened by Matt is LWG <a href="lwg-active.html#2306">2306</a>.
</p>

<p><i>[Issaquah 20014-10-11: Move to Immediate]</i></p>

<p>
Issue should have been Ready in pre-meeting mailing.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3376.</p>

<ol>
<li><p>Change Table 96 &mdash; "Container requirements" as indicated:</p>

<table border="1">
<caption>Table p6 &mdash; Container requirements</caption>

<tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational<br/>Semantics</th>
<th>Assertion/note<br/>pre-/post-condition</th>
<th>Complexity</th>
</tr> 

<tr>
<td>
<tt>X::reference</tt>
</td>
<td>
<del>lvalue of </del><tt>T<ins>&amp;</ins></tt>
</td>
<td>
&nbsp;
</td>
<td>
</td>
<td>
compile time
</td>
</tr>

<tr>
<td>
<tt>X::const_reference</tt>
</td>
<td>
<del>const lvalue of</del><ins><tt>const</tt></ins> <tt>T<ins>&amp;</ins></tt>
</td>
<td>
&nbsp;
</td>
<td>
</td>
<td>
compile time
</td>
</tr>

</table>

</li>
</ol>





<hr>
<h3><a name="2205"></a>2205. Problematic postconditions of <tt>regex_match</tt> and <tt>regex_search</tt></h3>
<p><b>Section:</b> 28.11.2 [re.alg.match], 28.11.3 [re.alg.search] <b>Status:</b> <a href="lwg-active.html#Immediate">Immediate</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2012-10-24 <b>Last modified:</b> 2014-02-12</p>
<p><b>View other</b> <a href="lwg-index-open.html#re.alg.match">active issues</a> in [re.alg.match].</p>
<p><b>View all other</b> <a href="lwg-index.html#re.alg.match">issues</a> in [re.alg.match].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Immediate">Immediate</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Table 142 lists post-conditions on the <tt>match_results</tt> object when a call to <tt>regex_match</tt> succeeds. 
<tt>regex_match</tt> is required to match the entire target sequence. The post-condition for <tt>m[0].matched</tt> 
is "true if a full match was found." Since these are conditions for a successful search which is, by definition, 
a full match, the post-condition should be simply "true".
</p>
<p>
There's an analogous probem in Table 143: the condition for <tt>m[0].matched</tt> is "true if a match was found, 
false otherwise." But Table 143 gives post-conditions for a successful match, so the condition should be simply 
"true".
</p>
<p>
Furthermore, they have explicit requirements for <tt>m[0].first</tt>, <tt>m[0].second</tt>, and <tt>m[0].matched</tt>. 
They also have requirements for the other elements of <tt>m</tt>, described as <tt>m[n].first</tt>, <tt>m[n].second</tt>, 
and <tt>m[n].matched</tt>, in each case qualifying the value of <tt>n</tt> as "for <tt>n &lt; m.size()</tt>". Since 
there is an explicit description for <tt>n == 0</tt>, this qualification should be "for <tt>0 &lt; n &lt; m.size()</tt>" 
in all 6 places.
</p>

<p><i>[Issaquah 20014-10-11: Move to Immediate]</i></p>




<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3376.</p>

<ol>
<li><p>Change Table 142 as indicated:</p>

<table border="1">
<caption>Table 142 &mdash; Effects of <tt>regex_match</tt> algorithm</caption>
<tr>
<th>Element</th>
<th>Value</th>
</tr> 

<tr>
<td colspan="2" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>m[0].first</tt>
</td>
<td>
<tt>first</tt>
</td>
</tr>

<tr>
<td>
<tt>m[0].second</tt>
</td>
<td>
<tt>last</tt>
</td>
</tr>

<tr>
<td>
<tt>m[0].matched</tt>
</td>
<td>
<tt>true</tt> <del>if a full match was found.</del>
</td>
</tr>

<tr>
<td>
<tt>m[n].first</tt>
</td>
<td>
For all integers <tt><ins>0 &lt;</ins> n &lt; m.size()</tt>, the start of the sequence
that matched sub-expression <tt>n</tt>.<br/> 
Alternatively, if subexpression <tt>n</tt> did not participate in the match, then <tt>last</tt>.
</td>
</tr>

<tr>
<td>
<tt>m[n].second</tt>
</td>
<td>
For all integers <tt><ins>0 &lt;</ins> n &lt; m.size()</tt>, the end of the sequence that
matched sub-expression <tt>n</tt>.<br/> 
Alternatively, if sub-expression <tt>n</tt> did not participate in the match, then <tt>last</tt>.
</td>
</tr>

<tr>
<td>
<tt>m[n].matched</tt>
</td>
<td>
For all integers <tt><ins>0 &lt;</ins> n &lt; m.size()</tt>, <tt>true</tt> if sub-expression 
<tt>n</tt> participated in the match, <tt>false</tt> otherwise.
</td>
</tr>

</table>
</li>

<li><p>Change Table 143 as indicated:</p>

<table border="1">
<caption>Table 143 &mdash; Effects of <tt>regex_search</tt> algorithm</caption>
<tr>
<th>Element</th>
<th>Value</th>
</tr> 

<tr>
<td colspan="2" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>m[0].first</tt>
</td>
<td>
The start of the sequence of characters that matched the regular expression
</td>
</tr>

<tr>
<td>
<tt>m[0].second</tt>
</td>
<td>
The end of the sequence of characters that matched the regular expression
</td>
</tr>

<tr>
<td>
<tt>m[0].matched</tt>
</td>
<td>
<tt>true</tt> <del>if a match was found, and false otherwise.</del>
</td>
</tr>

<tr>
<td>
<tt>m[n].first</tt>
</td>
<td>
For all integers <tt><ins>0 &lt;</ins> n &lt; m.size()</tt>, the start of the sequence
that matched sub-expression <tt>n</tt>.<br/> 
Alternatively, if subexpression <tt>n</tt> did not participate in the match, then <tt>last</tt>.
</td>
</tr>

<tr>
<td>
<tt>m[n].second</tt>
</td>
<td>
For all integers <tt><ins>0 &lt;</ins> n &lt; m.size()</tt>, the end of the sequence that
matched sub-expression <tt>n</tt>.<br/> 
Alternatively, if sub-expression <tt>n</tt> did not participate in the match, then <tt>last</tt>.
</td>
</tr>

<tr>
<td>
<tt>m[n].matched</tt>
</td>
<td>
For all integers <tt><ins>0 &lt;</ins> n &lt; m.size()</tt>, <tt>true</tt> if sub-expression 
<tt>n</tt> participated in the match, <tt>false</tt> otherwise.
</td>
</tr>

</table>
</li>

</ol>





<hr>
<h3><a name="2213"></a>2213. Return value of <tt>std::regex_replace</tt></h3>
<p><b>Section:</b> 28.11.4 [re.alg.replace] <b>Status:</b> <a href="lwg-active.html#Immediate">Immediate</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2012-11-08 <b>Last modified:</b> 2014-02-12</p>
<p><b>View other</b> <a href="lwg-index-open.html#re.alg.replace">active issues</a> in [re.alg.replace].</p>
<p><b>View all other</b> <a href="lwg-index.html#re.alg.replace">issues</a> in [re.alg.replace].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Immediate">Immediate</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 28.11.4 [re.alg.replace], the first two variants of <tt>std::regex_replace</tt> take an output iterator named 
"out" as their first argument. Paragraph 2 of that section says that the functions return "out". When I first implemented 
this, many years ago, I wrote it to return the value of the output iterator after all the insertions (cf. <tt>std::copy</tt>), 
which seems like the most useful behavior. But looking at the requirement now, it like the functions should return the 
original value of "out" (i.e. they have to keep a copy of the iterator for no reason except to return it). Is that 
really what was intended?
</p>

<p><i>[Issaquah 20014-10-11: Move to Immediate]</i></p>




<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3485.</p>

<ol>
<li><p>Edit 28.11.4 [re.alg.replace] as indicated:</p>
<blockquote><pre>
template &lt;class OutputIterator, class BidirectionalIterator,
  class traits, class charT, class ST, class SA&gt;
OutputIterator
regex_replace(OutputIterator out, BidirectionalIterator first, BidirectionalIterator last,
  const basic_regex&lt;charT, traits&gt;&amp; e, const basic_string&lt;charT, ST, SA&gt;&amp; fmt,
  regex_constants::match_flag_type flags = regex_constants::match_default);
template &lt;class OutputIterator, class BidirectionalIterator,
  class traits, class charT&gt;
OutputIterator
regex_replace(OutputIterator out, BidirectionalIterator first, BidirectionalIterator last,
  const basic_regex&lt;charT, traits&gt;&amp; e, const charT* fmt,
  regex_constants::match_flag_type flags = regex_constants::match_default);
</pre><blockquote>
<p>
-1- <i>Effects</i>: Constructs a <tt>regex_iterator</tt> object <tt>i</tt> as if by 
<tt>regex_iterator&lt;BidirectionalIterator, charT, traits&gt; i(first, last, e, flags)</tt>, 
and uses <tt>i</tt> to enumerate through all of the matches <tt>m</tt> of type 
<tt>match_results&lt;BidirectionalIterator&gt;</tt> that occur within the sequence <tt>[first, last)</tt>. 
If no such matches are found and <tt>!(flags &amp; regex_constants ::format_no_copy)</tt> then calls
<tt><ins>out = </ins>std::copy(first, last, out)</tt>. If any matches are found then, for each such match, if 
<tt>!(flags &amp; regex_constants::format_no_copy)</tt>, calls <tt><ins>out = </ins>std::copy(m.prefix().first, 
m.prefix().second, out)</tt>, and then calls <tt><ins>out = </ins>m.format(out, fmt, flags)</tt> 
for the first form of the function and <tt><ins>out = </ins>m.format(out, fmt, fmt + 
char_traits&lt;charT&gt;::length(fmt), flags)</tt> for the second. Finally, if such a match is found 
and <tt>!(flags &amp; regex_constants ::format_no_copy)</tt>, calls 
<tt><ins>out = </ins>std::copy(last_m.suffix().first, last_m.suffix().second, out)</tt> where 
<tt>last_m</tt> is a copy of the last match found. If <tt>flags &amp; regex_constants::format_first_only</tt> 
is non-zero then only the first match found is replaced.
<p/>
-2- <i>Returns</i>: <tt>out</tt>.
</p>
</blockquote></blockquote>
</li>
</ol>






<hr>
<h3><a name="2293"></a>2293. Wrong facet used by <tt>num_put::do_put</tt></h3>
<p><b>Section:</b> 22.4.2.2.2 [facet.num.put.virtuals] <b>Status:</b> <a href="lwg-active.html#Immediate">Immediate</a>
 <b>Submitter:</b> Juan Soulie <b>Opened:</b> 2013-09-04 <b>Last modified:</b> 2014-02-12</p>
<p><b>View other</b> <a href="lwg-index-open.html#facet.num.put.virtuals">active issues</a> in [facet.num.put.virtuals].</p>
<p><b>View all other</b> <a href="lwg-index.html#facet.num.put.virtuals">issues</a> in [facet.num.put.virtuals].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Immediate">Immediate</a> status.</p>
<p><b>Discussion:</b></p>
<p>
At the end of 22.4.2.2.2 [facet.num.put.virtuals] (in p6), the return value is said to be obtained by calling 
<tt>truename</tt> or <tt>falsename</tt> on the wrong facet: <tt>ctype</tt> should be replaced by <tt>numpunct</tt>.
</p>

<p><i>[Issaquah 20014-10-11: Move to Immediate]</i></p>




<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3691.</p>

<ol>
<li><p>Edit 22.4.2.2.2 [facet.num.put.virtuals] p6 as indicated:</p>

<blockquote><p>
-6- <i>Returns:</i> If <tt>(str.flags() &amp; ios_base::boolalpha) == 0</tt> returns <tt>do_put(out, str, fill, (int)val)</tt>, 
otherwise obtains a string <tt>s</tt> as if by
</p>
<blockquote><pre>
string_type s =
  val ? use_facet&lt;<del>ctype</del><ins>numpunct</ins>&lt;charT&gt; &gt;(loc).truename()
      : use_facet&lt;<del>ctype</del><ins>numpunct</ins>&lt;charT&gt; &gt;(loc).falsename();
</pre></blockquote>
<p>
and then inserts each character c of s into out via *out++ = c and returns out.
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="2304"></a>2304. Complexity of <tt>count</tt> in unordered associative containers</h3>
<p><b>Section:</b> 23.2.5 [unord.req] <b>Status:</b> <a href="lwg-active.html#Immediate">Immediate</a>
 <b>Submitter:</b> Joaqu&iacute;n M L&oacute;pez Mu&ntilde;oz <b>Opened:</b> 2013-09-20 <b>Last modified:</b> 2014-02-13</p>
<p><b>View other</b> <a href="lwg-index-open.html#unord.req">active issues</a> in [unord.req].</p>
<p><b>View all other</b> <a href="lwg-index.html#unord.req">issues</a> in [unord.req].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Immediate">Immediate</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Table 103 in 23.2.5 [unord.req] states that the complexity of <tt>b.count(k)</tt> is average case &#x1d4aa;(<tt>1</tt>) rather 
than linear with the number of equivalent elements, which seems to be a typo as this requires holding an internal 
count of elements in each group of equivalent keys, something which hardly looks the intent of the standard and no 
(known by the submitter) stdlib implementation is currently doing.
</p>

<p><i>[Issaquah 20014-10-11: Move to Immediate]</i></p>




<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3691.</p>

<ol>
<li><p>Change Table 103 as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 103 &mdash; Unordered associative container requirements (in addition to container)</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note pre-&#47;post-condition</th>
<th>Complexity</th>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>b.count(k)</tt>
</td>
<td>
<tt>size_type</tt>
</td>
<td>
Returns the number of elements with key equivalent to <tt>k</tt>.
</td>
<td>
Average case &#x1d4aa;(<tt><del>1</del><ins>b.count(k)</ins></tt>), worst case &#x1d4aa;(<tt>b.size()</tt>).
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>

</li>
</ol>





<hr>
<h3><a name="2306"></a>2306. <tt>match_results::reference</tt> should be <tt>value_type&amp;</tt>, not <tt>const value_type&amp;</tt></h3>
<p><b>Section:</b> 28.10 [re.results] <b>Status:</b> <a href="lwg-active.html#Immediate">Immediate</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2013-09-25 <b>Last modified:</b> 2014-02-12</p>
<p><b>View other</b> <a href="lwg-index-open.html#re.results">active issues</a> in [re.results].</p>
<p><b>View all other</b> <a href="lwg-index.html#re.results">issues</a> in [re.results].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Immediate">Immediate</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The match_results class synopsis has
</p>
<blockquote><pre>
typedef const value_type&amp; const_reference;
typedef const_reference reference;
</pre></blockquote>
<p>
We're getting too enthusiastic about types here by insisting that <tt>reference</tt> is a const reference, even 
though <tt>match_results</tt> is a read-only container. In the container requirements table (Table 96, in section 
23.2.1 [container.requirements.general] we say that <tt>Container::reference</tt> is "lvalue of <tt>T</tt>" and 
<tt>Container::const_reference</tt> is "const lvalue of <tt>T</tt>".
</p>
<p>
That phrasing in the container requirements table is admittedly a little fuzzy and ought to be clarified (as discussed in 
lwg issue <a href="lwg-active.html#2182">2182</a>), but in context it's clear that <tt>Container::reference</tt> ought to be a <tt>T&amp;</tt> 
even for constant containers. In the rest of Clause 23 we see that <tt>Container::reference</tt> is <tt>T&amp;</tt>, not 
<tt>const T&amp;</tt>, even for const-qualified containers and that it's <tt>T&amp;</tt>, not <tt>const T&amp;</tt>, even 
for containers like <tt>set</tt> and <tt>unordered_set</tt> that provide const iterators only.
<p/>
The way we handle const containers is just that in the case of a const-qualified container (including <tt>match_results</tt>) 
there are no operations that return <tt>Container::reference</tt>. That's already the case, so this issue is complaining 
about an unused typedef.
</p>

<p><i>[2013-10-17: Daniel comments]</i></p>

<p>
The <tt>std::initializer_list</tt> synopsis, 18.9 [support.initlist] shows a similar problem:
</p>
<blockquote><pre>
template&lt;class E&gt; class initializer_list {
public:
  typedef E value_type;
  typedef const E&amp; reference;
  typedef const E&amp; const_reference;
  [&hellip;]
}
</pre></blockquote>
<p>
Given the fact that <tt>std::initializer_list</tt> doesn't meet the container requirements anyway (and is such a core-language related
type) I recommend to stick with the current state.
</p>

<p><i>[Issaquah 20014-10-11: Move to Immediate]</i></p>




<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3691.</p>

<ol>
<li><p>Change the class template <tt>match_results</tt> header synopsis, 28.10 [re.results] p4 as indicated:</p>

<blockquote><pre>
typedef const value_type&amp; const_reference;
typedef <del>const_reference</del><ins>value_type&amp;</ins> reference;
</pre></blockquote>
</li>
</ol>





<hr>
<h3><a name="2308"></a>2308. Clarify container destructor requirements w.r.t. <tt>std::array</tt></h3>
<p><b>Section:</b> 23.2.1 [container.requirements.general] <b>Status:</b> <a href="lwg-active.html#Immediate">Immediate</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2013-09-26 <b>Last modified:</b> 2014-02-13</p>
<p><b>View other</b> <a href="lwg-index-open.html#container.requirements.general">active issues</a> in [container.requirements.general].</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements.general">issues</a> in [container.requirements.general].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Immediate">Immediate</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It has been suggested that Table 96 &mdash; "Container requirements" makes
confusing requirements for the destructor of <tt>std::array</tt>:
<p/>
"note: the destructor is applied to every element of <tt>a</tt>; all the memory is deallocated."
<p/>
Since <tt>std::array</tt> obtains no memory, there is none to deallocate,
arguably  making it unclear what the requirement means for <tt>std::array::~array()</tt>.
</p>

<p><i>[Issaquah 20014-10-11: Move to Immediate]</i></p>




<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3691.</p>

<ol>
<li><p>Change in 23.2.1 [container.requirements.general], Table 96 &mdash; "Container requirements", 
the "Assertion/note/pre-/post-condition" for the expression "<tt>(&amp;a)-&gt;~X()</tt>" as indicated:</p>

<blockquote><p>
note: the destructor is applied to every element of <tt>a</tt>; <del>all the</del><ins>any</ins> memory 
<ins>obtained</ins> is deallocated.
</p></blockquote>
</li>
</ol>





<hr>
<h3><a name="2313"></a>2313. <tt>tuple_size</tt> should always derive from <tt>integral_constant&lt;size_t, N&gt;</tt></h3>
<p><b>Section:</b> 20.4.2.5 [tuple.helper] <b>Status:</b> <a href="lwg-active.html#Immediate">Immediate</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2013-09-21 <b>Last modified:</b> 2014-02-12</p>
<p><b>View all other</b> <a href="lwg-index.html#tuple.helper">issues</a> in [tuple.helper].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Immediate">Immediate</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 20.4.2.5 [tuple.helper], the "primary template" is depicted as:
</p>
<blockquote><pre>
template &lt;class... Types&gt;
class tuple_size&lt;tuple&lt;Types...&gt; &gt;
  : public integral_constant&lt;size_t, sizeof...(Types)&gt; { };
</pre></blockquote>
<p>
However, 20.3.4 [pair.astuple]/1-2 and 23.3.2.9 [array.tuple]/1-2 are underspecified, saying:
</p>
<blockquote><pre>
tuple_size&lt;pair&lt;T1, T2&gt; &gt;::value
</pre><blockquote>
<p>
<i>Returns:</i> Integral constant expression.
<p/>
<i>Value:</i> <tt>2</tt>.
</p></blockquote>
</blockquote>
<blockquote><pre>
tuple_size&lt;array&lt;T, N&gt; &gt;::value
</pre><blockquote>
<p>
<i>Return type:</i> integral constant expression.
<p/>
<i>Value:</i> <tt>N</tt>
</p></blockquote>
</blockquote>
<p>
They should be required to behave like the "primary template". This is more than a stylistic decision &mdash; it allows 
<tt>tuple_size</tt> to be passed to a function taking <tt>integral_constant</tt>.
<p/>
LWG <a href="lwg-defects.html#1118">1118</a> noticed this underspecification, but instead of correcting it, the resolution changed 
20.4.2.5 [tuple.helper]/3 to require <tt>tuple_size&lt;<i>cv</i> T&gt;</tt> to derive from 
<tt>integral_constant&lt;remove_cv&lt;decltype(TS::value)&gt;::type, TS::value&gt;</tt>. This is unnecessarily overgeneralized.  
<tt>tuple_size</tt> is primarily for tuples, where it is required to be <tt>size_t</tt>, and it has been extended to handle 
pairs and arrays, which (as explained above) should also be guaranteed to be <tt>size_t</tt>. <tt>tuple_size&lt;<i>cv</i> T&gt;</tt> 
works with <i>cv</i>-qualified tuples, pairs, arrays, and user-defined types that also want to participate in the <tt>tuple_size</tt> 
system. It would be far simpler and perfectly reasonable to expect that user-defined types supporting the "tuple-like protocol" 
should have <tt>tuple_sizes</tt> of <tt>size_t</tt>.
</p>

<p><i>[Issaquah 20014-10-11: Move to Immediate]</i></p>




<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3691.</p>

<ol>
<li><p>Edit 20.3.4 [pair.astuple]/1-2 as indicated:</p>

<blockquote><pre>
<del>tuple_size&lt;pair&lt;T1, T2&gt; &gt;::value</del>
<ins>template &lt;class T1, class T2&gt;
struct tuple_size&lt;pair&lt;T1, T2&gt;&gt;
  : integral_constant&lt;size_t, 2&gt; { };</ins>
</pre><blockquote>
<p>
<del>-1- <i>Returns:</i> Integral constant expression.</del>
<p/>
<del>-2- <i>Value:</i> <tt>2</tt>.</del>
</p></blockquote>
</blockquote>
</li>

<li><p>Edit 23.3.2.9 [array.tuple]/1-2 as indicated:</p>

<blockquote><pre>
<del>tuple_size&lt;array&lt;T, N&gt; &gt;::value</del>
<ins>template &lt;class T, size_t N&gt;
struct tuple_size&lt;array&lt;T, N&gt;&gt;
  : integral_constant&lt;size_t, N&gt; { };</ins>
</pre><blockquote>
<p>
<del>-1- <i>Returns:</i> Integral constant expression.</del>
<p/>
<del>-2- <i>Value:</i> <tt>N</tt>.</del>
</p></blockquote>
</blockquote>
</li>

<li><p>Edit 20.4.2.5 [tuple.helper]/p1-p3 as indicated:</p>

<blockquote><pre>
<ins>template &lt;class T&gt; struct tuple_size;</ins>
</pre><blockquote>
<p>
<ins>-?- <i>Remarks:</i> All specializations of <tt>tuple_size&lt;T&gt;</tt> shall meet the <tt>UnaryTypeTrait</tt> 
requirements (20.10.1 [meta.rqmts]) with a <tt>BaseCharacteristic</tt> of <tt>integral_constant&lt;size_t, N&gt;</tt> 
for some <tt>N</tt>.</ins>
</p>
</blockquote>
</blockquote>
<blockquote><pre>
template &lt;class... Types&gt;
struct tuple_size&lt;tuple&lt;Types...&gt; &gt;
  : integral_constant&lt;size_t, sizeof...(Types)&gt; { };
  
template &lt;size_t I, class... Types&gt;
class tuple_element&lt;I, tuple&lt;Types...&gt; &gt; {
public:
  typedef TI type;
};
</pre><blockquote>
<p>
-1- <i>Requires:</i> <tt>I &lt; sizeof...(Types)</tt>. The program is ill-formed if <tt>I</tt> is out of bounds.
<p/>
[&hellip;]
</p></blockquote>
</blockquote>
<blockquote><pre>
template &lt;class T&gt; class tuple_size&lt;const T&gt;;
template &lt;class T&gt; class tuple_size&lt;volatile T&gt;;
template &lt;class T&gt; class tuple_size&lt;const volatile T&gt;;
</pre><blockquote>
<p>
-3- Let <i>TS</i> denote <tt>tuple_size&lt;T&gt;</tt> of the <i>cv</i>-unqualified type <tt>T</tt>. Then each of the 
three templates shall meet the <tt>UnaryTypeTrait</tt> requirements (20.10.1 [meta.rqmts]) with a <tt>BaseCharacteristic</tt> of
</p>
<blockquote><pre>
integral_constant&lt;<del>remove_cv&lt;decltype(TS::value)&gt;::type</del><ins>size_t</ins>, TS::value&gt;
</pre></blockquote>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="2314"></a>2314. <tt>apply()</tt> should return <tt>decltype(auto)</tt> and use <tt>decay_t</tt> before <tt>tuple_size</tt></h3>
<p><b>Section:</b> 20.5.1 [intseq.general] <b>Status:</b> <a href="lwg-active.html#Immediate">Immediate</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2013-09-21 <b>Last modified:</b> 2014-02-12</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Immediate">Immediate</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The example in 20.5.1 [intseq.general]/2 depicts <tt>apply_impl()</tt> and <tt>apply()</tt> as returning <tt>auto</tt>.  
This is incorrect because it will trigger decay and will not preserve <tt>F</tt>'s return type. For example, if invoking the 
functor returns <tt>const int&amp;</tt>, <tt>apply_impl()</tt> and <tt>apply()</tt> will return <tt>int</tt>. <tt>decltype(auto)</tt> 
should be used for "perfect returning".
</p>
<p>
Additionally, this depicts <tt>apply()</tt> as taking <tt>Tuple&amp;&amp;</tt>, then saying "<tt>std::tuple_size&lt;Tuple&gt;::value</tt>". 
This is incorrect because when <tt>apply()</tt> is called with lvalue tuples, perfect forwarding will deduce <tt>Tuple</tt> to be <i>cv</i> 
<tt>tuple&amp;</tt>, but 20.4.2.5 [tuple.helper] says that <tt>tuple_size</tt> handles only <i>cv</i> <tt>tuple</tt>, not 
references to tuples.  Using <tt>remove_reference_t</tt> would avoid this problem, but so would <tt>decay_t</tt>, which has a 
significantly shorter name. (The additional transformations that <tt>decay_t</tt> does are neither beneficial nor harmful here.)
</p>

<p><i>[Issaquah 20014-10-11: Move to Immediate]</i></p>




<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3691.</p>

<ol>
<li><p>Edit the example code in 20.5.1 [intseq.general]/2 as indicated:</p>

<blockquote><pre>
template&lt;class F, class Tuple, std::size_t... I&gt;
  <del>auto</del><ins>decltype(auto)</ins> apply_impl(F&amp;&amp; f, Tuple&amp;&amp; t, index_sequence&lt;I...&gt;) {
    return std::forward&lt;F&gt;(f)(std::get&lt;I&gt;(std::forward&lt;Tuple&gt;(t))...);
  }
template&lt;class F, class Tuple&gt;
  <del>auto</del><ins>decltype(auto)</ins> apply(F&amp;&amp; f, Tuple&amp;&amp; t) {
    using Indices = make_index_sequence&lt;std::tuple_size&lt;<ins>std::decay_t&lt;</ins>Tuple<ins>&gt;</ins>&gt;::value&gt;;
    return apply_impl(std::forward&lt;F&gt;(f), std::forward&lt;Tuple&gt;(t), Indices());
  }
</pre></blockquote>
</li>

</ol>





<hr>
<h3><a name="2316"></a>2316. <tt>weak_ptr::lock()</tt> should be atomic</h3>
<p><b>Section:</b> 20.8.2.3.5 [util.smartptr.weak.obs] <b>Status:</b> <a href="lwg-active.html#Immediate">Immediate</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2013-09-21 <b>Last modified:</b> 2014-02-12</p>
<p><b>View all other</b> <a href="lwg-index.html#util.smartptr.weak.obs">issues</a> in [util.smartptr.weak.obs].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Immediate">Immediate</a> status.</p>
<p><b>Discussion:</b></p>
<p>
20.8.2.2 [util.smartptr.shared]/4 says: "For purposes of determining the presence of a data race, member functions shall 
access and modify only the <tt>shared_ptr</tt> and <tt>weak_ptr</tt> objects themselves and not objects they refer to. Changes 
in <tt>use_count()</tt> do not reflect modifications that can introduce data races."  This requires <tt>shared_ptr/weak_ptr</tt> 
implementations to protect their strong and weak refcounts with atomic operations, without the Standardese having to say this 
elsewhere. However, 20.8.2.3.5 [util.smartptr.weak.obs]/5 describes <tt>weak_ptr::lock()</tt> with 
"<i>Returns:</i> <tt>expired() ? shared_ptr&lt;T&gt;() : shared_ptr&lt;T&gt;(*this)</tt>."  
Even after considering the blanket wording about 
data races, this specification is insufficient. If this conditional expression were literally implemented, the <tt>use_count()</tt> 
could change from nonzero to zero after testing <tt>expired()</tt>, causing <tt>shared_ptr&lt;T&gt;(*this)</tt> to throw 
<tt>bad_weak_ptr</tt> when the intention is for <tt>weak_ptr::lock()</tt> to return empty or nonempty without throwing &mdash; indeed, 
<tt>weak_ptr::lock()</tt> is marked as <tt>noexcept</tt>.</p>
<p>
We all know what <tt>weak_ptr::lock()</tt> should do, the Standardese just doesn't say it. 
<tt>shared_ptr(const weak_ptr&lt;Y&gt;&amp;)</tt>'s specification is not really affected because 
20.8.2.2.1 [util.smartptr.shared.const]/23-27 describes the behavior with English instead of code.
</p>

<p><i>[Issaquah 20014-10-11: Move to Immediate]</i></p>




<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3691.</p>

<ol>
<li><p>Edit 20.8.2.3.5 [util.smartptr.weak.obs]/5 as indicated:</p>

<blockquote><pre>
shared_ptr&lt;T&gt; lock() const noexcept;
</pre>
<blockquote>
<p>
-5- <i>Returns:</i> <tt>expired() ? shared_ptr&lt;T&gt;() : shared_ptr&lt;T&gt;(*this)</tt><ins>, executed atomically</ins>.
</p>
</blockquote>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="2317"></a>2317. The type property queries should be <tt>UnaryTypeTraits</tt> returning <tt>size_t</tt></h3>
<p><b>Section:</b> 20.10.5 [meta.unary.prop.query] <b>Status:</b> <a href="lwg-active.html#Immediate">Immediate</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2013-09-21 <b>Last modified:</b> 2014-02-12</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Immediate">Immediate</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The sibling sections 20.10.4 [meta.unary], 20.10.6 [meta.rel], and 20.10.7 [meta.trans] respectively specify 
<tt>UnaryTypeTraits</tt>, <tt>BinaryTypeTraits</tt>, and <tt>TransformationTraits</tt>, as stated by each /2 paragraph.  However, 
20.10.5 [meta.unary.prop.query] is underspecified. <tt>alignment_of</tt>, <tt>rank</tt>, and <tt>extent</tt> are said to produce 
"Values", but the type of that Value is not specified, and the struct templates are not required to derive from <tt>integral_constant</tt>.  
Such derivation is more than stylistic &mdash; it allows the structs to be passed to functions taking <tt>integral_constant</tt>.
<p/>
<tt>alignment_of</tt> returns <tt>alignof(T)</tt> which is <tt>size_t</tt> (5.3.6 [expr.alignof]/2). <tt>extent</tt> returns 
an array bound, which is clearly <tt>size_t</tt>. <tt>rank</tt> returns "the number of dimensions" of an array, so any type could 
be chosen, with <tt>size_t</tt> being a reasonable choice. (Another choice would be <tt>unsigned int</tt>, to match <tt>extent</tt>'s 
template parameter <tt>I</tt>.)
</p>

<p><i>[Issaquah 20014-10-11: Move to Immediate]</i></p>




<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3691.</p>

<ol>
<li><p>Following 20.10.5 [meta.unary.prop.query]/1 add a new paragraph as indicated:</p>

<blockquote><p>
<ins>Each of these templates shall be a <tt>UnaryTypeTrait</tt> (20.10.1 [meta.rqmts]) with a <tt>BaseCharacteristic</tt> of 
<tt>integral_constant&lt;size_t, Value&gt;</tt>.</ins>
</p>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="2320"></a>2320. <tt>select_on_container_copy_construction()</tt> takes allocators, not containers</h3>
<p><b>Section:</b> 23.2.1 [container.requirements.general] <b>Status:</b> <a href="lwg-active.html#Immediate">Immediate</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2013-09-21 <b>Last modified:</b> 2014-02-13</p>
<p><b>View other</b> <a href="lwg-index-open.html#container.requirements.general">active issues</a> in [container.requirements.general].</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements.general">issues</a> in [container.requirements.general].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Immediate">Immediate</a> status.</p>
<p><b>Discussion:</b></p>
<p>
23.2.1 [container.requirements.general]/7 says "Copy constructors for these container types obtain an allocator by calling 
<tt>allocator_traits&lt;allocator_type&gt;::select_on_container_copy_construction</tt> on their first parameters."  However, 
20.7.8.2 [allocator.traits.members]/8 says that this takes <tt>const Alloc&amp;</tt>, not a container.  
23.2.1 [container.requirements.general]/7 goes on to say "Move constructors obtain an allocator by move construction from 
the allocator belonging to the container being moved." so we can follow that wording.
</p>

<p><i>[Issaquah 20014-10-11: Move to Immediate]</i></p>




<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3691.</p>

<ol>
<li><p>In 23.2.1 [container.requirements.general]/7 change as indicated:</p>

<blockquote><p>
-7- Unless otherwise specified, all containers defined in this clause obtain memory using an allocator (see 17.6.3.5).
Copy constructors for these container types obtain an allocator by calling 
<tt>allocator_traits&lt;allocator_type&gt;::select_on_container_copy_construction</tt> on <del>their first 
parameters</del><ins>the allocator belonging to the container being copied</ins>. 
Move constructors obtain an allocator by move construction from the allocator belonging to the container being moved. [&hellip;]
</p></blockquote>
</li>

</ol>






<hr>
<h3><a name="2322"></a>2322. Associative(<tt>initializer_list</tt>, stuff) constructors are underspecified</h3>
<p><b>Section:</b> 23.2.4 [associative.reqmts], 23.2.5 [unord.req] <b>Status:</b> <a href="lwg-active.html#Immediate">Immediate</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2013-09-21 <b>Last modified:</b> 2014-02-12</p>
<p><b>View other</b> <a href="lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Immediate">Immediate</a> status.</p>
<p><b>Discussion:</b></p>
<p>
23.2.4 [associative.reqmts] specifies both <tt>X(i,j)</tt> and <tt>X(i,j,c)</tt>, but only <tt>X(il)</tt>.  
23.4.4.1 [map.overview] declares "<tt>map(initializer_list&lt;value_type&gt;, const Compare&amp; = Compare(), 
const Allocator&amp; = Allocator());</tt>" but 23.4.4.2 [map.cons] intentionally doesn't explain it, relying 
on the big table's requirements. As a result, <tt>map(il, c)</tt>'s behavior is not actually specified by the Standard.  
(All of the other ordered associative containers also provide such constructors.)
<p/>
The unordered associative containers are similarly affected, although they have more arguments. (Again, the actual 
containers are correctly depicted with the desired constructors, their behavior just isn't specified.)
</p>

<p><i>[Issaquah 20014-10-11: Move to Immediate]</i></p>




<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3691.</p>

<ol>
<li><p>Edit 23.2.4 [associative.reqmts], Table 102 &mdash; "Associative container requirements", as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 102 &mdash; Associative container requirements (in addition to container) (continued)</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note pre-&#47;post-condition</th>
<th>Complexity</th>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>X(il);</tt>
</td>
<td>
<tt></tt>
</td>
<td>
Same as <tt>X(il.begin(), il.end())</tt>.
</td>
<td>
<del>s</del><ins>S</ins>ame as <tt>X(il.begin(), il.end())</tt>.
</td>
</tr>

<tr>
<td>
<ins><tt>X(il, c);</tt></ins>
</td>
<td>
<tt>&nbsp;</tt>
</td>
<td>
<ins>Same as <tt>X(il.begin(), il.end(), c)</tt>.</ins>
</td>
<td>
<ins>Same as <tt>X(il.begin(), il.end(), c)</tt>.</ins>
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>
</li>

<li><p>Edit 23.2.5 [unord.req], Table 103 "Unordered associative container requirements", as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 103 &mdash; Unordered associative container requirements (in addition to container)</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note pre-&#47;post-condition</th>
<th>Complexity</th>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>X(il)</tt>
</td>
<td>
<tt>X</tt>
</td>
<td>
Same as <tt>X(il.begin(), il.end())</tt>.
</td>
<td>
Same as <tt>X(il.begin(), il.end())</tt>.
</td>
</tr>

<tr>
<td>
<ins><tt>X(il, n)</tt></ins>
</td>
<td>
<ins><tt>X</tt></ins>
</td>
<td>
<ins>Same as <tt>X(il.begin(), il.end(), n)</tt>.</ins>
</td>
<td>
<ins>Same as <tt>X(il.begin(), il.end(), n)</tt>.</ins>
</td>
</tr>

<tr>
<td>
<ins><tt>X(il, n, hf)</tt></ins>
</td>
<td>
<ins><tt>X</tt></ins>
</td>
<td>
<ins>Same as <tt>X(il.begin(), il.end(), n, hf)</tt>.</ins>
</td>
<td>
<ins>Same as <tt>X(il.begin(), il.end(), n, hf)</tt>.</ins>
</td>
</tr>

<tr>
<td>
<ins><tt>X(il, n, hf, eq)</tt></ins>
</td>
<td>
<ins><tt>X</tt></ins>
</td>
<td>
<ins>Same as <tt>X(il.begin(), il.end(), n, hf, eq)</tt>.</ins>
</td>
<td>
<ins>Same as <tt>X(il.begin(), il.end(), n, hf, eq)</tt>.</ins>
</td>
</tr>

<tr>
<td colspan="4" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>

</li>

</ol>






<hr>
<h3><a name="2323"></a>2323. <tt>vector::resize(n, t)</tt>'s specification should be simplified</h3>
<p><b>Section:</b> 23.3.6.3 [vector.capacity], 23.3.3.3 [deque.capacity] <b>Status:</b> <a href="lwg-active.html#Immediate">Immediate</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2013-09-21 <b>Last modified:</b> 2014-02-12</p>
<p><b>View other</b> <a href="lwg-index-open.html#vector.capacity">active issues</a> in [vector.capacity].</p>
<p><b>View all other</b> <a href="lwg-index.html#vector.capacity">issues</a> in [vector.capacity].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Immediate">Immediate</a> status.</p>
<p><b>Discussion:</b></p>
<p>
First, 23.3.3.3 [deque.capacity]/4 and 23.3.6.3 [vector.capacity]/16 say that <tt>resize(size_type sz, const T&amp; c)</tt> 
"<i>Requires:</i> <tt>T</tt> shall be <tt>MoveInsertable</tt> into <tt>*this</tt> and <tt>CopyInsertable</tt> into <tt>*this</tt>."  
The <tt>CopyInsertable</tt> requirement is correct (because <tt>sz</tt> might be <tt>size() + 2</tt> or more), but the 
<tt>MoveInsertable</tt> requirement is redundant due to 23.2.1 [container.requirements.general]/13: "<tt>T</tt> is 
<tt>CopyInsertable</tt> into <tt>X</tt> means that, in addition to <tt>T</tt> being <tt>MoveInsertable</tt> into <tt>X</tt>, the [...]".  
(LWG <a href="lwg-defects.html#2033">2033</a>'s resolution said that this was "not redundant, because <tt>CopyInsertable</tt> is not necessarily a refinement 
of <tt>MoveInsertable</tt>" which was true at the time, but then LWG <a href="lwg-defects.html#2177">2177</a>'s resolution made it a refinement.)
<p/>
Second, 23.3.6.3 [vector.capacity]/17 says "<i>Remarks:</i> If an exception is thrown other than by the move constructor of a 
non-<tt>CopyInsertable</tt> <tt>T</tt> there are no effects." This is confusing because <tt>T</tt> is required to be 
<tt>CopyInsertable</tt>. (/14 says the same thing for <tt>resize(size_type sz)</tt>, where it is correct because that overload 
requires only <tt>MoveInsertable</tt> and <tt>DefaultInsertable</tt>.)
</p>

<p><i>[Issaquah 20014-10-11: Move to Immediate]</i></p>




<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3691.</p>

<ol>
<li><p>Edit 23.3.3.3 [deque.capacity]/4 as indicated:</p>

<blockquote><pre>
void resize(size_type sz, const T&amp; c);
</pre><blockquote>
<p>
[&hellip;]
<p/>
-4- <i>Requires:</i> <tt>T</tt> shall be <del><tt>MoveInsertable</tt> into <tt>*this</tt> and</del> <tt>CopyInsertable</tt> into 
<tt>*this</tt>.
</p>
</blockquote></blockquote>
</li>

<li><p>Edit 23.3.6.3 [vector.capacity]/16+17 as indicated:</p>

<blockquote><pre>
void resize(size_type sz, const T&amp; c);
</pre><blockquote>
<p>
[&hellip;]
<p/>
-16- <i>Requires:</i> <tt>T</tt> shall be <del><tt>MoveInsertable</tt> into <tt>*this</tt> and</del> <tt>CopyInsertable</tt> into 
<tt>*this</tt>.
<p/>
-17- <i>Remarks:</i> If an exception is thrown <del>other than by the move constructor of a non-<tt>CopyInsertable</tt> <tt>T</tt></del> 
there are no effects.
</p>
</blockquote></blockquote>
</li>

</ol>






<hr>
<h3><a name="2324"></a>2324. Insert iterator constructors should use <tt>addressof()</tt></h3>
<p><b>Section:</b> 24.5.2.2.1 [back.insert.iter.cons], 24.5.2.4.1 [front.insert.iter.cons], 24.5.2.6.1 [insert.iter.cons] <b>Status:</b> <a href="lwg-active.html#Immediate">Immediate</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2013-09-21 <b>Last modified:</b> 2014-02-12</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Immediate">Immediate</a> status.</p>
<p><b>Discussion:</b></p>
<p>
24.5.2.2.1 [back.insert.iter.cons]/1, 24.5.2.4.1 [front.insert.iter.cons]/1, and 24.5.2.6.1 [insert.iter.cons]/1 
say "Initializes container with <tt>&amp;x</tt>", which doesn't defend against containers overloading <tt>operator&amp;()</tt>.  
Containers are now required to have such defenses for their elements, so we may as well be consistent here.
</p>

<p><i>[Issaquah 20014-10-11: Move to Immediate]</i></p>




<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3691.</p>

<ol>
<li><p>Edit 24.5.2.2.1 [back.insert.iter.cons]/1 as indicated:</p>

<blockquote><pre>
explicit back_insert_iterator(Container&amp; x);
</pre><blockquote>
<p>
-1- <i>Effects:</i> Initializes <tt>container</tt> with <tt><del>&amp;x</del><ins>std::addressof(x)</ins></tt>.
</p>
</blockquote></blockquote>
</li>

<li><p>Edit 24.5.2.4.1 [front.insert.iter.cons]/1 as indicated:</p>

<blockquote><pre>
explicit front_insert_iterator(Container&amp; x);
</pre><blockquote>
<p>
-1- <i>Effects:</i> Initializes <tt>container</tt> with <tt><del>&amp;x</del><ins>std::addressof(x)</ins></tt>.
</p>
</blockquote></blockquote>
</li>

<li><p>Edit 24.5.2.6.1 [insert.iter.cons]/1 as indicated:</p>

<blockquote><pre>
insert_iterator(Container&amp; x, typename Container::iterator i);
</pre><blockquote>
<p>
-1- <i>Effects:</i> Initializes <tt>container</tt> with <tt><del>&amp;x</del><ins>std::addressof(x)</ins></tt> and <tt>iter</tt> with <tt>i</tt>.
</p>
</blockquote></blockquote>
</li>

</ol>






<hr>
<h3><a name="2330"></a>2330. <tt>regex("meow", regex::icase)</tt> is technically forbidden but should be permitted</h3>
<p><b>Section:</b> 28.5.1 [re.synopt] <b>Status:</b> <a href="lwg-active.html#Immediate">Immediate</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2013-09-21 <b>Last modified:</b> 2014-02-13</p>
<p><b>View other</b> <a href="lwg-index-open.html#re.synopt">active issues</a> in [re.synopt].</p>
<p><b>View all other</b> <a href="lwg-index.html#re.synopt">issues</a> in [re.synopt].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Immediate">Immediate</a> status.</p>
<p><b>Discussion:</b></p>
<p>
28.5.1 [re.synopt]/1 says "A valid value of type <tt>syntax_option_type</tt> shall have exactly one of the elements 
<tt>ECMAScript</tt>, <tt>basic</tt>, <tt>extended</tt>, <tt>awk</tt>, <tt>grep</tt>, <tt>egrep</tt>, set." 
<p/>
This "exactly one" wording technically forbids passing <tt>icase</tt> by itself! Users should not be required to pass 
<tt>regex::ECMAScript | regex::icase</tt>. (Note that the cost of an additional check for no grammar being explicitly requested 
is completely irrelevant, as regex construction is so much more expensive.)
</p>

<p><i>[Issaquah 20014-10-11: Move to Immediate]</i></p>




<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3691.</p>

<ol>
<li><p>Edit 28.5.1 [re.synopt] as indicated:</p>

<blockquote><p>
-1- The type <tt>syntax_option_type</tt> is an implementation-defined bitmask type (17.5.2.1.3). Setting its elements
has the effects listed in table 138. A valid value of type <tt>syntax_option_type</tt> shall have <del>exactly</del><ins>at most</ins> 
one of the <ins>grammar</ins> elements <tt>ECMAScript</tt>, <tt>basic</tt>, <tt>extended</tt>, <tt>awk</tt>, <tt>grep</tt>, 
<tt>egrep</tt>, set. <ins> If no grammar element is set, the default grammar is <tt>ECMAScript</tt>.</ins>
</p></blockquote>
</li>
</ol>





<hr>
<h3><a name="2339"></a>2339. Wording issue in <tt>nth_element</tt></h3>
<p><b>Section:</b> 25.4.2 [alg.nth.element] <b>Status:</b> <a href="lwg-active.html#Immediate">Immediate</a>
 <b>Submitter:</b> Christopher Jefferson <b>Opened:</b> 2013-10-19 <b>Last modified:</b> 2014-02-12</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.nth.element">issues</a> in [alg.nth.element].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Immediate">Immediate</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The wording of <tt>nth_element</tt> says:
</p>
<blockquote><pre>
template&lt;class RandomAccessIterator&gt;
  void nth_element(RandomAccessIterator first, RandomAccessIterator nth,
                   RandomAccessIterator last);
</pre><blockquote>
<p>
After <tt>nth_element</tt> the element in the position pointed to by <tt>nth</tt> is the element that would be in that
position if the whole range were sorted. Also for every iterator <tt>i</tt> in the range <tt>[first,nth)</tt> and every
iterator <tt>j</tt> in the range <tt>[nth,last)</tt> it holds that: <tt>!(*j &lt; *i)</tt> or <tt>comp(*j, *i) == false</tt>.
</p>
</blockquote></blockquote>
<p>
That wording, to me, implies that there must be an element at '<tt>nth</tt>'.
However, gcc at least accepts <tt>nth == last</tt>, and returns without effect
(which seems like the sensible option).
<p/>
Is it intended to accept <tt>nth == last</tt>? If so, then I would suggest adding
this to the wording explicitly, say:
</p>
<blockquote>
<p>
After <tt>nth_element</tt> the element in the position pointed to by <tt>nth</tt><ins>, if any,</ins> is the element that
would be in that position if the whole range were sorted. Also for every iterator <tt>i</tt> in the range <tt>[first,nth)</tt>
and every iterator <tt>j</tt> in the range <tt>[nth,last)</tt> it holds that: <tt>!(*j &lt; *i)</tt> or <tt>comp(*j, *i) == false</tt>.
</p>
</blockquote>

<p><i>[Issaquah 20014-10-11: Move to Immediate]</i></p>




<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3797.</p>

<ol>
<li><p>Modify 25.4.2 [alg.nth.element]/1 as indicated:</p>

<blockquote><pre>
template&lt;class RandomAccessIterator&gt;
  void nth_element(RandomAccessIterator first, RandomAccessIterator nth,
                   RandomAccessIterator last);
template&lt;class RandomAccessIterator, class Compare&gt;
  void nth_element(RandomAccessIterator first, RandomAccessIterator nth,
                   RandomAccessIterator last, Compare comp);
</pre><blockquote>
<p>
-1- After <tt>nth_element</tt> the element in the position pointed to by <tt>nth</tt> is the element that would be in that
position if the whole range were sorted<ins>, unless <tt>nth == last</tt></ins>. Also for every iterator <tt>i</tt> in the 
range <tt>[first,nth)</tt> and every iterator <tt>j</tt> in the range <tt>[nth,last)</tt> it holds that: <tt>!(*j &lt; *i)</tt> 
or <tt>comp(*j, *i) == false</tt>.
</p>
</blockquote></blockquote>
</li>

</ol>





<hr>
<h3><a name="2341"></a>2341. Inconsistency between <tt>basic_ostream::seekp(pos)</tt> and <tt>basic_ostream::seekp(off, dir)</tt></h3>
<p><b>Section:</b> 27.7.3.5 [ostream.seeks] <b>Status:</b> <a href="lwg-active.html#Immediate">Immediate</a>
 <b>Submitter:</b> Marshall Clow  <b>Opened:</b> 2013-10-21 <b>Last modified:</b> 2014-02-12</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Immediate">Immediate</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 27.7.3.5 [ostream.seeks], we have:
</p>
<blockquote><pre>
basic_ostream&lt;charT,traits&gt;&amp; seekp(pos_type pos);
</pre><blockquote>
<p>
-3- <i>Effects:</i> If <tt>fail() != true</tt>, executes <tt>rdbuf()-&gt;pubseekpos(pos, ios_base::out)</tt>. In case of failure, 
the function calls <tt>setstate(failbit)</tt> (which may throw <tt>ios_base::failure</tt>).
<p/>
-4- <i>Returns:</i> <tt>*this</tt>.
</p>
</blockquote></blockquote>
<blockquote><pre>
basic_ostream&lt;charT,traits&gt;&amp; seekp(off_type off, ios_base::seekdir dir);
</pre><blockquote>
<p>
-5- <i>Effects:</i> If <tt>fail() != true</tt>, executes <tt>rdbuf()-&gt;pubseekoff(off, dir, ios_base::out)</tt>.
<p/>
-6- <i>Returns:</i> <tt>*this</tt>.
</p>
</blockquote></blockquote>
<p>
The first call is required to set the <tt>failbit</tt> on failure, but the second is not
<p/>
So (given two ostreams, <tt>os1</tt> and <tt>os2</tt>) the following code (confusingly) works:
</p>
<blockquote><pre>
os1.seekp(-1);
assert(os1.fail());

os2.seekp(-1, std::ios_base::beg);
assert(os2.good());
</pre></blockquote>
<p>
Note that the description of <tt>basic_istream&lt;charT,traits&gt;&amp; seekg(off_type off, ios_base::seekdir dir)</tt> in 
27.7.2.3 [istream.unformatted] p43 <em>does</em> require setting <tt>failbit</tt>.
</p>

<p><i>[Issaquah 20014-10-11: Move to Immediate]</i></p>




<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3797.</p>

<ol>
<li><p>Modify 27.7.3.5 [ostream.seeks]p5 as indicated:</p>

<blockquote><pre>
basic_ostream&lt;charT,traits&gt;&amp; seekp(off_type off, ios_base::seekdir dir);
</pre><blockquote>
<p>
-5- <i>Effects:</i> If <tt>fail() != true</tt>, executes <tt>rdbuf()-&gt;pubseekoff(off, dir, ios_base::out)</tt>.
<ins>In case of failure, the function calls <tt>setstate(failbit)</tt> (which may throw <tt>ios_base::failure</tt>).</ins>
<p/>
-6- <i>Returns:</i> <tt>*this</tt>.
</p>
</blockquote></blockquote>
</li>

</ol>





<hr>
<h3><a name="2346"></a>2346. <tt>integral_constant</tt>'s member functions should be marked <tt>noexcept</tt></h3>
<p><b>Section:</b> 20.10.3 [meta.help] <b>Status:</b> <a href="lwg-active.html#Immediate">Immediate</a>
 <b>Submitter:</b> Stephan T. Lavavej <b>Opened:</b> 2013-11-05 <b>Last modified:</b> 2014-02-12</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.help">issues</a> in [meta.help].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Immediate">Immediate</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Obvious.
</p>

<p><i>[Issaquah 20014-10-11: Move to Immediate]</i></p>




<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3797.</p>

<ol>
<li><p>Edit 20.10.3 [meta.help] as indicated:</p>

<blockquote><pre>
namespace std {
  template&lt;class T, T v&gt;
  struct integral_constant {
    static constexpr T value = v;
    typedef T value_type;
    typedef integral_constant&lt;T,v&gt; type;
    constexpr operator value_type() const <ins>noexcept</ins> { return value; }
    constexpr value_type operator()() const <ins>noexcept</ins> { return value; }
  };
  [&hellip;]
}
</pre></blockquote>
</li>

</ol>






<hr>
<h3><a name="2350"></a>2350. <tt>min</tt>, <tt>max</tt>, and <tt>minmax</tt> should be <tt>constexpr</tt></h3>
<p><b>Section:</b> 25.4.7 [alg.min.max] <b>Status:</b> <a href="lwg-active.html#Immediate">Immediate</a>
 <b>Submitter:</b> Ville Voutilainen <b>Opened:</b> 2013-12-15 <b>Last modified:</b> 2014-02-12</p>
<p><b>View other</b> <a href="lwg-index-open.html#alg.min.max">active issues</a> in [alg.min.max].</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.min.max">issues</a> in [alg.min.max].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Immediate">Immediate</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Having <tt>min</tt>, <tt>max</tt>, and <tt>minmax</tt> <tt>constexpr</tt> 
was a large part of the motivation to allow reference-to-const arguments for 
<tt>constexpr</tt> functions as per 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3039.pdf">N3039</a>.
Furthermore, <tt>initializer_lists</tt> are immutable and not-movable-from
for large part in order to allow using them in <tt>constexpr</tt> contexts
and other hoisting-optimizations. In <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf">N3797</a> 
version of the draft none of these functions are <tt>constexpr</tt>, and they should be made
<tt>constexpr</tt>.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3797.</p>

<ol>
<li><p>In 25.1 [algorithms.general], header <tt>&lt;algorithm&gt;</tt> synopsis, and 25.4.7 [alg.min.max], 
change as indicated (add <tt>constexpr</tt> to every signature before <tt>min_element</tt>):</p>

<blockquote><pre>
template&lt;class T&gt; <ins>constexpr</ins> const T&amp; min(const T&amp; a, const T&amp; b);
template&lt;class T, class Compare&gt;
<ins>constexpr</ins> const T&amp; min(const T&amp; a, const T&amp; b, Compare comp);
[&hellip;]
template&lt;class T&gt;
<ins>constexpr</ins> T min(initializer_list&lt;T&gt; t);
template&lt;class T, class Compare>
<ins>constexpr</ins> T min(initializer_list&lt;T&gt; t, Compare comp);
[&hellip;]
template&lt;class T&gt; <ins>constexpr</ins> const T&amp; max(const T&amp; a, const T&amp; b);
template&lt;class T, class Compare&gt;
<ins>constexpr</ins> const T&amp; max(const T&amp; a, const T&amp; b, Compare comp);
[&hellip;]
template&lt;class T&gt;
<ins>constexpr</ins> T max(initializer_list&lt;T&gt; t);
template&lt;class T, class Compare>
<ins>constexpr</ins> T max(initializer_list&lt;T&gt; t, Compare comp);
[&hellip;]
template&lt;class T&gt; <ins>constexpr</ins> pair&lt;const T&amp;, const T&amp;&gt; minmax(const T&amp; a, const T&amp; b);
template&lt;class T, class Compare&gt;
<ins>constexpr</ins> pair&lt;const T&amp;, const T&amp;&gt; minmax(const T&amp; a, const T&amp; b, Compare comp);
[&hellip;]
template&lt;class T&gt;
<ins>constexpr</ins> pair&lt;T, T&gt; minmax(initializer_list&lt;T&gt; t);
template&lt;class T, class Compare>
<ins>constexpr</ins> pair&lt;T, T&gt; minmax(initializer_list&lt;T&gt; t, Compare comp);
</pre></blockquote>
</li>

</ol>






<hr>
<h3><a name="2357"></a>2357. Remaining "<tt>Assignable</tt>" requirement</h3>
<p><b>Section:</b> 25.3.13 [alg.partitions] <b>Status:</b> <a href="lwg-active.html#Immediate">Immediate</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2014-02-01 <b>Last modified:</b> 2014-02-12</p>
<p><b>View all other</b> <a href="lwg-index.html#alg.partitions">issues</a> in [alg.partitions].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Immediate">Immediate</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <i>Requires</i> element of <tt>partition_copy</tt> says (emphasis mine):
</p>
<blockquote><p>
<i>Requires</i>: <tt>InputIterator</tt>'s value type shall be <b><tt>Assignable</tt></b>, and &hellip;
</p></blockquote>
<p>
The C++03 term <tt>Assignable</tt> was replaced by <tt>CopyAssignable</tt>, remaining cleanups happened via LWG issue
<a href="lwg-closed.html#972">972</a>, but algorithm <tt>partition_copy</tt> was not affected at that time (during that time the requirements
of <tt>partition_copy</tt> didn't mention writable nor assignable, but I cannot track down at the moment where these requirements
had been added). Presumably this requirement should be corrected similarly to the approach used in <a href="lwg-closed.html#972">972</a>.
<p/>
Another question is whether a <tt>CopyAssignable</tt> is needed here, given the fact that we already require "writable to" an 
<tt>OutputIterator</tt> which is defined in 24.2.1 [iterator.requirements.general] and does already impose the necessary
statement
</p>
<blockquote><pre>
*out = *in;
</pre></blockquote>
<p>
Given the fact that <tt>partition_copy</tt> never touches any input value twice, there is no reason why anything more than
<i>writable to</i> should be necessary.
<p/>
The below suggested primary resolution does not respond to the second part of this question.
</p>

<p><i>[Issaquah 20014-10-11: Move to Immediate]</i></p>




<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3797.</p>

<ol>
<li><p>Modify 25.3.13 [alg.partitions], p12 as indicated:</p>

<blockquote><p>
-12- <i>Requires</i>: <tt>InputIterator</tt>'s value type shall be <tt><ins>Copy</ins>Assignable</tt>, and shall be writable 
to the <tt>out_true</tt> and <tt>out_false</tt> <tt>OutputIterator</tt>s, and shall be convertible to <tt>Predicate</tt>'s 
argument type. The input range shall not overlap with either of the output ranges.
</p></blockquote>
</li>
</ol>





<hr>
<h3><a name="2359"></a>2359. How does <tt>regex_constants::nosubs</tt> affect <tt>basic_regex::mark_count()</tt>?</h3>
<p><b>Section:</b> 28.5.1 [re.synopt] <b>Status:</b> <a href="lwg-active.html#Immediate">Immediate</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2014-02-01 <b>Last modified:</b> 2014-02-12</p>
<p><b>View other</b> <a href="lwg-index-open.html#re.synopt">active issues</a> in [re.synopt].</p>
<p><b>View all other</b> <a href="lwg-index.html#re.synopt">issues</a> in [re.synopt].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Immediate">Immediate</a> status.</p>
<p><b>Discussion:</b></p>
<p>
As discussed in <a href="http://accu.org/cgi-bin/wg21/message?wg=lib&amp;msg=35399">c++std-lib-35399</a> and its replies, 
I can see two possible interpretations of the effects of <tt>regex_constants::nosubs</tt>:
</p>
<ol style="list-style-type:decimal">
<li><p>
The effect of <tt>nosubs</tt> only applies during matching. Parentheses are
still recognized as marking a sub-expression by the <tt>basic_regex</tt>
compiler, and <tt>basic_regex::mark_count()</tt> still returns the number of
marked sub-expressions, but anything they match is not stored in the
results. This means it is not always true that <tt>results.size() == r.mark_count() + 1</tt> 
for a successful match.
</p></li>
<li><p>
<tt>nosubs</tt> affects how a regular expression is compiled, altering the
state of the <tt>std::basic_regex</tt> object so that <tt>mark_count()</tt> returns
zero. This also affects any subsequent matching.
</p></li>
</ol>
<p>
The definition of <tt>nosubs</tt> should make this clear.
<p/>
The wording in 28.5.1 [re.synopt]/1 seems to imply that <tt>nosubs</tt> only has
effects during matching, which is (1), but all known implementations
do (2). John Maddock confirmed that (2) was intended.
</p>

<p><i>[Issaquah 20014-10-11: Move to Immediate]</i></p>




<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3797.</p>

<ol>
<li><p>Apply the following edit to the table in 28.5.1 [re.synopt]/1</p>

<blockquote><p>
Specifies that <ins>no sub-expressions shall be considered to be
marked, so that</ins> when a regular expression is matched against a character container
sequence, no sub-expression matches shall be stored in the supplied
<tt>match_results</tt> structure.
</p></blockquote>
</li>
</ol>






</body>
</html>
