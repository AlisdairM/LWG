<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>C++ Standard Library Issues Resolved Directly In [INSERT CURRENT MEETING HERE]</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
</style>
</head>
<body>
<p>Revised 2013-09-26 at 17:09:45 UTC</p>
<h2>Immediate Issues</h2>
<hr>
<h3><a name="2097"></a>2097. <tt>packaged_task</tt> constructors should be constrained</h3>
<p><b>Section:</b> 30.6.9.1 [futures.task.members] <b>Status:</b> <a href="lwg-active.html#Immediate">Immediate</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2011-11-02 <b>Last modified:</b> 2013-09-26</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures.task.members">active issues</a> in [futures.task.members].</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.task.members">issues</a> in [futures.task.members].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Immediate">Immediate</a> status.</p>
<p><b>Discussion:</b></p>

<p>
With the proposed resolution of <a href="lwg-defects.html#2067">2067</a>, this no longer selects the
copy constructor:
</p>
<blockquote><pre>
std::packaged_task&lt;void()&gt; p1;
std::packaged_task&lt;void()&gt; p2(p1);
</pre></blockquote>
<p>
Instead this constructor is a better match:
</p>
<blockquote><pre>
template &lt;class F&gt;
 explicit packaged_task(F&amp;&amp; f);
</pre></blockquote>
<p>
This attempts to package a <tt>packaged_task</tt>, which internally tries to
copy <tt>p2</tt>, which fails because the copy constructor is deleted. For at
least one implementation the resulting error message is much less
helpful than the expected "cannot call deleted function" because it
happens after instantiating several more templates rather than in the
context where the constructor is called.
<p/>
I believe the solution is to constrain to the template constructors so
the template argument <tt>F</tt> cannot be deduced as (possibly <i>cv</i>)
<tt>packaged_task&amp;</tt> or <tt>packaged_task</tt>.  It could be argued 
this constraint is already implied because <tt>packaged_task</tt> is not 
copyable and the template constructors require that "invoking a copy of <tt>f</tt> 
shall behave the same as invoking <tt>f</tt>".
<p/>
Daniel points out that the variadic constructor of <tt>std::thread</tt>
described in 30.3.1.2 [thread.thread.constr] has a similar problem and 
suggests a similar wording change, which has been integrated below.
<p/>
An alternative is to declare <tt>thread(thread&amp;)</tt> and
<tt>packaged_task(packaged_task&amp;)</tt> as deleted.
</p>

<p><i>[2012, Portland]</i></p>

<p>
This issue appears to be more about library specification than technical
concurrency issues, so should be handled in LWG.
</p>


<p><i>[2012, Portland]</i></p>

<p>
Move to Immediate resolution.
</p>
<p>
Howard volunteered existing implementation experience with the first change, and saw no issue that the second would introduce any new issue.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS.</p>

<ol>
<li><p>Insert a new Remarks element to 30.3.1.2 [thread.thread.constr] around p3 as indicated:</p>

<blockquote><pre>
template &lt;class F, class ...Args&gt; explicit thread(F&amp;&amp; f, Args&amp;&amp;... args);
</pre></blockquote>
<p>
-3- <i>Requires</i>: <tt>F</tt> and each <tt>Ti</tt> in <tt>Args</tt> shall satisfy the <tt>MoveConstructible</tt> 
requirements. <tt><i>INVOKE</i>(<i>DECAY_COPY</i> ( std::forward&lt;F&gt;(f)), <i>DECAY_COPY</i> (std::forward&lt;Args&gt;(args))...)</tt> 
(20.8.2) shall be a valid expression.
<p/>
<ins>-?- <i>Remarks</i>: This constructor shall not participate in overload resolution if <tt>decay&lt;F&gt;::type</tt> 
is the same type as <tt>std::thread</tt>.</ins>
</p>
</li>

<li><p>Insert a new Remarks element to 30.6.9.1 [futures.task.members] around p2 as indicated:</p>

<blockquote><pre>
template &lt;class F&gt;
  packaged_task(F&amp;&amp; f);
template &lt;class F, class Allocator&gt;
  explicit packaged_task(allocator_arg_t, const Allocator&amp; a, F&amp;&amp; f);
</pre></blockquote>
<p>
-2- <i>Requires</i>: <tt><i>INVOKE</i>(f, t1, t2, ..., tN, R)</tt>, where <tt>t1, t2, ..., tN</tt> are values of the corresponding
types in <tt>ArgTypes...</tt>, shall be a valid expression. Invoking a copy of <tt>f</tt> shall behave the same as invoking <tt>f</tt>.
<p/>
<ins>-?- <i>Remarks</i>: These constructors shall not participate in overload resolution if <tt>decay&lt;F&gt;::type</tt> 
is the same type as <tt>std::packaged_task&lt;R(ArgTypes...)&gt;</tt>.</ins>
</p>
</li>

</ol>






<hr>
<h3><a name="2275"></a>2275. [CD] Why is <tt>forward_as_tuple</tt> not <tt>constexpr</tt>?</h3>
<p><b>Section:</b> 20.4.2.4 [tuple.creation] <b>Status:</b> <a href="lwg-active.html#Immediate">Immediate</a>
 <b>Submitter:</b> Marshall Clow <b>Opened:</b> 2013-07-30 <b>Last modified:</b> 2013-09-25</p>
<p><b>View all other</b> <a href="lwg-index.html#tuple.creation">issues</a> in [tuple.creation].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Immediate">Immediate</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses ES 11</b></p>

<p>
In <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3471.html">n3471</a>, a bunch of routines 
from header <tt>&lt;tuple&gt;</tt> were made <tt>constexpr</tt>.
<p/>
<tt>make_tuple/tuple_cat/get&lt;&gt;(tuple)/</tt>relational operators &mdash; all these were "constexpr-ified".
<p/>
But not <tt>forward_as_tuple</tt>.
<p/>
Why not?
<p/>
This was discussed in Portland, and STL opined that this was "an omission" (along with <tt>tuple_cat</tt>, which was added)
<p/>
In discussion on c++std-lib@accu.org list, Pablo agreed that <tt>forward_as_tuple</tt> should be <tt>constexpr</tt>.
</p>

<p><i>[2013-09 Chicago]</i></p>

<p>
Moved to Immediate, this directly addresses an NB comment and the wording is non-controversial.
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3691.</p>

<ol>
<li><p>Change header <tt>&lt;tuple&gt;</tt> synopsis, 20.4.1 [tuple.general] as indicated:</p>

<blockquote>
<pre>
template &lt;class... Types&gt;
  <ins>constexpr</ins> tuple&lt;Types&amp;&amp;...&gt; forward_as_tuple(Types&amp;&amp;...) noexcept;
</pre>
</blockquote>
</li>

<li><p>Change 20.4.2.4 [tuple.creation] before p5 as indicated:</p>

<blockquote>
<pre>
template &lt;class... Types&gt;
  <ins>constexpr</ins> tuple&lt;Types&amp;&amp;...&gt; forward_as_tuple(Types&amp;&amp;... t) noexcept;
</pre>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2284"></a>2284. Inconsistency in <tt>allocator_traits::max_size</tt></h3>
<p><b>Section:</b> 20.8.8 [allocator.traits] <b>Status:</b> <a href="lwg-active.html#Immediate">Immediate</a>
 <b>Submitter:</b> Marshall Clow <b>Opened:</b> 2013-08-27 <b>Last modified:</b> 2013-09-26</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Immediate">Immediate</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Section 20.8.8 [allocator.traits] says:
</p>
<blockquote><pre>
static size_type max_size(const Alloc&amp; a) noexcept;
</pre></blockquote>
<p>
Section 20.8.8.2 [allocator.traits.members] says:
</p>
<blockquote><pre>
static size_type max_size(Alloc&amp; a) noexcept;
</pre></blockquote>

<p>
These should be the same.
</p>

<p>
Discussion:
</p>

<p>
Pablo (who I believe wrote the <tt>allocator_traits</tt> proposal) says "The function should take a <tt>const</tt> reference."
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3691.</p>

<ol>
<li><p>Change 20.8.8.2 [allocator.traits.members] as follows:</p>

<blockquote><pre>
static size_type max_size(<ins>const</ins> Alloc&amp; a) noexcept;
</pre>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="2298"></a>2298. [CD] <tt>is_nothrow_constructible</tt> is always false because of <tt>create&lt;&gt;</tt></h3>
<p><b>Section:</b> 20.11.4.3 [meta.unary.prop] <b>Status:</b> <a href="lwg-active.html#Immediate">Immediate</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2013-09-24 <b>Last modified:</b> 2013-09-26</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.unary.prop">active issues</a> in [meta.unary.prop].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.unary.prop">issues</a> in [meta.unary.prop].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Immediate">Immediate</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US 18</b></p>

<p>
The trait <tt>is_constructible&lt;T, Args...&gt;</tt> is defined in terms of a helper template, <tt>create&lt;&gt;</tt>, 
that is identical to <tt>std::declval&lt;&gt;</tt> except for the latter's <tt>noexcept</tt> clause.   
<p/>
If the absence of <tt>noexcept</tt> is critical to this definition, insert a Note of explanation; otherwise, excise 
<tt>create&lt;&gt;</tt> and reformulate in terms of <tt>declval&lt;&gt;</tt> the definition of <tt>is_constructible</tt>. 
</p>

<p><i>[2013-09-24 Daniel comments and provides resolution suggestion]</i></p>


<p>
Replacing <tt>create&lt;&gt;</tt> by <tt>std::declval&lt;&gt;</tt> would make the situation worse, because the definition of
<tt>is_constructible</tt> is based on a well-formed variable definition and there is no way to specify a variable definition
without odr-using its initializer arguments. It should also be added, that there is another problem with the specification of
all existing <tt>is_trivially_*</tt> traits, because neither <tt>create&lt;&gt;</tt> nor <tt>std::declval&lt;&gt;</tt>
are considered as trivial functions, but this should be solved by a different issue.
</p>

<p><i>[2013-09-26 Nico improves wording]</i></p>


<p>
The additional change is just to keep both places were <tt>create()</tt> is defined consistent.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3691.</p>

<ol>
<li><p>Change 20.11.4.3 [meta.unary.prop] around p6 as indicated:</p>

<blockquote><p>
-6- Given the following function prototype:
</p>
<blockquote><pre>
template &lt;class T&gt;
  typename add_rvalue_reference&lt;T&gt;::type create() <ins>noexcept</ins>;
</pre></blockquote>
<p>
the predicate condition for a template specialization <tt>is_constructible&lt;T, Args...&gt;</tt> shall be satisfied
if and only if the following variable definition would be well-formed for some invented variable <tt>t</tt>:
</p>
<blockquote><pre>
T t(create&lt;Args&gt;()...);
</pre></blockquote>
<p>
[&hellip;]
</p>
</blockquote>
</li>

<li><p>Change 20.11.4.3 [meta.unary.prop] around p4 as indicated:</p>

<blockquote><p>
-4- Given the following function prototype:
</p>
<blockquote><pre>template &lt;class T&gt;
  typename add_rvalue_reference&lt;T&gt;::type create() <ins>noexcept</ins>;
</pre></blockquote>
<p>
the predicate condition for a template specialization <tt>is_convertible&lt;From, To&gt;</tt> shall be satisfied if and
only if the return expression in the following code would be well-formed, including any implicit conversions
to the return type of the function:
</p>
<blockquote><pre>
To test() {
  return create&lt;From&gt;();
}
</pre></blockquote>
<p>
[&hellip;]
</p>
</blockquote>
</li>

</ol>





</body>
</html>
