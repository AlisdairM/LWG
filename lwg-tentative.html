<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>C++ Standard Library Tentative Issues</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
</style>
</head>
<body>
<p>Revised 2013-04-19 at 22:04:36 UTC</p>
<h2>Tentative Issues</h2>
<hr>
<h3><a name="2078"></a>2078. Throw specification of <tt>async()</tt> incomplete</h3>
<p><b>Section:</b> 30.6.8 [futures.async] <b>Status:</b> <a href="lwg-active.html#NAD Editorial">Tentatively NAD Editorial</a>
 <b>Submitter:</b> Nicolai Josuttis <b>Opened:</b> 2011-08-29 <b>Last modified:</b> 2012-12-23</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures.async">active issues</a> in [futures.async].</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.async">issues</a> in [futures.async].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD Editorial">Tentatively NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The current throw specification of <tt>async()</tt> does state:
</p>
<blockquote><p>
-6- <i>Throws</i>: <tt>system_error</tt> if policy is <tt>launch::async</tt> and 
the implementation is unable to start a new thread.
</p></blockquote>
<p>
First it seems not clear whether this only applies if policy equals 
<tt>launch::async</tt> of if the <tt>async</tt> launch mode flag is set 
(if <tt>policy|launch::async!=0</tt>)
<p/>
In the discussion Lawrence Crowl also wrote:
</p>
<blockquote><p>
    More generally, I think what we want to say is that if the
    implementation cannot successfully execute on one of the policies
    allowed, then it must choose another. The principle would apply
    to implementation-defined policies as well.
</p></blockquote>

<p>
Peter Sommerlad:
</p>
<blockquote><p>
Should not throw. That was the intent. "is async" meat exactly.
</p></blockquote>

<p><i>[2012, Portland: move to Tentatively NAD Editorial]</i></p>

<p>
If no launch policy, it is undefined behavior.
</p>
<p>
Agree with Lawrence, should try all the allowed policies. We will rephrase so that
the policy argument should be <tt>lauch::async</tt>. Current wording seems good enough.
</p>
<p>
We believe this choice of policy statement is really an editorial issue.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2080"></a>2080. Specify when <tt>once_flag</tt> becomes invalid</h3>
<p><b>Section:</b> 30.4.4 [thread.once] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Nicolai Josuttis <b>Opened:</b> 2011-08-30 <b>Last modified:</b> 2012-12-23</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p>
In function <tt>call_once</tt> 30.4.4.2 [thread.once.callonce]
paragraph 4 and 5 specify for <tt>call_once()</tt>:
</p>

<blockquote>
<p>
<i>Throws</i>: <tt>system_error</tt> when an exception is required (30.2.2 [thread.req.exception]), 
or any exception thrown by <tt>func</tt>.
<p/>
<i>Error conditions</i>:
</p>
<ul>
<li><tt>invalid_argument</tt> &mdash; if the <tt>once_flag</tt> object is no longer valid.</li>
</ul>
</blockquote>

<p>
However, nowhere in 30.4.4 [thread.once] is specified, when a once-flag becomes invalid.
<p/>
As far as I know this happens if the flag is used for different functions. So we either have to have 
to insert a sentence&#47;paragraph in
</p>
<blockquote><p>
30.4.4.2 Function call_once [thread.once.callonce]
</p></blockquote>
<p>
or
</p>
<blockquote><p>
30.4.4 Call once [thread.once]
</p></blockquote>
<p>
explaining when a <tt>once_flag</tt> becomes invalidated or we should state as error condition something like:
</p>

<ul>
<li><tt>invalid_argument</tt> &mdash; if the <tt>func</tt> used in combination with the <tt>once_flag</tt> is different 
from a previously passed <tt>func</tt> for the same <tt>once_flag</tt>
</li>
</ul>

<p>
Anthony Williams:
</p>
<blockquote>
<p>
A <tt>once_flag</tt> is invalidated if you destroy it (e.g. it is an automatic object, or heap 
allocated and deleted, etc.)
<p/>
If the library can detect that this is the case then it will throw this exception. If it cannot 
detect such a case then it will never be thrown.
</p>
</blockquote>

<p>
Jonathan Wakely:
</p>
<blockquote>
<p>
I have also wondered how that error can happen in C++, where the type
system will reject a non-callable type being passed to <tt>call_once()</tt> and
should prevent a <tt>once_flag</tt> being used after its destructor runs.
<p/>
If a <tt>once_flag</tt> is used after its destructor runs then it is indeed
undefined behaviour, so implementations are already free to throw any
exception (or set fire to a printer) without the standard saying so.
<p/>
My assumption was that it's an artefact of basing the API on pthreads,
which says:
</p>
<blockquote>
<p>
The <tt>pthread_once()</tt> function may fail if:
<p/>
<tt>[EINVAL]</tt>  If either <tt>once_control</tt> or <tt>init_routine</tt> is invalid.
</p>
</blockquote>
</blockquote>

<p>
Pete Becker:
</p>
<blockquote><p>
Yes, probably. We had to clean up several UNIXisms that were in the original design.
</p></blockquote>

<p><i>[2012, Kona]</i></p>

<p>
Remove error conditions, move to Review.
</p>

<p><i>[2012, Portland: move to Tentatively Ready]</i></p>

<p>
Concurrency move to Ready, pending LWG review.
</p>

<p>
LWG did not have time to perform the final review in Portland, so moving to
<i>tentatively</i> ready to reflect the Concurrency belief that the issue is
ready, but could use a final inspection from library wordsmiths.
</p>



<p><b>Proposed resolution:</b></p>

<p>This wording is relative to N3337.</p>

<ol>
<li><p>Change 30.4.4.2 [thread.once.callonce] as indicated:</p>
<blockquote><pre>
template&lt;class Callable, class ...Args&gt;
void call_once(once_flag&amp; flag, Callable&amp;&amp; func, Args&amp;&amp;... args);
</pre><blockquote>
<p>
[&hellip;]
<p/>
-4- <i>Throws</i>: <tt>system_error</tt> when an exception is required (30.2.2), or any exception thrown by <tt>func</tt>.
<p/>
<del>-5- Error conditions:</del>
</p>
<ul>
<li><del><tt>invalid_argument</tt> &mdash; if the <tt>once_flag</tt> object is no longer valid.</del></li>
</ul>
</blockquote></blockquote>
</li>
</ol>





<hr>
<h3><a name="2109"></a>2109. Incorrect requirements for <tt>hash</tt> specializations</h3>
<p><b>Section:</b> 19.5.5 [syserr.hash], 20.7.2.6 [util.smartptr.hash], 20.8.12 [unord.hash], 20.13.1 [type.index.synopsis], 21.6 [basic.string.hash], 23.3.7 [vector.bool], 30.3.1.1 [thread.thread.id] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2011-12-04 <b>Last modified:</b> 2012-12-23</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p>
20.7.2.6 [util.smartptr.hash] p2 is specified as follows:
</p>

<blockquote><p>
<i>Requires</i>: the template specializations shall meet the requirements of class template 
<tt>hash</tt> (20.8.12).
</p></blockquote>

<p>
The problem here is the usage of a <i>Requires</i> element, which is actually a pre-condition
that a <em>user</em> of a component has to satisfy. But the intent of this wording is actually
to be a requirement on implementations. The <i>Requires</i> element should be removed here and
the wording should be improved to say what it was intended for.
<p/>
We have similar situations in basically all other places where the specification of library-provided
<tt>hash</tt> specializations is defined. Usually, the <i>Requires</i> element is incorrect. In the
special case of <tt>hash&lt;unique_ptr&lt;T, D&gt;&gt;</tt> the implementation depends on 
the behaviour of <tt>hash</tt> specializations, that could be user-provided. In this case
the specification needs to separate the requirements on these specializations and those
that are imposed on the implementation.
</p>


<p><i>[2012, Kona]</i></p>

<p>
Update wording and move to Review.
</p>
<p>
Believe a simpler formulation is to simply string the term <i>Requires:</i> and leave the
current wording intact, rather than strike the whole clause and replace it.
</p>

<p><i>[Originally proposed wording for reference
<ol>
<li><p>Change 19.5.5 [syserr.hash] as indicated:</p>

<blockquote><pre>
template &lt;&gt; struct hash&lt;error_code&gt;;
</pre><blockquote>
<p>
-1- <del><i>Requires</i>: the template specialization shall meet the requirements 
of class template <tt>hash</tt> (20.8.12 [unord.hash])</del><ins>The header 
<tt>&lt;system_error&gt;</tt> provides a definition for a specialization of the 
template <tt>hash&lt;error_code&gt;</tt>. The requirements for the members of 
this specialization are given in sub-clause 20.8.12 [unord.hash]</ins>.
</p>
</blockquote></blockquote>
</li>

<li><p>Change 20.5.3 [bitset.hash] as indicated:</p>

<blockquote><pre>
template &lt;size_t N&gt; struct hash&lt;bitset&lt;N&gt; &gt;;
</pre><blockquote>
<p>
-1- <del><i>Requires</i>: the template specialization shall meet the requirements 
of class template <tt>hash</tt> (20.8.12 [unord.hash])</del><ins>The header 
<tt>&lt;bitset&gt;</tt> provides a definition for a partial specialization of the 
<tt>hash</tt> class template for specializations of class template <tt>bitset&lt;N&gt;</tt>. 
The requirements for the members of instantiations of this specialization are given 
in sub-clause 20.8.12 [unord.hash]</ins>.
</p>
</blockquote></blockquote>
</li>

<li><p>Change 20.7.2.6 [util.smartptr.hash] as indicated:</p>

<blockquote><pre>
template &lt;class T, class D&gt; struct hash&lt;unique_ptr&lt;T, D&gt; &gt;;
</pre><blockquote>
<p>
-1- <del><i>Requires</i>: the template specialization shall meet the requirements 
of class template <tt>hash</tt> (20.8.12 [unord.hash])</del><ins>The header 
<tt>&lt;memory&gt;</tt> provides a definition for a partial specialization of the 
<tt>hash</tt> class template for specializations of class template <tt>unique_ptr&lt;T, D&gt;</tt>. 
The requirements for the members of instantiations of this specialization are given 
in sub-clause 20.8.12 [unord.hash]</ins>. For an object <tt>p</tt> of type 
<tt>UP</tt>, where <tt>UP</tt> is <tt>unique_ptr&lt;T, D&gt;</tt>, 
<tt>hash&lt;UP&gt;()(p)</tt> shall evaluate to the same value as 
<tt>hash&lt;typename UP::pointer&gt;()(p.get())</tt>. <del>The specialization 
<tt>hash&lt;typename UP::pointer&gt;</tt> shall be well-formed.</del>
<p/>
<ins>-?- <i>Requires</i>: The specialization <tt>hash&lt;typename UP::pointer&gt;</tt> 
shall be well-formed and well-defined [<i>Note:</i> the general requirements 
of class template <tt>hash</tt> (20.8.12 [unord.hash]) are implied &mdash; 
<i>end note</i>].</ins>
</p>
</blockquote></blockquote>

<blockquote><pre>
template &lt;class T&gt; struct hash&lt;shared_ptr&lt;T&gt; &gt;;
</pre><blockquote>
<p>
-2- <del><i>Requires</i>: the template specialization shall meet the requirements 
of class template <tt>hash</tt> (20.8.12 [unord.hash])</del><ins>The header 
<tt>&lt;memory&gt;</tt> provides a definition for a partial specialization of the 
<tt>hash</tt> class template for specializations of class template <tt>shared_ptr&lt;T&gt;</tt>. 
The requirements for the members of instantiations of this specialization are given 
in sub-clause 20.8.12 [unord.hash]</ins>. For an object <tt>p</tt> of type 
<tt>shared_ptr&lt;T&gt;</tt>, <tt>hash&lt;shared_ptr&lt;T&gt; &gt;()(p)</tt> 
shall evaluate to the same value as <tt>hash&lt;T*&gt;()(p.get())</tt>.
</p>
</blockquote></blockquote>
</li>

<li><p>Change 20.8.12 [unord.hash] p2 as indicated: [<i>Comment</i>: For unknown
reasons the extended integer types are not mentioned here, which looks like an oversight to
me and makes also the wording more complicated. See <a href="lwg-active.html#2119">2119</a> for this part
of the problem. &mdash; <i>end comment</i>]</p>

<blockquote><pre>
template &lt;&gt; struct hash&lt;bool&gt;;
template &lt;&gt; struct hash&lt;char&gt;;
[&hellip;]
template &lt;&gt; struct hash&lt;long double&gt;;
template &lt;class T&gt; struct hash&lt;T*&gt;;
</pre><blockquote>
<p>
-2- <del><i>Requires</i>: the template specializations shall meet the requirements 
of class template <tt>hash</tt> (20.8.12 [unord.hash])</del><ins>The header 
<tt>&lt;functional&gt;</tt> provides definitions for specializations of the 
<tt>hash</tt> class template for each <i>cv</i>-unqualified arithmetic type except 
for the extended integer types. This header also provides a definition for a partial 
specialization of the <tt>hash</tt> class template for any pointer type. The 
requirements for the members of these specializations are given in sub-clause 
20.8.12 [unord.hash]</ins>.
</p>
</blockquote></blockquote>
</li>

<li><p>Change 20.13.4 [type.index.hash] p1 as indicated:</p>

<blockquote><pre>
template &lt;&gt; struct hash&lt;type_index&gt;;
</pre><blockquote>
<p>
-1- <del><i>Requires</i>: the template specialization shall meet the requirements 
of class template <tt>hash</tt> (20.8.12 [unord.hash])</del><ins>The header 
<tt>&lt;typeindex&gt;</tt> provides a definition for a specialization of the 
template <tt>hash&lt;type_index&gt;</tt>. The requirements for the members 
of this specialization are given in sub-clause 20.8.12 [unord.hash]</ins>. For 
an object <tt>index</tt> of type <tt>type_index</tt>, <tt>hash&lt;type_index&gt;()(index)</tt> 
shall evaluate to the same result as <tt>index.hash_code()</tt>.
</p>
</blockquote></blockquote>
</li>

<li><p>Change 21.6 [basic.string.hash] p1 as indicated:</p>

<blockquote><pre>
template &lt;&gt; struct hash&lt;string&gt;;
template &lt;&gt; struct hash&lt;u16string&gt;;
template &lt;&gt; struct hash&lt;u32string&gt;;
template &lt;&gt; struct hash&lt;wstring&gt;;
</pre><blockquote>
<p>
-1- <del><i>Requires</i>: the template specializations shall meet the requirements 
of class template <tt>hash</tt> (20.8.12 [unord.hash])</del><ins>The header 
<tt>&lt;string&gt;</tt> provides definitions for specializations of the 
<tt>hash</tt> class template for the types <tt>string</tt>, <tt>u16string</tt>,
<tt>u32string</tt>, and <tt>wstring</tt>. The requirements for the members 
of these specializations are given in sub-clause 20.8.12 [unord.hash]</ins>.
</p>
</blockquote></blockquote>
</li>

<li><p>Change 23.3.7 [vector.bool] p7 as indicated:</p>

<blockquote><pre>
template &lt;class Allocator&gt; struct hash&lt;vector&lt;bool, Allocator&gt; &gt;;
</pre><blockquote>
<p>
-7- <del><i>Requires</i>: the template specialization shall meet the requirements 
of class template <tt>hash</tt> (20.8.12 [unord.hash])</del><ins>The header 
<tt>&lt;vector&gt;</tt> provides a definition for a partial specialization of the 
<tt>hash</tt> class template for specializations of class template <tt>vector&lt;bool, Allocator&gt;</tt>. 
The requirements for the members of instantiations of this specialization are given 
in sub-clause 20.8.12 [unord.hash]</ins>.
</p>
</blockquote></blockquote>
</li>

<li><p>Change 30.3.1.1 [thread.thread.id] p14 as indicated:</p>

<blockquote><pre>
template &lt;&gt; struct hash&lt;thread::id&gt;;
</pre><blockquote>
<p>
-14- <del><i>Requires</i>: the template specialization shall meet the requirements 
of class template <tt>hash</tt> (20.8.12 [unord.hash])</del><ins>The header 
<tt>&lt;thread&gt;</tt> provides a definition for a specialization of the 
template <tt>hash&lt;thread::id&gt;</tt>. The requirements for the members of this 
specialization are given in sub-clause 20.8.12 [unord.hash]</ins>.
</p>
</blockquote></blockquote>
</li>

</ol>
]</i></p>


<p><i>[2012, Portland: Move to Tentatively Ready]</i></p>

<p>
No further wording issues, so move to Tentatively Ready (post meeting issues processing).
</p>



<p><b>Proposed resolution:</b></p>

<ol>
<li><p>Change 19.5.5 [syserr.hash] as indicated:</p>

<blockquote><pre>
template &lt;&gt; struct hash&lt;error_code&gt;;
</pre><blockquote>
<p>
-1- <del><i>Requires</i>: t</del><ins>T</ins>he template specialization shall meet the requirements 
of class template <tt>hash</tt> (20.8.12 [unord.hash].
</p>
</blockquote></blockquote>
</li>

<li><p>Change 20.5.3 [bitset.hash] as indicated:</p>

<blockquote><pre>
template &lt;size_t N&gt; struct hash&lt;bitset&lt;N&gt; &gt;;
</pre><blockquote>
<p>
-1- <del><i>Requires</i>: t</del><ins>T</ins>he template specialization shall meet the requirements 
of class template <tt>hash</tt> (20.8.12 [unord.hash]).
</p>
</blockquote></blockquote>
</li>

<li><p>Change 20.7.2.6 [util.smartptr.hash] as indicated:</p>

<blockquote><pre>
template &lt;class T, class D&gt; struct hash&lt;unique_ptr&lt;T, D&gt; &gt;;
</pre><blockquote>
<p>
-1- <del><i>Requires</i>: t</del><ins>T</ins>he template specialization shall meet the requirements 
of class template <tt>hash</tt> (20.8.12 [unord.hash]). For an object <tt>p</tt> of type 
<tt>UP</tt>, where <tt>UP</tt> is <tt>unique_ptr&lt;T, D&gt;</tt>, 
<tt>hash&lt;UP&gt;()(p)</tt> shall evaluate to the same value as 
<tt>hash&lt;typename UP::pointer&gt;()(p.get())</tt>.  <del>The specialization 
<tt>hash&lt;typename UP::pointer&gt;</tt> shall be well-formed.</del>
<p/>
<ins>-?- <i>Requires</i>: The specialization <tt>hash&lt;typename UP::pointer&gt;</tt> 
shall be well-formed and well-defined, and shall meet the requirements of class template
<tt>hash</tt> (20.8.12 [unord.hash]).</ins>
</p>
</blockquote></blockquote>

<blockquote><pre>
template &lt;class T&gt; struct hash&lt;shared_ptr&lt;T&gt; &gt;;
</pre><blockquote>
<p>
-2- <del><i>Requires</i>: t</del><ins>T</ins>he template specialization shall meet the requirements 
of class template <tt>hash</tt> (20.8.12 [unord.hash]). For an object <tt>p</tt> of type 
<tt>shared_ptr&lt;T&gt;</tt>, <tt>hash&lt;shared_ptr&lt;T&gt; &gt;()(p)</tt> 
shall evaluate to the same value as <tt>hash&lt;T*&gt;()(p.get())</tt>.
</p>
</blockquote></blockquote>
</li>

<li><p>Change 20.8.12 [unord.hash] p2 as indicated: [<i>Comment</i>: For unknown
reasons the extended integer types are not mentioned here, which looks like an oversight to
me and makes also the wording more complicated. See <a href="lwg-active.html#2119">2119</a> for this part
of the problem. &mdash; <i>end comment</i>]</p>

<blockquote><pre>
template &lt;&gt; struct hash&lt;bool&gt;;
template &lt;&gt; struct hash&lt;char&gt;;
[&hellip;]
template &lt;&gt; struct hash&lt;long double&gt;;
template &lt;class T&gt; struct hash&lt;T*&gt;;
</pre><blockquote>
<p>
-2- <del><i>Requires</i>: t</del><ins>T</ins>he template specializations shall meet the requirements 
of class template <tt>hash</tt> (20.8.12 [unord.hash]).
</p>
</blockquote></blockquote>
</li>

<li><p>Change 20.13.4 [type.index.hash] p1 as indicated:</p>

<blockquote><pre>
template &lt;&gt; struct hash&lt;type_index&gt;;
</pre><blockquote>
<p>
-1- <del><i>Requires</i>: t</del><ins>T</ins>he template specialization shall meet the requirements 
of class template <tt>hash</tt> (20.8.12 [unord.hash]). For 
an object <tt>index</tt> of type <tt>type_index</tt>, <tt>hash&lt;type_index&gt;()(index)</tt> 
shall evaluate to the same result as <tt>index.hash_code()</tt>.
</p>
</blockquote></blockquote>
</li>

<li><p>Change 21.6 [basic.string.hash] p1 as indicated:</p>

<blockquote><pre>
template &lt;&gt; struct hash&lt;string&gt;;
template &lt;&gt; struct hash&lt;u16string&gt;;
template &lt;&gt; struct hash&lt;u32string&gt;;
template &lt;&gt; struct hash&lt;wstring&gt;;
</pre><blockquote>
<p>
-1- <del><i>Requires</i>: t</del><ins>T</ins>he template specializations shall meet the requirements 
of class template <tt>hash</tt> (20.8.12 [unord.hash]).
</p>
</blockquote></blockquote>
</li>

<li><p>Change 23.3.7 [vector.bool] p7 as indicated:</p>

<blockquote><pre>
template &lt;class Allocator&gt; struct hash&lt;vector&lt;bool, Allocator&gt; &gt;;
</pre><blockquote>
<p>
-7- <del><i>Requires</i>: t</del><ins>T</ins>he template specialization shall meet the requirements 
of class template <tt>hash</tt> (20.8.12 [unord.hash]).
</p>
</blockquote></blockquote>
</li>

<li><p>Change 30.3.1.1 [thread.thread.id] p14 as indicated:</p>

<blockquote><pre>
template &lt;&gt; struct hash&lt;thread::id&gt;;
</pre><blockquote>
<p>
-14- <del><i>Requires</i>: t</del><ins>T</ins>he template specialization shall meet the requirements 
of class template <tt>hash</tt> (20.8.12 [unord.hash]).
</p>
</blockquote></blockquote>
</li>

</ol>






<hr>
<h3><a name="2125"></a>2125. <tt>TimedMutex</tt> specification problem</h3>
<p><b>Section:</b> 30.4.1.3 [thread.timedmutex.requirements], 30.4.1.3.1 [thread.timedmutex.class] <b>Status:</b> <a href="lwg-active.html#NAD Editorial">Tentatively NAD Editorial</a>
 <b>Submitter:</b> Vicente J. Botet Escriba <b>Opened:</b> 2012-01-01 <b>Last modified:</b> 2012-12-23</p>
<p><b>View other</b> <a href="lwg-index-open.html#thread.timedmutex.requirements">active issues</a> in [thread.timedmutex.requirements].</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.timedmutex.requirements">issues</a> in [thread.timedmutex.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD Editorial">Tentatively NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p>
30.4.1.3.1 [thread.timedmutex.class] says:
</p>
<blockquote><p>
The class <tt>timed_mutex</tt> shall satisfy all of the <tt>TimedMutex</tt> requirements (30.4.1.3 [thread.timedmutex.requirements]). 
It shall be a standardlayout class (Clause 9 [class]).
</p></blockquote>
<p>
Problem here is that 30.4.1.3 [thread.timedmutex.requirements] does not define a requirement set named &quot;<tt>TimedMutex</tt>&quot;,
it only refers to &quot;<i>timed mutex types</i>&quot;
</p>

<p><i>[See also issue <a href="lwg-active.html#2126">2126</a>]</i></p>


<p><i>[2012, Portland: move to Tentatively NAD Editorial]</i></p>

<p>
We have timed mutex type, but it is labeled timed mutex requirements
</p>
<p>
We can make a suggestion, but will send to the editor as it seems purely editorial.
There is a typo, and we don't have the timed mutex but 30.4.1.3 [thread.timedmutex.requirements] already
says timed mutex type, and we need to reuse that term down in the class to fulfil the mutex requirement.
</p>
<p><i>[To Editor:]</i></p>

<p>
Replace this one with timed mutex type.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2126"></a>2126. Several specification problems in regard to mutex requirements</h3>
<p><b>Section:</b> 30.4.1 [thread.mutex.requirements], 30.4.1.2.1 [thread.mutex.class], 30.4.1.2 [thread.mutex.requirements.mutex], 30.4.1.2.2 [thread.mutex.recursive], 30.4.1.3 [thread.timedmutex.requirements], 30.4.1.3.1 [thread.timedmutex.class], 30.4.1.3.2 [thread.timedmutex.recursive] <b>Status:</b> <a href="lwg-active.html#NAD Editorial">Tentatively NAD Editorial</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2012-01-16 <b>Last modified:</b> 2012-12-23</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.mutex.requirements">issues</a> in [thread.mutex.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD Editorial">Tentatively NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p>
 30.4.1.2.1 [thread.mutex.class]&#47;3 says that the class mutex "shall satisfy all the <tt>Mutex</tt> requirements (30.4.1 [thread.mutex.requirements])". 
 30.4.1.2.1 [thread.mutex.class] is part of 30.4.1 [thread.mutex.requirements], so at the very least, this 
 requirement is recursive. But worse, there is nothing that says what "the <tt>Mutex</tt> requirements" refers to. For example, 
 the "<tt>Lockable</tt> requirements" section starts with "A type <tt>L</tt> meets the <tt>Lockable</tt> requirements if &hellip;". There is no such 
 statement for "the <tt>Mutex</tt> requirements".
<p/>
Organizationally, paragraphs 1-26 in 30.4.1.2 [thread.mutex.requirements.mutex] should probably be in a subclause with a name. 
(This is actually an ISO requirement, to avoid exactly this kind of ambiguous referencing) Then the first sentence of 
30.4.1.2.1 [thread.mutex.class]&#47;3 can become a note: "The class mutex meets the requirements of (whatever)", since that 
subclause already says that the mutex types "shall meet the requirements set out in this section."
<p/>
And similarly for 30.4.1.2.2 [thread.mutex.recursive]&#47;2 (<tt>recursive_mutex</tt>).
<p/>
30.4.1.3 [thread.timedmutex.requirements], Timed mutex types, also needs the same rearrangement: its introductory 
requirements should be moved into a subclause, and the first sentences of 30.4.1.3.1 [thread.timedmutex.class]&#47;2 
and 30.4.1.3.2 [thread.timedmutex.recursive]&#47;2 should be turned into notes that refer to this new subclause and 
to the new subclause in 30.4.1.2 [thread.mutex.requirements.mutex].
</p>

<p><i>[See also issue <a href="lwg-active.html#2125">2125</a>]</i></p>


<p><i>[2012, Portland: move to Tentatively NAD Editorial]</i></p>

<p>
Seems no real ambiguity. May need some reorg of text rather then changing the wording.
</p>
<p>
Is there much that needs to be changed? But Pete's suggestion of putting requirement in separate sub section is good.
Should be the direction to editor.
</p>
<p>
Suggest this is an editorial change. Happy with Pete's comments.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2134"></a>2134. Redundant Mutex requirement?</h3>
<p><b>Section:</b> 30.4.1.2 [thread.mutex.requirements.mutex] <b>Status:</b> <a href="lwg-active.html#NAD Editorial">Tentatively NAD Editorial</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2012-03-05 <b>Last modified:</b> 2012-12-23</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.mutex.requirements.mutex">issues</a> in [thread.mutex.requirements.mutex].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD Editorial">Tentatively NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p>
30.4.1.2 [thread.mutex.requirements.mutex]&#47;11 says that prior unlock operations <em>synchronize with</em> <tt>m.lock()</tt>.
<p/>
30.4.1.2 [thread.mutex.requirements.mutex]&#47;19 says that if <tt>m.try_lock()</tt> succeeds, prior unlock operations 
<em>synchronize with</em> the operation. 
<p/>
30.4.1.2 [thread.mutex.requirements.mutex]&#47;25 says that <tt>m.unlock()</tt> <em>synchronizes with</em> subsequent 
successful lock operations. 
<p/>
Does the third requirement add anything to the first two? If not, it should probably be a non-normative note.
</p>

<p><i>[2012, Portland: move to Tentatively NAD Editorial]</i></p>

<p>
Agree that third note should be non-normative and adds nothing.
</p>
<p>
Seems An Editorial change, but does changing a normative to non-normative wording makes it a non-editorial change?
</p>
<p>
Ask the editor. If not editorial, then we will agree on the fix as removal of the third point,
then we will put it in ready state for Bristol.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2144"></a>2144. Missing <tt>noexcept</tt> specification in <tt>type_index</tt></h3>
<p><b>Section:</b> 20.13 [type.index] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2012-03-18 <b>Last modified:</b> 2013-04-12</p>
<p><b>View all other</b> <a href="lwg-index.html#type.index">issues</a> in [type.index].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The class type <tt>type_index</tt> is a thin wrapper of <tt>type_info</tt> to
adapt it as a valid associative container element. Similar to <tt>type_info</tt>, 
all member functions have an effective <tt>noexcept(true)</tt> specification, with the 
exception of <tt>hash_code()</tt> and <tt>name()</tt>. The actual effects of these
functions is a direct call to <tt>type_info</tt>'s <tt>hash_code()</tt> and <tt>name</tt> 
function, but according to 18.7 [support.rtti] these are both <tt>noexcept</tt>
functions, so there is no reason for not declaring them as <tt>noexcept</tt>, too. In fact,
one of the suggested changes of the original proposing paper 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2530.html">N2530</a>
specifically was to ensure that <tt>type_info</tt> would get a <tt>hash_code()</tt>
function that guarantees not to throw exceptions (during that time the <tt>hash</tt>
requirements did not allow to exit with an exception). From this we can conclude that
<tt>type_index::hash_code()</tt> was intended to be nothrow.
<p/>
It seems both consistent and technically simply to require these functions to be <tt>noexcept</tt>.
</p>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Tentatively Ready.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3376.</p>

<ol>
<li><p>Modify the class <tt>type_index</tt> synopsis, 20.13.2 [type.index.overview] as indicated:</p>

<blockquote><pre>
namespace std {
  class type_index {
  public:
    type_index(const type_info&amp; rhs) noexcept;
    bool operator==(const type_index&amp; rhs) const noexcept;
    bool operator!=(const type_index&amp; rhs) const noexcept;
    bool operator&lt; (const type_index&amp; rhs) const noexcept;
    bool operator&lt;= (const type_index&amp; rhs) const noexcept;
    bool operator&gt; (const type_index&amp; rhs) const noexcept;
    bool operator&gt;= (const type_index&amp; rhs) const noexcept;
    size_t hash_code() const <ins>noexcept</ins>;
    const char* name() const <ins>noexcept</ins>;
  private:
    const type_info* target; <i>// exposition only</i>
    <i>// Note that the use of a pointer here, rather than a reference,</i>
    <i>// means that the default copy&#47;move constructor and assignment</i>
    <i>// operators will be provided and work as expected.</i>
  };
}
</pre></blockquote>
</li>
</ol>

<ol>
<li><p>Modify the prototype definitions in 20.13.3 [type.index.members] as indicated:</p>

<blockquote><pre>
size_t hash_code() const <ins>noexcept</ins>;
</pre><blockquote>
<p>
-8- <i>Returns</i>: <tt>target->hash_code()</tt>
</p>
</blockquote>
<pre>
const char* name() const <ins>noexcept</ins>;
</pre><blockquote>
<p>
-9- <i>Returns</i>: <tt>target->name()</tt>
</p>
</blockquote>
</blockquote>

</li>
</ol>






<hr>
<h3><a name="2167"></a>2167. Copy assignment requirements of Containers</h3>
<p><b>Section:</b> 23.2.1 [container.requirements.general] <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Dean Michael Berris <b>Opened:</b> 2012-07-13 <b>Last modified:</b> 2012-12-23</p>
<p><b>View other</b> <a href="lwg-index-open.html#container.requirements.general">active issues</a> in [container.requirements.general].</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements.general">issues</a> in [container.requirements.general].</p>
<p><b>Discussion:</b></p>

<p>
Table 96 defines the general requirement for copy assignment (row 23, page 704) as:
</p>

<table border="1">
<caption>Table 96 &mdash; Container requirements</caption>

<tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Assertion&#47;note pre-&#47;post-condition</th>
<th>Complexity</th>
</tr> 

<tr>
<td>
<tt>r = a</tt>
</td>
<td>
<tt>X&amp;</tt>
</td>
<td>
<tt></tt>
</td>
<td>
post: <tt>r == a.</tt>
</td>
<td>
linear
</td>
</tr>

</table>

<p>
However there is no requirement that <tt>T</tt> is <tt>CopyInsertable</tt> into <tt>X</tt>.
</p>

<p><i>[2012, Portland: Move to Tentatively NAD]</i></p>

<p>
Howard notes that this may be a difficult requirement for <tt>std::array</tt>
</p>

<p>
We already have this requirement for allocator aware containers, and
<tt>std::array</tt> already adds the appropriate extra requirement.
</p>

<p>
We say the necessary things in the necessary places, but the container requirements
continue to cause confusion in where we sometimes say things.  Consensus is that
this issue remains NAD though.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3376.</p>

<ol>
<li><p>Change Table 96 &mdash; "Container requirements" in 23.2.1 [container.requirements.general]:</p>

<table border="1">
<caption>Table 96 &mdash; Container requirements</caption>

<tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Assertion&#47;note pre-&#47;post-condition</th>
<th>Complexity</th>
</tr> 

<tr>
<td>
<tt>r = a</tt>
</td>
<td>
<tt>X&amp;</tt>
</td>
<td>
<tt></tt>
</td>
<td>
<ins><i>Requires</i>: <tt>T</tt> is <tt>CopyInsertable</tt> into <tt>X</tt>.</ins><br/>
post: <tt>r == a.</tt>
</td>
<td>
linear
</td>
</tr>

</table>

</li>
</ol>







<hr>
<h3><a name="2174"></a>2174. <tt>wstring_convert::converted()</tt> should be <tt>noexcept</tt></h3>
<p><b>Section:</b> 22.3.3.2.2 [conversions.string] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2012-08-02 <b>Last modified:</b> 2013-04-12</p>
<p><b>View other</b> <a href="lwg-index-open.html#conversions.string">active issues</a> in [conversions.string].</p>
<p><b>View all other</b> <a href="lwg-index.html#conversions.string">issues</a> in [conversions.string].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p>
There is no reason <tt>wstring_convert::converted()</tt> shouldn't be <tt>noexcept</tt>.
<p/>
It might be possible for <tt>wstring_convert::state()</tt> and <tt>wbuffer_convert::state()</tt> 
to be <tt>noexcept</tt> too, depending on the requirements on <tt>mbstate_t</tt>.
</p>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Tentatively Ready.
</p>
<p>
Defer the separate discsussion of <tt>state()</tt> to another issue, if anyone is ever motivated
to file one.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3376.</p>

<ol>
<li><p>Edit in the class template <tt>wstring_convert</tt> synopsis 22.3.3.2.2 [conversions.string] p2:</p>

<blockquote><pre>
size_t converted() const <ins>noexcept</ins>;
</pre></blockquote>
</li>

<li><p>Edit the signature before 22.3.3.2.2 [conversions.string] p6:</p>

<blockquote><pre>
size_t converted() const <ins>noexcept</ins>;
</pre></blockquote>
</li>
</ol>





<hr>
<h3><a name="2175"></a>2175. <tt>wstring_convert</tt> and <tt>wbuffer_convert</tt> validity</h3>
<p><b>Section:</b> 22.3.3.2.2 [conversions.string], 22.3.3.2.3 [conversions.buffer] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2012-08-02 <b>Last modified:</b> 2013-04-12</p>
<p><b>View other</b> <a href="lwg-index-open.html#conversions.string">active issues</a> in [conversions.string].</p>
<p><b>View all other</b> <a href="lwg-index.html#conversions.string">issues</a> in [conversions.string].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p>
See discussion following <a href="http://accu.org/cgi-bin/wg21/message?wg=lib&amp;msg=32710">c++std-lib-32710</a>.
<p/>
It's not specified what happens if <tt>wstring_convert</tt> and <tt>wbuffer_convert</tt> objects are constructed 
with null <tt>Codecvt</tt> pointers.
<p/>
Should the constructors have preconditions that the pointers are not null?  If not, are conversions expected to 
fail, or is it undefined to attempt conversions if the pointers are null?
<p/>
There are no observer functions to check whether objects were constructed with valid <tt>Codecvt</tt> pointers. 
If the types are made movable such observers would be necessary even if the constructors require non-null 
pointers (see also LWG <a href="lwg-active.html#2176">2176</a>).
</p>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Tentatively Ready.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3376.</p>

<ol>
<li><p>Insert a new paragraph before 22.3.3.2.2 [conversions.string] paragraph 16:</p>

<blockquote><pre>
wstring_convert(Codecvt *pcvt = new Codecvt);
wstring_convert(Codecvt *pcvt, state_type state);
wstring_convert(const byte_string&amp; byte_err,
  const wide_string&amp; wide_err = wide_string());
</pre>
<blockquote>
<p>
<ins>-?- <i>Requires</i>: For the first and second constructors <tt>pcvt != nullptr</tt>.</ins>
<p/>
-16- <i>Effects</i>: The first constructor shall store <tt>pcvt</tt> in <tt>cvtptr</tt> and default values in 
<tt>cvtstate</tt>, <tt>byte_err_string</tt>, and <tt>wide_err_string</tt>. The second constructor shall 
store <tt>pcvt</tt> in <tt>cvtptr</tt>, <tt>state</tt> in <tt>cvtstate</tt>, and default values in 
<tt>byte_err_string</tt> and <tt>wide_err_string</tt>; moreover the stored state shall be retained between 
calls to <tt>from_bytes</tt> and <tt>to_bytes</tt>. The third constructor shall store <tt>new Codecvt</tt> 
in <tt>cvtptr</tt>, <tt>state_type()</tt> in cvtstate, <tt>byte_err</tt> in <tt>byte_err_string</tt>, 
and <tt>wide_err</tt> in <tt>wide_err_string</tt>.
</p>
</blockquote></blockquote>
</li>

<li><p>Insert a new paragraph before 22.3.3.2.3 [conversions.buffer] paragraph 10:</p>

<blockquote><pre>
wbuffer_convert(std::streambuf *bytebuf = 0,
  Codecvt *pcvt = new Codecvt, state_type state = state_type());
</pre><blockquote>
<p>
<ins>-?- <i>Requires</i>: <tt>pcvt != nullptr</tt>.</ins>
<p/>
-10- <i>Effects</i>: The constructor constructs a stream buffer object, initializes <tt>bufptr</tt> to <tt>bytebuf</tt>, 
initializes <tt>cvtptr</tt> to <tt>pcvt</tt>, and initializes <tt>cvtstate</tt> to <tt>state</tt>.
</p>
</blockquote></blockquote>

</li>

</ol>





<hr>
<h3><a name="2177"></a>2177. Requirements on <tt>Copy&#47;MoveInsertable</tt></h3>
<p><b>Section:</b> 23.2.1 [container.requirements.general] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Lo&iuml;c Joly <b>Opened:</b> 2012-08-10 <b>Last modified:</b> 2012-12-23</p>
<p><b>View other</b> <a href="lwg-index-open.html#container.requirements.general">active issues</a> in [container.requirements.general].</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements.general">issues</a> in [container.requirements.general].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p>
See also discussion following <a href="http://accu.org/cgi-bin/wg21/message?wg=lib&amp;msg=32883">c++std-lib-32883</a>
and <a href="http://accu.org/cgi-bin/wg21/message?wg=lib&amp;msg=32897">c++std-lib-32897</a>.
<p/>
The requirements on <tt>CopyInsertable</tt> and <tt>MoveInsertable</tt> are either incomplete, or complete but hard to 
figure out.
<p/>
From e-mail <a href="http://accu.org/cgi-bin/wg21/message?wg=lib&amp;msg=32897">c++std-lib-32897</a>:
<p/>
Pablo Halpern:
<p/>
I agree that we need semantic requirements for all of the <tt>*Insertable</tt> concepts analogous to the requirements 
we have on similar concepts.
<p/>
Howard Hinnant:
<p/>
I've come to believe that the standard is actually correct as written in this area. But it is <em>really</em> hard 
to read. I would have no objection whatsoever to clarifications to <tt>CopyInsertable</tt> as you suggest (such as the 
post-conditions on <tt>v</tt>). And I do agree with you that the correct approach to the clarifications is to 
confirm that <tt>CopyInsertable</tt> implies <tt>MoveInsertable</tt>.
</p>

<p><i>[2012, Portland: Move to Tentatively Ready]</i></p>

<p>
Move to Tentatively Ready by unanimous consent.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3376.</p>

<ol>
<li><p>Edit 23.2.1 [container.requirements.general] p13 as indicated:</p>

<blockquote><p>
-13- [&hellip;] Given a container type <tt>X</tt> having an <tt>allocator_type</tt> identical to <tt>A</tt> and 
a <tt>value_type</tt> identical to <tt>T</tt> and given an lvalue <tt>m</tt> of type <tt>A</tt>, a pointer <tt>p</tt> 
of type <tt>T*</tt>, an expression <tt>v</tt> of type (possibly <tt>const</tt>) <tt>T</tt>, and an rvalue <tt>rv</tt> 
of type <tt>T</tt>, the following terms are defined. If <tt>X</tt> is not allocator-aware, the terms below are
defined as if <tt>A</tt> were <tt>std::allocator&lt;T&gt;</tt> &mdash; no allocator object needs to be created and 
user specializations of <tt>std::allocator&lt;T&gt;</tt> are not instantiated:
</p>
<ul>
<li><p><tt>T</tt> is <em><tt>DefaultInsertable</tt> into <tt>X</tt></em> means that the following expression is 
well-formed:</p>
<blockquote><pre>
allocator_traits&lt;A&gt;::construct(m, p)<del>;</del>
</pre></blockquote>
</li>

<li><p>An element of <tt>X</tt> is <em>default-inserted</em> if it is initialized by evaluation of the expression</p>
<blockquote><pre>
allocator_traits&lt;A&gt;::construct(m, p)<del>;</del>
</pre></blockquote>
<p>
where <tt>p</tt> is the address of the uninitialized storage for the element allocated within <tt>X</tt>.
</p>
</li>

<li><p><tt>T</tt> is <em><tt><del>Copy</del><ins>Move</ins>Insertable</tt> into <tt>X</tt></em> means that 
the following expression is well-formed:</p>
<blockquote><pre>
allocator_traits&lt;A&gt;::construct(m, p, <ins>r</ins>v)<del>;</del>
</pre></blockquote>
<p>
<ins>and when evaluated the following postconditions hold: The value of <tt>*p</tt> is equivalent to the value of 
<tt>rv</tt> before the evaluation. [<i>Note</i>: <tt>rv</tt> remains a valid object. Its state is unspecified &mdash; 
<i>end note</i>]</ins>
</p>
</li>

<li><p><tt>T</tt> is <em><tt><del>Move</del><ins>Copy</ins>Insertable</tt> into <tt>X</tt></em> means 
that<ins>, in addition to satisfying the <tt>MoveInsertable</tt> requirements,</ins> the following expression is 
well-formed:</p>
<blockquote><pre>
allocator_traits&lt;A&gt;::construct(m, p, <del>r</del>v)<del>;</del>
</pre></blockquote>
<p>
<ins>and when evaluated the following postconditions hold: The value of <tt>v</tt> is unchanged and is equivalent 
to <tt>*p</tt>.</ins>
</p>
</li>

<li><p><tt>T</tt> is <em><tt>EmplaceConstructible</tt> into <tt>X</tt> from <tt>args</tt></em>, for zero or more arguments 
<tt>args</tt>, means that the following expression is well-formed:</p>
<blockquote><pre>
allocator_traits&lt;A&gt;::construct(m, p, args)<del>;</del>
</pre></blockquote>
</li>

<li><p><tt>T</tt> is <em><tt>Erasable</tt> from <tt>X</tt></em> means that the following expression is well-formed:</p>
<blockquote><pre>
allocator_traits&lt;A&gt;::destroy(m, p)<del>;</del>
</pre></blockquote>
</li>

</ul>
<p>
[<i>Note</i>: A container calls <tt>allocator_traits&lt;A&gt;::construct(m, p, args)</tt> to construct an element 
at <tt>p</tt> using <tt>args</tt>. The default construct in <tt>std::allocator</tt> will call 
<tt>::new((void*)p) T(args)</tt>, but specialized allocators may choose a different definition. &mdash; <i>end note</i>]
</p>
</blockquote>
</li>

</ol>






<hr>
<h3><a name="2187"></a>2187. <tt>vector&lt;bool&gt;</tt> is missing <tt>emplace</tt> and <tt>emplace_back</tt> member functions</h3>
<p><b>Section:</b> 23.3.7 [vector.bool] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Nevin Liber <b>Opened:</b> 2012-09-21 <b>Last modified:</b> 2012-12-23</p>
<p><b>View all other</b> <a href="lwg-index.html#vector.bool">issues</a> in [vector.bool].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p>
It should have them so that it more closely matches the <tt>vector&lt;T&gt;</tt> interface, as this helps when 
writing generic code.
</p>

<p><i>[2012, Portland: Move to Tentatively Ready]</i></p>

<p>
Question on whether the variadic template is really needed, but it turns out to be needed to support
<tt>emplace</tt> of no arguments.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3376.</p>

<ol>
<li><p>Change the class template <tt>vector&lt;bool&gt;</tt> synopsis, 23.3.7 [vector.bool] p1, as indicated:</p>
<blockquote><pre>
namespace std {
  template &lt;class Allocator&gt; class vector&lt;bool, Allocator&gt; {
  public:
    [&hellip;]
    <i>// modifiers:</i>
    <ins>template &lt;class... Args&gt; void emplace_back(Args&amp;&amp;... args);</ins>
    void push_back(const bool&amp; x);
    void pop_back();
    <ins>template &lt;class... Args&gt; iterator emplace(const_iterator position, Args&amp;&amp;... args);</ins>
    iterator insert(const_iterator position, const bool&amp; x);
    [&hellip;]
  };
}
</pre></blockquote>
</li>
</ol>






<hr>
<h3><a name="2197"></a>2197. Specification of <tt>is_[un]signed</tt> unclear for non-arithmetic types</h3>
<p><b>Section:</b> 20.9.4.3 [meta.unary.prop] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2012-10-07 <b>Last modified:</b> 2013-04-12</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.unary.prop">active issues</a> in [meta.unary.prop].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.unary.prop">issues</a> in [meta.unary.prop].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The pre-conditions for the trait <tt>is_signed</tt> allow for any types as template arguments, 
including non-arithmetic ones.
<p/>
But the current wording in Table 49 defining the predicate condition,
</p>
<blockquote><pre>
is_arithmetic&lt;T&gt;::value &amp;&amp; T(-1) &lt; T(0)
</pre></blockquote>
<p>
looks like real code and so leaves it open whether such argument types would create a well-formed 
instantiation of the trait template or not. As written this definition would lead to a hard
instantiation error for a non-arithmetic type like e.g.
</p>
<blockquote><pre>
struct S {};
</pre></blockquote>
<p>
I would suggest that the wording clarifies that the instantiation would be valid for such types as well,
by means of a specification that is not an exact code pattern. This also reflects how existing 
implementations behave.
</p>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Tentatively Ready.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3376.</p>

<ol>
<li><p>Change Table 49 as indicated:</p>

<table border="1">
<caption>Table 49 &mdash; Type property predicates</caption>
<tr>
<th>Template</th>
<th>Condition</th>
<th>Preconditions</th>
</tr> 

<tr>
<td>
<tt>template &lt;class T&gt;</tt><br/>
<tt>struct is_signed;</tt>
</td>
<td>
<ins>If </ins><tt>is_arithmetic&lt;T&gt;::value<del> &amp;&amp;</del></tt><ins> is true, the same result as</ins><br/>
<tt><ins>integral_constant&lt;bool,</ins> T(-1) &lt; T(0)<ins>&gt;::value</ins></tt><ins>;<br/>
otherwise, false.</ins>
</td>
<td>
&nbsp;
</td>
</tr>

<tr>
<td>
<tt>template &lt;class T&gt;</tt><br/>
<tt>struct is_unsigned;</tt>
</td>
<td>
<ins>If </ins><tt>is_arithmetic&lt;T&gt;::value<del> &amp;&amp;</del></tt><ins> is true, the same result as</ins><br/>
<tt><ins>integral_constant&lt;bool,</ins> T(0) &lt; T(-1)<ins>&gt;::value</ins></tt><ins>;<br/>
otherwise, false.</ins>
</td>
<td>
&nbsp;
</td>
</tr>

</table>

</li>
</ol>






<hr>
<h3><a name="2200"></a>2200. Data race avoidance for all containers, not only for sequences</h3>
<p><b>Section:</b> 23.2.2 [container.requirements.dataraces] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2012-10-17 <b>Last modified:</b> 2013-04-12</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements.dataraces">issues</a> in [container.requirements.dataraces].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p>
23.2.2 [container.requirements.dataraces]/2 says "[&hellip;] implementations are
required to avoid data races when the contents of the contained object in different 
elements in the same sequence, excepting <tt>vector&lt;bool&gt;</tt>, are modified 
concurrently."
</p>
<p>
This should say "same container" instead of "same sequence", to avoid
the interpretation that it only applies to sequence containers.
</p>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Tentatively Ready.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3376.</p>

<ol>
<li><p>Change 23.2.2 [container.requirements.dataraces]/2 as indicated:</p>
<blockquote><p>
-2- Notwithstanding (17.6.5.9 [res.on.data.races]), implementations are required to avoid data races when 
the contents of the contained object in different elements in the same <del>sequence</del><ins>container</ins>, 
excepting <tt>vector&lt;bool&gt;</tt>, are modified concurrently.
<p/>
-3- [<i>Note</i>: For a <tt>vector&lt;int&gt; x</tt> with a size greater than one, <tt>x[1] = 5</tt> and 
<tt>*x.begin() = 10</tt> can be executed concurrently without a data race, but <tt>x[0] = 5</tt> and 
<tt>*x.begin() = 10</tt> executed concurrently may result in a data race. As an exception to the general 
rule, for a <tt>vector&lt;bool&gt; y, y[0] = true</tt> may race with <tt>y[1] = true</tt>. &mdash; <i>end note</i> ]
</p></blockquote>
</li>
</ol>





<hr>
<h3><a name="2209"></a>2209. <tt>assign()</tt> overspecified for sequence containers</h3>
<p><b>Section:</b> 23.3 [sequences] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2012-10-31 <b>Last modified:</b> 2013-04-12</p>
<p><b>View other</b> <a href="lwg-index-open.html#sequences">active issues</a> in [sequences].</p>
<p><b>View all other</b> <a href="lwg-index.html#sequences">issues</a> in [sequences].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p>
DR <a href="lwg-defects.html#704">704</a> ensures allocator-aware containers can reuse existing
elements during copy/move assignment, and sequence containers can do
the same for <tt>assign()</tt>.
<p/>
But apart from <tt>std::list</tt> (which was changed by DR <a href="lwg-defects.html#320">320</a>) the sequence
containers define the Effects of <tt>assign()</tt> in terms of <tt>clear()</tt> followed
by <tt>insert</tt>.  A user-defined allocator can easily tell whether all old
elements are cleared and then new elements inserted or whether existing elements are assigned 
to, so those Effects clauses cannot be ignored via the as-if rule.
<p/>
The descriptions of the <tt>assign()</tt> members for <tt>deque</tt>, <tt>forward_list</tt> and
<tt>vector</tt> should be removed.  Their intended effects are entirely described by the 
sequence container requirements table, and the specific definitions of them are worse than 
redundant, they're contradictory (if the operations are defined in terms of <tt>erase</tt> and
<tt>insert</tt> then there's no need for elements to be assignable.)  The descriptions of 
<tt>assign()</tt> for <tt>list</tt> are correct but redundant, so should be removed too.
</p>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Tentatively Ready.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3376.</p>

<ol>
<li><p>Edit 23.3.3.2 [deque.cons] to remove everything after paragraph 10:</p>

<blockquote>
<pre>
<del>template &lt;class InputIterator&gt;
void assign(InputIterator first, InputIterator last);</del>
</pre>
<blockquote>
<p>
<del>-11- <i>Effects</i>:</del>
</p>
<blockquote><pre>
<del>erase(begin(), end());
insert(begin(), first, last);</del>
</pre></blockquote>
</blockquote>

<pre>
<del>void assign(size_type n, const T&amp; t);</del>
</pre>
<blockquote>
<p>
<del>-12- <i>Effects</i>:</del>
</p>
<blockquote><pre>
<del>erase(begin(), end());
insert(begin(), n, t);</del>
</pre></blockquote>
</blockquote>
</blockquote>

</li>

<li><p>Edit 23.3.4.2 [forwardlist.cons] to remove everything after paragraph 10:</p>

<blockquote>
<pre>
<del>template &lt;class InputIterator&gt;
void assign(InputIterator first, InputIterator last);</del>
</pre>
<blockquote>
<p>
<del>-11- <i>Effects</i>: <tt>clear(); insert_after(before_begin(), first, last);</tt></del>
</p>
</blockquote>

<pre>
<del>void assign(size_type n, const T&amp; t);</del>
</pre>
<blockquote>
<p>
<del>-12- <i>Effects</i>: <tt>clear(); insert_after(before_begin(), n, t);</tt></del>
</p>
</blockquote>
</blockquote>

</li>

<li><p>Edit 23.3.5.2 [list.cons] to remove everything after paragraph 10:</p>

<blockquote>
<pre>
<del>template &lt;class InputIterator&gt;
void assign(InputIterator first, InputIterator last);</del>
</pre>
<blockquote>
<p>
<del>-11- <i>Effects</i>: Replaces the contents of the list with the range <tt>[first, last)</tt>.</del>
</p>
</blockquote>

<pre>
<del>void assign(size_type n, const T&amp; t);</del>
</pre>
<blockquote>
<p>
<del>-12- <i>Effects</i>: Replaces the contents of the list with <tt>n</tt> copies of <tt>t</tt>.</del>
</p>
</blockquote>
</blockquote>

</li>

<li><p>Edit 23.3.6.2 [vector.cons] to remove everything after paragraph 10:</p>

<blockquote>
<pre>
<del>template &lt;class InputIterator&gt;
void assign(InputIterator first, InputIterator last);</del>
</pre>
<blockquote>
<p>
<del>-11- <i>Effects</i>:</del>
</p>
<blockquote><pre>
<del>erase(begin(), end());
insert(begin(), first, last);</del>
</pre></blockquote>
</blockquote>

<pre>
<del>void assign(size_type n, const T&amp; t);</del>
</pre>
<blockquote>
<p>
<del>-12- <i>Effects</i>:</del>
</p>
<blockquote><pre>
<del>erase(begin(), end());
insert(begin(), n, t);</del>
</pre></blockquote>
</blockquote>
</blockquote>

</li>

</ol>






<hr>
<h3><a name="2211"></a>2211. Replace ambiguous use of "Allocator" in container requirements</h3>
<p><b>Section:</b> 23.2.1 [container.requirements.general] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2012-11-07 <b>Last modified:</b> 2013-04-12</p>
<p><b>View other</b> <a href="lwg-index-open.html#container.requirements.general">active issues</a> in [container.requirements.general].</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements.general">issues</a> in [container.requirements.general].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p>
23.2.1 [container.requirements.general]/7 says:
</p>
<blockquote><p>
All other constructors for these container types take an <tt>Allocator&amp;</tt> argument 
(17.6.3.5 [allocator.requirements]), an allocator whose value type is the same as the
container's value type.
</p></blockquote>
<p>
This is a strange place to state the requirement on the allocator's
<tt>value_type</tt>, because the allocator is a property (and template
parameter) of the container type not of some of its constructors.
It's also unclear whether "<tt>Allocator&amp;</tt>" refers to the concept (as
implied by the cross-reference to the allocator requirements in Clause 17) 
or to the container's template parameter (as implied by the fact
it's shown as an lvalue-reference type.) I believe the latter is
intended, because those constructors can't take any model of the
allocator concept, they can only take the container's <tt>allocator_type</tt>.
<p/>
I think it would be clearer to remove the value type requirement earlier
in the paragraph (Table 99 already imposes that requirement) and to make it clear 
the constructor arguments are the container's <tt>allocator_type</tt>. There is 
already a cross-reference to the allocator requirements earlier in the paragraph, 
so it doesn't need to be repeated in another place where it causes confusion.
</p>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Tentatively Ready.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3485.</p>

<ol>
<li><p>Edit 23.2.1 [container.requirements.general] paragraph 7:</p>

<blockquote>
<p>
Unless otherwise specified, all containers defined in this clause obtain memory using an allocator 
(see 17.6.3.5 [allocator.requirements]). Copy constructors for these container types obtain an 
allocator by calling <tt>allocator_traits&lt;allocator_type&gt;::select_on_container_copy_construction</tt> 
on their first parameters. Move constructors obtain an allocator by move construction from the allocator 
belonging to the container being moved. Such move construction of the allocator shall not exit via 
an exception. All other constructors for these container types take <del>an <tt>Allocator&amp;</tt> argument 
(17.6.3.5 [allocator.requirements]), an allocator whose value type is the same as the container's value
type</del><ins>a <tt>const allocator_type&amp;</tt> argument</ins>. [<i>Note</i>: If an invocation of a 
constructor uses the default value of an optional allocator argument, then the <tt>Allocator</tt> type 
must support value initialization. &mdash; <i>end note</i>] A copy of this allocator is used for any
memory allocation performed, by these constructors and by all member functions, during the lifetime of each
container object or until the allocator is replaced. [&hellip;]
</p>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2222"></a>2222. Inconsistency in description of <tt>forward_list::splice_after</tt> single-element overload</h3>
<p><b>Section:</b> 23.3.4.6 [forwardlist.ops] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Edward Catmur <b>Opened:</b> 2012-12-11 <b>Last modified:</b> 2013-04-12</p>
<p><b>View all other</b> <a href="lwg-index.html#forwardlist.ops">issues</a> in [forwardlist.ops].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p>
23.3.4.6 [forwardlist.ops] p6 has
</p>
<blockquote><pre>
void splice_after(const_iterator position, forward_list&amp; x, const_iterator i);
void splice_after(const_iterator position, forward_list&amp;&amp; x, const_iterator i);
</pre><p>
<i>Effects</i>: Inserts the element following <tt>i</tt> into <tt>*this</tt>, following <tt>position</tt>, 
and removes it from <tt>x</tt>. The result is unchanged if <tt>position == i</tt> or <tt>position == ++i</tt>. 
Pointers and references to <tt>*i</tt> continue to refer to the same element but as a member of <tt>*this</tt>. 
Iterators to <tt>*i</tt> (including <tt>i</tt> itself) continue to refer to the same element, but now behave 
as iterators into <tt>*this</tt>, not into <tt>x</tt>.
</p>
</blockquote>
<p>
This overload splices the element <em>following</em> <tt>i</tt> from <tt>x</tt> to <tt>*this</tt>, so the 
language in the two latter sentences should refer to <tt>++i</tt>:
</p>
<blockquote><p>
Pointers and references to <tt>*++i</tt> continue to refer to the same element but as a member of
<tt>*this</tt>. Iterators to <tt>*++i</tt> continue to refer to the same element, but now behave as iterators
into <tt>*this</tt>, not into <tt>x</tt>.
</p></blockquote>
<p>
</p>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Tentatively Ready.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3485.</p>

<ol>
<li><p>Edit 23.3.4.6 [forwardlist.ops] p6 as indicated:</p>
<blockquote><pre>
void splice_after(const_iterator position, forward_list&amp; x, const_iterator i);
void splice_after(const_iterator position, forward_list&amp;&amp; x, const_iterator i);
</pre>
<p>
-5- <i>Requires</i>: <tt>position</tt> is <tt>before_begin()</tt> or is a dereferenceable iterator 
in the range <tt>[begin(),end())</tt>. The iterator following <tt>i</tt> is a dereferenceable iterator 
in <tt>x</tt>. <tt>get_allocator() == x.get_allocator()</tt>.
<p/>
-6- <i>Effects</i>: Inserts the element following <tt>i</tt> into <tt>*this</tt>, following <tt>position</tt>, 
and removes it from <tt>x</tt>. The result is unchanged if <tt>position == i</tt> or <tt>position == ++i</tt>. 
Pointers and references to <tt>*<ins>++</ins>i</tt> continue to refer to the same element but as a member of 
<tt>*this</tt>. Iterators to <tt>*<ins>++</ins>i</tt> <del>(including <tt>i</tt> itself)</del> continue to
refer to the same element, but now behave as iterators into <tt>*this</tt>, not into <tt>x</tt>.
</p></blockquote>
</li>
</ol>






<hr>
<h3><a name="2225"></a>2225. Unrealistic header inclusion checks required</h3>
<p><b>Section:</b> 17.6.2.2 [using.headers] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Richard Smith <b>Opened:</b> 2012-12-18 <b>Last modified:</b> 2013-04-12</p>
<p><b>View all other</b> <a href="lwg-index.html#using.headers">issues</a> in [using.headers].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p>
17.6.2.2 [using.headers]/3 says:
<p/>
A translation unit shall include a header only outside of any external declaration or definition, and shall 
include the header lexically before the first reference in that translation unit to any of the entities 
declared in that header.
<p/>
Per 1.4 [intro.compliance]/1, programs which violate this rule are ill-formed, and a conforming 
implementation is required to produce a diagnostic. This does not seem to match reality. Presumably, this 
paragraph is missing a "no diagnostic is required".
</p>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Tentatively Ready.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3485.</p>

<ol>
<li><p>Edit 17.6.2.2 [using.headers] p3 as indicated:</p>
<p>-3- A translation unit shall include a header only outside of any external declaration or definition, and shall
include the header lexically before the first reference in that translation unit to any of the entities declared
in that header. <ins>No diagnostic is required.</ins></p>
</li>
</ol>






<hr>
<h3><a name="2231"></a>2231. DR 704 removes complexity guarantee for <tt>clear()</tt></h3>
<p><b>Section:</b> 23.2.3 [sequence.reqmts] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2012-12-30 <b>Last modified:</b> 2013-04-12</p>
<p><b>View other</b> <a href="lwg-index-open.html#sequence.reqmts">active issues</a> in [sequence.reqmts].</p>
<p><b>View all other</b> <a href="lwg-index.html#sequence.reqmts">issues</a> in [sequence.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
From the question at <a href="http://stackoverflow.com/q/14094408/981959">stackoverflow</a>.
</p>

<p>
Were we aware that the resolution to LWG <a href="lwg-defects.html#704">704</a> means there is no complexity guarantee for 
<tt>clear()</tt> on most sequence containers? Previously it was implied by defining it in terms of 
<tt>erase(begin(), end())</tt> but we no longer do that.
</p>

<p>
There are explicit complexity requirements for <tt>std::list::clear()</tt>, but not the other sequence containers.
</p>

<p>Daniel:</p>

<p>
The idea was that the notion of "destroys all elements in <tt>a</tt>" would imply a linear complexity, but the wording 
needs to be clearer, because this doesn't say that this step is the actual complexity bound.
</p>

<p><i>[2013-03-15 Issues Teleconference]</i></p>

<p>
Moved to Tentatively Ready.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3485.</p>

<ol>
<li><p>Change Table 100 as indicated:</p>

<blockquote>
<table border="1">
<caption>Table 100 &mdash; Sequence container requirements (in addition to container) (continued)</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note pre-&#47;post-condition</th>
</tr>

<tr>
<td colspan="3" align="center">
<tt>&hellip;</tt>
</td>
</tr>

<tr>
<td>
<tt>a.clear()</tt>
</td>
<td>
<tt>void</tt>
</td>
<td>
Destroys all elements in <tt>a</tt>. Invalidates all<br/>
references, pointers, and iterators referring to<br/>
the elements of <tt>a</tt> and may invalidate the<br/>
past-the-end iterator.<br/>
post: <tt>a.empty()</tt> returns <tt>true</tt><br/>
<ins>complexity: linear</ins>
</td>
</tr>

<tr>
<td colspan="3" align="center">
<tt>&hellip;</tt>
</td>
</tr>

</table>
</blockquote>
</li>

</ol>






</body>
</html>
