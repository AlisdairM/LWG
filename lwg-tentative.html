<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>C++ Standard Library Tentative Issues</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
</style>
</head>
<body>
<p>Revised 2011-02-25 at 15:02:06 UTC</p>
<h2>Tentative Issues</h2>
<hr>
<h3><a name="1215"></a>1215. <tt>list::merge</tt> with unequal allocators</h3>
<p><b>Section:</b> 23.3.4.4 [list.ops] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Pablo Halpern <b>Opened:</b> 2009-09-24 <b>Last modified:</b> 2010-11-13</p>
<p><b>View all other</b> <a href="lwg-index.html#list.ops">issues</a> in [list.ops].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In Bellevue (I think), we passed
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2525.pdf">N2525</a>,
which, among other things, specifies that the behavior of
<tt>list::splice</tt> is undefined if the allocators of the two lists
being spliced do not compare equal. The same rationale should apply to
<tt>list::merge</tt>. The intent of <tt>list::merge</tt> (AFAIK) is to
move nodes from one sorted <tt>list</tt> into another sorted
<tt>list</tt> without copying the elements. This is possible only if the
allocators compare equal.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Relative to the August 2009 WP,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2857.pdf">N2857</a>,
change 23.3.4.4 [list.ops],
paragraphs 22-25 as follows:
</p>

<blockquote>
<pre>
void merge(list&amp;&amp; x);
template &lt;class Compare&gt; void merge(list&amp;&amp; x, Compare comp);
</pre>
<blockquote>
<p>
<i>Requires</i>: both the list and the argument list shall be sorted
according to operator&lt; or comp.
</p>
<p>
<i>Effects</i>: If <tt>(&amp;x == this)</tt> does nothing; otherwise, merges the
two sorted ranges <tt>[begin(), end())</tt> and <tt>[x.begin(),
x.end())</tt>. The result is a range in which the elements will be
sorted in non-decreasing order according to the ordering defined by
<tt>comp</tt>; that is, for every iterator <tt>i</tt>, in the range other than the
<tt>first</tt>, the condition <tt>comp(*i, *(i - 1)<ins>)</ins></tt> will be
<tt>false</tt>.
</p>
<p>
<i>Remarks</i>: Stable. If <tt>(&amp;x != this)</tt> the range <tt>[x.begin(), x.end())</tt> is
empty after the merge. <ins>No elements are copied by this operation.
The behavior is undefined if <tt>this-&gt;get_allocator() !=
x.get_allocator()</tt>.</ins>
</p>
<p>
<i>Complexity</i>: At most <tt>size() + x.size() - 1</tt> applications of <tt>comp</tt>
if <tt>(&amp;x != this)</tt>; otherwise, no applications of <tt>comp</tt> are performed. If an
exception is thrown other than by a comparison there are no effects.
</p>
</blockquote>
</blockquote>





<hr>
<h3><a name="1253"></a>1253. invalidation of iterators and <tt>emplace</tt> vs. <tt>insert</tt> inconsistence in assoc. containers</h3>
<p><b>Section:</b> 23.2.4 [associative.reqmts] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Boris Du&scaron;ek <b>Opened:</b> 2009-10-24 <b>Last modified:</b> 2011-02-23</p>
<p><b>View other</b> <a href="lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In the latest published draft
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2960.pdf">N2960</a>,
section 23.2.4 [associative.reqmts], paragraph 8, it is specified
that that <tt>insert</tt> does not invalidate any iterators. As per
23.2.1 [container.requirements.general], paragraph 12, this holds
true not only for <tt>insert</tt>, but <tt>emplace</tt> as well. This
gives the <tt>insert</tt> member a special treatment w.r.t.
<tt>emplace</tt> member in 23.2.4 [associative.reqmts], par. 8,
since both modify the container. For the sake of consistency, in 23.2.4 [associative.reqmts], par. 8: either reference to <tt>insert</tt> 
should be removed (i.e. count on 23.2.1 [container.requirements.general], 
par. 12), or reference to <tt>emplace</tt> be added (i.e. mention all 
members of assoc. containers that modify it).
</p>

<p><i>[
2009-11-18 Chris provided wording.
]</i></p>


<blockquote><p>
This suggested wording covers both the issue discussed, and a number of other
identical issues (namely <tt>insert</tt> being discussed without <tt>emplace</tt>). I'm happy to
go back and split and introduce a new issue if appropriate, but I think the
changes are fairly mechanical and obvious.
</p></blockquote>

<p><i>[
2010-01-23 Daniel Kr&uuml;gler and J. Daniel Garc&iacute;a updated wording to
make the use of <tt>hint</tt> consistent with <tt>insert</tt>.
]</i></p>


<p><i>[
2011-02-23 Daniel Kr&uuml;gler adapts wording to numbering changes to match the N3225 draft. During this
action it was found that 23.2.5 [unord.req] had been changed considerably
due to acceptance of <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3068.pdf">N3068</a>
during the Pittsburgh meeting, such that the suggested wording change to
p. 6 can no longer be applied. The new wording is more general and should
now include <tt>insert()</tt> and <tt>emplace()</tt> calls as well ("mutating operations").
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Modify bullet 1 of 23.2.1 [container.requirements.general], p11:
</p>

<p>
11 Unless otherwise specified (see 23.2.4.1, 23.2.5.1, 23.3.2.3, and 23.3.5.4)
all container types defined in this Clause meet the following additional
requirements:
</p>

<ul>
<li>
if an exception is thrown by an <tt>insert()</tt> <ins>or
<tt>emplace()</tt></ins> function while inserting a single element, that
function has no effects.
</li>
<li>...</li>
</ul>

<p>
Modify 23.2.4 [associative.reqmts], p4:
</p>

<blockquote><p>
4 An associative container supports <i>unique keys</i> if it may contain at most
one element for each key. Otherwise, it supports <i>equivalent keys</i>. The
<tt>set</tt> and <tt>map</tt> classes support unique keys; the <tt>multiset</tt>
and <tt>multimap</tt> classes support equivalent keys. For <tt>multiset</tt> and
<tt>multimap</tt>, <tt>insert</tt><ins>, <tt>emplace</tt>,</ins> and
<tt>erase</tt> preserve the relative ordering of equivalent elements.
</p></blockquote>

<p>
Modify Table 102 &mdash; Associative container requirements in 
23.2.4 [associative.reqmts]:
</p>

<blockquote>
<table border="1">
<caption>Table 102 &mdash; Associative container requirements (in addition to container)</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion&#47;note<br />pre-&#47;post-condition</th>
<th>Complexity</th>
</tr>

<tr>
<td colspan="4" style="text-align:center;">...</td>
</tr>

<tr>
<td><tt>a_eq.emplace(args)</tt></td>
<td><tt>iterator</tt></td>
<td>[..] <i>Effects:</i> Inserts a <tt>T</tt> object <tt>t</tt> constructed with
<tt>std::forward&lt;Args&gt;(args)...</tt> and returns the iterator pointing to
the newly inserted element. <ins>If a range containing elements equivalent to
<tt>t</tt> exists in <tt>a_eq</tt>, <tt>t</tt> is inserted at the end of that
range.</ins></td>
<td>logarithmic</td>
</tr>

<tr>
<td><tt>a.emplace_hint(p, args)</tt></td>
<td><tt>iterator</tt></td>
<td>equivalent to <tt>a.emplace(std::forward&lt;Args&gt;(args)...)</tt>. Return
value is an iterator pointing to the element with the key equivalent to the
newly inserted element. <del>The <tt>const_iterator p</tt> is a hint pointing to
where the search should start.</del> <ins>The element is inserted as close as
possible to the position just prior to <tt>p</tt>.</ins> <del>Implementations
are permitted to ignore the hint.</del></td>
<td>logarithmic in general, but amortized constant if the element is inserted
right <del>after</del> <ins>before</ins> <tt>p</tt></td>
</tr>

<tr>
<td colspan="4" style="text-align:center;">...</td>
</tr>

</table>
</blockquote>

<p>
Modify 23.2.4 [associative.reqmts], p9:
</p>

<blockquote><p>
9 The <tt>insert</tt> <ins>and <tt>emplace</tt></ins> members shall not affect
the validity of iterators and references to the container, and the
<tt>erase</tt> members shall invalidate only iterators and references to the
erased elements.
</p></blockquote>

<p>
Modify 23.2.4.1 [associative.reqmts.except], p2:
</p>

<blockquote><p>
2 For associative containers, if an exception is thrown by any operation from
within an <tt>insert()</tt> <ins> or <tt>emplace()</tt></ins> function inserting
a single element, the <del><tt>insert()</tt> function</del> <ins>insertion</ins>
has no effect.
</p></blockquote>

<p>
Modify 23.2.5 [unord.req], p13 and p14:
</p>

<blockquote>
<p>
6 An unordered associative container supports <i>unique keys</i> if it may
contain at most one element for each key. Otherwise, it supports <i>equivalent
keys</i>. <tt>unordered_set</tt> and <tt>unordered_map</tt> support unique keys.
<tt>unordered_multiset</tt> and <tt>unordered_multimap</tt> support equivalent
keys. In containers that support equivalent keys, elements with equivalent keys
are adjacent to each other in the iteration order of the container. Thus, although 
the absolute order of elements in an unordered container is not specified, its 
elements are grouped into <i>equivalent-key groups</i> such that all elements of each 
group have equivalent keys. Mutating operations on unordered containers shall 
preserve the relative order of elements within each equivalent-key group unless 
otherwise specified.
</p>

<p>
13 The <tt>insert</tt> <ins>and <tt>emplace</tt></ins> members shall not affect
the validity of references to container elements, but may invalidate all
iterators to the container. The erase members shall invalidate only iterators
and references to the erased elements.
</p>

<p>
14 The <tt>insert</tt> <ins>and <tt>emplace</tt></ins> members shall not affect
the validity of iterators if <tt>(N+n) &lt; z * B</tt>, where <tt>N</tt> is the
number of elements in the container prior to the insert operation, <tt>n</tt> is
the number of elements inserted, <tt>B</tt> is the container's bucket count, and
<tt>z</tt> is the container's maximum load factor.
</p>
</blockquote>

<p>
Modify 23.2.5.1 [unord.req.except], p2:
</p>

<blockquote><p>
2 For unordered associative containers, if an exception is thrown by any
operation other than the container's hash function from within an
<tt>insert()</tt> <ins>or <tt>emplace()</tt></ins> function inserting a single
element, the <del><tt>insert()</tt></del> <ins>insertion</ins>
<del>function</del> has no effect.
</p></blockquote>





<hr>
<h3><a name="1310"></a>1310. <tt>forward_list splice_after</tt> from lvalues</h3>
<p><b>Section:</b> 23.3.3.5 [forwardlist.ops] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2010-02-05 <b>Last modified:</b> 2010-11-13</p>
<p><b>View all other</b> <a href="lwg-index.html#forwardlist.ops">issues</a> in [forwardlist.ops].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
We've moved <a href="lwg-defects.html#1133">1133</a> to Tentatively Ready and I'm fine with that.
</p>

<p>
<a href="lwg-defects.html#1133">1133</a> adds lvalue-references to the <tt>splice</tt> signatures for <tt>list</tt>.  So now
<tt>list</tt> can <tt>splice</tt> from lvalue and rvalue lists (which was the intent of the
original move papers btw).  During the discussion of this issue it was mentioned
that if we want to give the same treatment to <tt>forward_list</tt>, that should be a
separate issue.
</p>

<p>
This is that separate issue.
</p>

<p>
Consider the following case where you want to splice elements from one place in
a <tt>forward_list</tt> to another.  Currently this must be coded like so:
</p>

<blockquote><pre>
fl.splice_after(to_here, std::move(fl), from1, from2);
</pre></blockquote>

<p>
This looks pretty shocking to me.  I would expect to be able to code instead:
</p>

<blockquote><pre>
fl.splice_after(to_here, fl, from1, from2);
</pre></blockquote>

<p>
but we currently don't allow it.
</p>

<p>
When I say <tt>move(fl)</tt>, I consider that as saying that I don't care about
the value of <tt>fl</tt> any more (until I assign it a new value).  But in the
above example, this simply isn't true.  I do care about the value of <tt>fl</tt>
after the move, and I'm not assigning it a new value.  I'm merely permuting its
current value.
</p>

<p>
I propose adding <tt>forward_list&amp;</tt> overloads to the 3
<tt>splice_after</tt> members.  For consistency's sake (principal of least
surprise) I'm also proposing to overload <tt>merge</tt> this way as well.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add to the synopsis of 23.3.3 [forwardlist]:
</p>

<blockquote><pre>
template &lt;class T, class Allocator = allocator&lt;T&gt; &gt;
class forward_list {
public:
  ...
  <ins>void splice_after(const_iterator p, forward_list&amp; x);</ins>
  void splice_after(const_iterator p, forward_list&amp;&amp; x);
  <ins>void splice_after(const_iterator p, forward_list&amp; x, const_iterator i);</ins>
  void splice_after(const_iterator p, forward_list&amp;&amp; x, const_iterator i);
  <ins>void splice_after(const_iterator p, forward_list&amp; x,
                    const_iterator first, const_iterator last);</ins>
  void splice_after(const_iterator p, forward_list&amp;&amp; x,
                    const_iterator first, const_iterator last);
  ...
  <ins>void merge(forward_list&amp; x);</ins>
  void merge(forward_list&amp;&amp; x);
  <ins>template &lt;class Compare&gt; void merge(forward_list&amp; x, Compare comp);</ins>
  template &lt;class Compare&gt; void merge(forward_list&amp;&amp; x, Compare comp);
  ...
};
</pre></blockquote>

<p>
Add to the signatures of 23.3.3.5 [forwardlist.ops]:
</p>

<blockquote>
<pre>
<ins>void splice_after(const_iterator p, forward_list&amp; x);</ins>
void splice_after(const_iterator p, forward_list&amp;&amp; x);
</pre>
<blockquote>
<p>1 ...</p>
</blockquote>

<pre>
<ins>void splice_after(const_iterator p, forward_list&amp; x, const_iterator i);</ins>
void splice_after(const_iterator p, forward_list&amp;&amp; x, const_iterator i);
</pre>
<blockquote>
<p>5 ...</p>
</blockquote>

<pre>
<ins>void splice_after(const_iterator p, forward_list&amp; x,
                const_iterator first, const_iterator last);</ins>
void splice_after(const_iterator p, forward_list&amp;&amp; x,
                const_iterator first, const_iterator last);
</pre>
<blockquote>
<p>9 ...</p>
</blockquote>

<pre>
<ins>void merge(forward_list&amp; x);</ins>
void merge(forward_list&amp;&amp; x);
<ins>template &lt;class Compare&gt; void merge(forward_list&amp; x, Compare comp);</ins>
template &lt;class Compare&gt; void merge(forward_list&amp;&amp; x, Compare comp);
</pre>
<blockquote>
<p>18 ...</p>
</blockquote>

</blockquote>






<hr>
<h3><a name="1320"></a>1320. Header for <tt>iter_swap</tt></h3>
<p><b>Section:</b> 24.3 [iterator.synopsis] <b>Status:</b> <a href="lwg-active.html#NAD Future">Tentatively NAD Future</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2010-02-16 <b>Last modified:</b> 2010-11-13</p>
<p><b>Discussion:</b></p>
<p>
The <tt>iter_swap</tt> function template appears in the
<tt>&lt;algorithm&gt;</tt> header, yet its main use is in building further
algorithms, not calling existing ones. The main clients are implementers of data
structures and their iterators, so it seems most appropriate to place the
template in the <tt>&lt;iterator&gt;</tt> header instead.
</p>

<p>
Note that this is not an issue for implementers of the standard library, as they
rarely use the standard headers directly, designing a more fine-grained set of
headers for their own internal use.  This option is not available to customers
of the standard library.
</p>

<p>
Note that we cannot remove <tt>iter_swap</tt> from <tt>&lt;algorithm&gt;</tt>
without breaking code, but there is no reason we cannot offer the same
declaration via two standard headers.  Alternatively, require
<tt>&lt;algorithm&gt;</tt> to <tt>#include &lt;iterator&gt;</tt>, but
introducing the dependency on the iterator adaptors seems un-necessary.
</p>

<p><i>[
]</i></p>


<p>
Discussed possibly moving to <tt>&lt;utility&gt;</tt> but don't like that. Some not seeing this 
as a defect, and want to keep it in <tt>&lt;algorithm&gt;</tt>. No one seems to feel strongly 
about moving to <tt>&lt;iterator&gt;</tt>.
</p>


<p><b>Proposed resolution:</b></p>

<p>
Add the declaration of <tt>iter_swap</tt> to the <tt>&lt;iterator&gt;</tt>
header synopsis (24.3 [iterator.synopsis]), with a note that it is
documented in clause 25 [algorithms].
</p>

<blockquote><pre>
...
template &lt;class T, size_t N&gt; T* end(T (&amp;array)[N]);

<ins><i>// documented in 25 [algorithms]</i>
template&lt;class ForwardIterator1, class ForwardIterator2&gt;
  void iter_swap(ForwardIterator1 a, ForwardIterator2 b);</ins>
</pre></blockquote>






<hr>
<h3><a name="1371"></a>1371. [FCD] standard exceptions require stronger no-throw guarantees</h3>
<p><b>Section:</b> 19 [diagnostics] <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2011-02-20</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-75</b></p>
<p>
None of the exception types defined in clause 19 are
allowed to throw an exception on copy or move
operations, but there is no clear specification that the
operations have an exception specification to prove it.
Note that the implicitly declared constructors, taking the
exception specification from their base class (ultimately
<tt>std::exception</tt>) will implicitly generate a <tt>noexcept</tt>
exception specification if all of their data members
similarly declare <tt>noexcept</tt> operations. As the
representation is unspecified, we cannot assume nonthrowing
operations unless we explicitly state this as a
constraint on the implementation.
</p>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<p>
Add a global guarantee that all exception types
defined in clause 19 that rely on implicitly declared
operations have a non-throwing exception
specification on those operations.
</p>

<p><i>[
2010 Batavia:
]</i></p>

<p>
This is addressed by the current words in 18.8.1 [exception], p2
</p>
<blockquote><p>
Each standard library class <tt>T</tt> that derives from class <tt>exception</tt> 
shall have a publicly accessible copy constructor and a publicly accessible copy
assignment operator that do not exit with an exception.
</p></blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1413"></a>1413. [FCD] Specify whether <tt>high_resolution_clock</tt> is a distinct type or a typedef</h3>
<p><b>Section:</b> 20.11.5.3 [time.clock.hires] <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-16</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-112</b></p>
<p>
What it means for <tt>high_resolution_clock</tt> to be a synonym
is undefined. If it may or may not be a typedef, then
certain classes of programs become unportable.
</p>

<p><i>[
Resolution proposed in ballot comment
]</i></p>

<p>
Require that it be a distinct class type.
</p>

<p><i>[
2010 Batavia
]</i></p>

<p>
This is not a defect.  Threre are a number of places in the standard where
we allow implentations to choose their preferred technique, the most obvious
example being the <tt>iterator</tt>/<tt>const_iterator</tt> types of <tt>set</tt>.
</p>
<p>
Typically, this means it is not portable to declare function overloads that differ
only in their use of these types.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1456"></a>1456. [FCD] Missing fixed-size atomic_ typedefs</h3>
<p><b>Section:</b> 29 [atomics] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2011-02-20</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics">active issues</a> in [atomics].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics">issues</a> in [atomics].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-129</b></p>
<p>
Table 143 lists the typedefs for various atomic types
corresponding to the various standard integer typedefs,
such as <tt>atomic_int_least8_t</tt> for <tt>int_least8_t</tt>, and
<tt>atomic_uint_fast64_t</tt> for <tt>uint_fast64_t</tt>. However, there are
no atomic typedefs corresponding to the fixed-size
standard typedefs <tt>int8_t</tt>, <tt>int16_t</tt>, and so forth.
</p>
<p><i>[
2010-10-24 Daniel adds:
]</i></p>


<blockquote><p>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3164.html">n3164</a> would solve this issue.
</p></blockquote>

<p><i>[
2011-02-15 Anthony corrects numbering/naming for N3225, Howard suggests improvement for the position
of '(optional)', Daniel reorders rows in harmony to remaining entries and suggests specific optionality
comments:
]</i></p>


<p><i>[2011-02-16 Reflector discussion]</i></p>

<p>
Moved to Tentatively Ready after 5 votes.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add the following entries to table 143:
</p>
<blockquote>
<table border="1">
<caption>Table 146 &mdash; <tt>atomic</tt> <tt>&lt;inttypes.h&gt;</tt> typedefs</caption>
<tr>
<th>Atomic typedef</th>
<th><tt>&lt;inttypes.h&gt;</tt> type</th>
</tr>
<tr>
<td><tt>...</tt></td>
<td><tt>...</tt></td>
</tr>
<tr>
<td><tt>atomic_intmax_t</tt></td>
<td><tt>intmax_t</tt></td>
</tr>
<tr>
<td><tt>atomic_uintmax_t</tt></td>
<td><tt>uintmax_t</tt></td>
</tr>
<tr>
<td><ins><tt>atomic_int8_t&nbsp;</tt>// <em>iff <tt>int8_t</tt> is provided</em></ins></td>
<td><ins><tt>int8_t</tt></ins></td>
</tr>
<tr>
<td><ins><tt>atomic_uint8_t&nbsp;</tt>// <em>iff <tt>uint8_t</tt> is provided</em></ins></td>
<td><ins><tt>uint8_t</tt></ins></td>
</tr>
<tr>
<td><ins><tt>atomic_int16_t&nbsp;</tt>// <em>iff <tt>int16_t</tt> is provided</em></ins></td>
<td><ins><tt>int16_t</tt></ins></td>
</tr>
<tr>
<td><ins><tt>atomic_uint16_t&nbsp;</tt>// <em>iff <tt>uint16_t</tt> is provided</em></ins></td>
<td><ins><tt>uint16_t</tt></ins></td>
</tr>
<tr>
<td><ins><tt>atomic_int32_t&nbsp;</tt>// <em>iff <tt>int32_t</tt> is provided</em></ins></td>
<td><ins><tt>int32_t</tt></ins></td>
</tr>
<tr>
<td><ins><tt>atomic_uint32_t&nbsp;</tt>// <em>iff <tt>uint32_t</tt> is provided</em></ins></td>
<td><ins><tt>uint32_t</tt></ins></td>
</tr>
<tr>
<td><ins><tt>atomic_int64_t&nbsp;</tt>// <em>iff <tt>int64_t</tt> is provided</em></ins></td>
<td><ins><tt>int64_t</tt></ins></td>
</tr>
<tr>
<td><ins><tt>atomic_uint64_t&nbsp;</tt>// <em>iff <tt>uint64_t</tt> is provided</em></ins></td>
<td><ins><tt>uint64_t</tt></ins></td>
</tr>
</table>
</blockquote> 





<hr>
<h3><a name="1457"></a>1457. [FCD] Splitting lock-free properties</h3>
<p><b>Section:</b> 29.2 [atomics.syn] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2011-02-24</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-130</b></p>
<p>
The synopsis for the <tt>&lt;atomic&gt;</tt> header lists the macros
<tt>ATOMIC_INTEGRAL_LOCK_FREE</tt> and <tt>ATOMIC_ADDRESS_LOCK_FREE</tt>.
</p>
<p>
The <tt>ATOMIC_INTEGRAL_LOCK_FREE</tt> macro has been replaced with a set of macros 
for each integral type, as listed in 29.4 [atomics.lockfree].
</p>

<p><i>[Proposed resolution as of comment]</i></p>


<blockquote>
<p>
Against FCD, N3092:
</p>
<p>
In [atomics.syn], header <tt>&lt;atomic&gt;</tt> synopsis replace as indicated:
</p>
<blockquote><pre>
// 29.4, lock-free property
<del>#define ATOMIC_INTEGRAL_LOCK_FREE <em>unspecified</em></del>
<ins>#define ATOMIC_CHAR_LOCK_FREE <em>implementation-defined</em></ins>
<ins>#define ATOMIC_CHAR16_T_LOCK_FREE <em>implementation-defined</em></ins>
<ins>#define ATOMIC_CHAR32_T_LOCK_FREE <em>implementation-defined</em></ins>
<ins>#define ATOMIC_WCHAR_T_LOCK_FREE <em>implementation-defined</em></ins>
<ins>#define ATOMIC_SHORT_LOCK_FREE <em>implementation-defined</em></ins>
<ins>#define ATOMIC_INT_LOCK_FREE <em>implementation-defined</em></ins>
<ins>#define ATOMIC_LONG_LOCK_FREE <em>implementation-defined</em></ins>
<ins>#define ATOMIC_LLONG_LOCK_FREE <em>implementation-defined</em></ins>
#define ATOMIC_ADDRESS_LOCK_FREE <em>unspecified</em>
</pre></blockquote>
</blockquote>

<p><i>[
2010-10-26: Daniel adds:
]</i></p>


<p>
The proposed resolution below is against the FCD working draft. After application
of the editorial issues <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3162.html#US144">US-144</a>
and <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3162.html#US146">US-146</a> the remaining difference
against the working draft is the usage of <em>implementation-defined</em> instead of <em>unspecified</em>, effectively
resulting in this delta:
</p>

<blockquote><pre>
// 29.4, lock-free property
#define ATOMIC_CHAR_LOCK_FREE <del><em>unspecified</em></del><ins><em>implementation-defined</em></ins>
#define ATOMIC_CHAR16_T_LOCK_FREE <del><em>unspecified</em></del><ins><em>implementation-defined</em></ins>
#define ATOMIC_CHAR32_T_LOCK_FREE <del><em>unspecified</em></del><ins><em>implementation-defined</em></ins>
#define ATOMIC_WCHAR_T_LOCK_FREE <del><em>unspecified</em></del><ins><em>implementation-defined</em></ins>
#define ATOMIC_SHORT_LOCK_FREE <del><em>unspecified</em></del><ins><em>implementation-defined</em></ins>
#define ATOMIC_INT_LOCK_FREE <del><em>unspecified</em></del><ins><em>implementation-defined</em></ins>
#define ATOMIC_LONG_LOCK_FREE <del><em>unspecified</em></del><ins><em>implementation-defined</em></ins>
#define ATOMIC_LLONG_LOCK_FREE <del><em>unspecified</em></del><ins><em>implementation-defined</em></ins>
#define ATOMIC_ADDRESS_LOCK_FREE <em>unspecified</em>
</pre></blockquote>

<p>
It is my understanding that the intended wording should be <em>unspecified</em> as for <tt>ATOMIC_ADDRESS_LOCK_FREE</tt>
but if this is right, we need to use the same wording in 29.4 [atomics.lockfree], which consequently uses
the term <em>implementation-defined</em>. I recommend to keep 29.2 [atomics.syn] as it currently is and to
fix 29.4 [atomics.lockfree] instead as indicated:
</p>

<p><i>[2011-02-24 Reflector discussion]</i></p>

<p>
Moved to Tentatively Ready after 5 votes.
</p> 


<p><i>[2011-02-20: Daniel adapts the proposed wording to N3225 and fixes an editorial omission of
applying <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3193.htm">N3193</a>]</i></p>


<p><b>Proposed resolution:</b></p>
<p>
Change 29.4 [atomics.lockfree] as indicated (The removal of the <tt>ATOMIC_ADDRESS_LOCK_FREE</tt>
is an editorial step, because that macro was removed when <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3193.htm">N3193</a>
was accepted during the Batavia meeting):
</p>
<blockquote><pre>
#define ATOMIC_CHAR_LOCK_FREE <del><em>implementation-defined</em></del><ins><em>unspecified</em></ins>
#define ATOMIC_CHAR16_T_LOCK_FREE <del><em>implementation-defined</em></del><ins><em>unspecified</em></ins>
#define ATOMIC_CHAR32_T_LOCK_FREE <del><em>implementation-defined</em></del><ins><em>unspecified</em></ins>
#define ATOMIC_WCHAR_T_LOCK_FREE <del><em>implementation-defined</em></del><ins><em>unspecified</em></ins>
#define ATOMIC_SHORT_LOCK_FREE <del><em>implementation-defined</em></del><ins><em>unspecified</em></ins>
#define ATOMIC_INT_LOCK_FREE <del><em>implementation-defined</em></del><ins><em>unspecified</em></ins>
#define ATOMIC_LONG_LOCK_FREE <del><em>implementation-defined</em></del><ins><em>unspecified</em></ins>
#define ATOMIC_LLONG_LOCK_FREE <del><em>implementation-defined</em></del><ins><em>unspecified</em></ins>
<del>#define ATOMIC_ADDRESS_LOCK_FREE <em>implementation-defined</em></del>
</pre></blockquote>





<hr>
<h3><a name="1474"></a>1474. [FCD] weak compare-and-exchange confusion</h3>
<p><b>Section:</b> 29.6.5 [atomics.types.operations.req] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2011-02-24</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Duplicate of:</b> <a href="lwg-closed.html#1470">1470</a>, <a href="lwg-closed.html#1475">1475</a>, <a href="lwg-closed.html#1476">1476</a>, <a href="lwg-closed.html#1477">1477</a></p>
<p><b>Discussion:</b></p>



<p><b>Addresses US-175, US-165, CH-23, GB-135</b></p>
<p>
29.6.5 [atomics.types.operations.req] p. 25: The first sentence is grammatically incorrect.
</p>
<p><i>[
2010-10-28 Daniel adds:
]</i></p>

<p>
Duplicate issue <a href="lwg-closed.html#1475">1475</a> also has a proposed resolution, but both issues are resolved with
below proposed resolution.
</p>

<p><i>[
2011-02-15 Howard fixes numbering, Hans improves the wording
]</i></p>


<p><i>[2011-02-24 Reflector discussion]</i></p>

<p>
Moved to Tentatively Ready after 6 votes.
</p> 


<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>Change 29.6.5 [atomics.types.operations.req] p. 23 as indicated:</p>

<blockquote><p>
[ <em>Note</em>: <ins>For example, t</ins><del>T</del>he effect of 
<del>the compare-and-exchange operations</del><ins><tt>atomic_compare_exchange_strong</tt></ins> is
</p><blockquote><pre>
if (memcmp(object, expected, sizeof(*object)) == 0)
  memcpy(object, &amp;desired, sizeof(*object));
else
  memcpy(expected, object, sizeof(*object));
</pre></blockquote>
<p> &mdash; <em>end note</em> ] [..]</p>
</blockquote>
</li>

<li>
<p>Change 29.6.5 [atomics.types.operations.req] p. 25 as indicated:</p>
<blockquote><p>
25 <em>Remark</em>: <del>The weak compare-and-exchange operations may fail spuriously, that is, return false while
leaving the contents of memory pointed to by <tt>expected</tt> before the operation is the same that same
as that of the <tt>object</tt> and the same as that of <tt>expected</tt> after the operation</del><ins>A weak 
compare-and-exchange operation may fail spuriously. That is, even when the contents of memory referred to by 
<tt>expected</tt> and <tt>object</tt> are equal, it may return false and store back to <tt>expected</tt> the same 
memory contents that were originally there.</ins>. [ <em>Note</em>: This spurious
failure enables implementation of compare-and-exchange on a broader class of machines, e.g., loadlocked
store-conditional machines. A consequence of spurious failure is that nearly all uses of weak
compare-and-exchange will be in a loop.
<p/>
When a compare-and-exchange is in a loop, the weak version will yield better performance on some
platforms. When a weak compare-and-exchange would require a loop and a strong one would not, the
strong one is preferable. &mdash; <em>end note</em> ]
</p>
</blockquote>
</li>
</ol>





<hr>
<h3><a name="1479"></a>1479. [FCD] Fence functions should be <tt>extern "C"</tt></h3>
<p><b>Section:</b> 29.8 [atomics.fences] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2011-02-20</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics.fences">active issues</a> in [atomics.fences].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.fences">issues</a> in [atomics.fences].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-179</b></p>
<p>
The fence functions (29.8 [atomics.fences] p.5 + p.6) should be <tt>extern "C"</tt>, for <tt>C</tt> compatibility.
</p>

<p><i>[2011-02-16 Reflector discussion]</i></p>

<p>
Moved to Tentatively Ready after 6 votes.
</p>



<p><b>Proposed resolution:</b></p>
<ol>
<li>Change 29.2 [atomics.syn], header <tt>&lt;atomic&gt;</tt> synopsis as indicated:
<blockquote><pre>
namespace std {
  [..]
  // <em>29.8, fences</em>
  <ins>extern "C"</ins> void atomic_thread_fence(memory_order);
  <ins>extern "C"</ins> void atomic_signal_fence(memory_order);  
}
</pre></blockquote>
</li>
<li><p>Change 29.8 [atomics.fences], p. 5 and p. 6 as indicated:</p>
<blockquote><pre>
<ins>extern "C"</ins> void atomic_thread_fence(memory_order);
</pre><blockquote><p>
5 <em>Effects</em>: depending on the value of <tt>order</tt>, this operation: [..]
</p></blockquote></blockquote>
<blockquote><pre>
<ins>extern "C"</ins> void atomic_signal_fence(memory_order);  
</pre><blockquote><p>
6 <em>Effects</em>: equivalent to <tt>atomic_thread_fence(order)</tt>, except that synchronizes with relationships are
established only between a thread and a signal handler executed in the same thread.
</p></blockquote></blockquote>
</li>
</ol>





<hr>
<h3><a name="1485"></a>1485. [FCD] Unclear <tt>thread::id</tt> specification</h3>
<p><b>Section:</b> 30.3.1.1 [thread.thread.id] <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2011-02-20</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.thread.id">issues</a> in [thread.thread.id].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-184</b></p>
<p>
It is unclear when a <tt>thread::id</tt> ceases to be meaningful.
The sentence "The library may reuse the value of a
<tt>thread::id</tt> of a terminated thread that can no longer be
joined." implies that some terminated threads can be
joined. It says nothing about detached threads.
</p>
<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote><p>
Require a unique <tt>thread::id</tt> for every thread that is
(1) detached and not terminated or (2) has an associated <tt>std::thread</tt> 
object.
</p></blockquote>

<p><i>[
2010-11-22 Howard Hinnant observes
]</i></p>


<p>
A thread can either be running or terminated. Additionally a thread can be joined, detached, or neither.  
These combine into the five possible states shown in this table:
</p>

<table border="1">
<tr>
<th></th><th>Running</th><th>Terminated</th>
</tr>
<tr>
<th>Neither joined nor detached</th><td>shall not reuse id</td><td>shall not reuse id</td>
</tr>
<tr>
<th>detached</th><td>shall not reuse id</td><td>may reuse id</td>
</tr>
<tr>
<th>joined</th><td>impossible state</td><td>may reuse id</td>
</tr>
</table>
<p>
Only if a thread is neither joined nor detached can it be joined. Or said differently, if a 
thread has already been joined or detached, then it can not be joined. The sentence:
</p>
<blockquote><p>
The library may reuse the value of a <tt>thread::id</tt> of a terminated thread that can no longer be joined.
</p></blockquote>
<p>
precisely defines the two states shown in the above table where a thread::id may be reused.
</p>
<p>
The following program illustrates all of the possibilities:
</p>
<blockquote><pre>
#include &lt;mutex>
#include &lt;thread>
#include &lt;iostream>
#include &lt;chrono>

std::mutex mut;

void f()
{
   std::lock_guard&lt;std::mutex&gt; _(mut);
   std::cout &lt;&lt; "f id = " &lt;&lt; std::this_thread::get_id() &lt;&lt; " terminating\n";
}

void g()
{
   std::lock_guard&lt;std::mutex&gt; _(mut);
   std::cout &lt;&lt; "g id = " &lt;&lt; std::this_thread::get_id() &lt;&lt; " terminating\n";
}

int main()
{
   std::cout &lt;&lt; "main id = " &lt;&lt; std::this_thread::get_id() &lt;&lt; "\n";
   std::thread t1(f);
   std::thread(g).detach();
   std::this_thread::sleep_for(std::chrono::seconds(1));
   std::cout &lt;&lt; "g's thread::id can be reused here because g has terminated and is detached.\n";
   std::cout &lt;&lt; "f's thread::id can't be reused here because f has terminated but is still joinable.\n";
   std::cout &lt;&lt; "f id = " &lt;&lt; t1.get_id() &lt;&lt; "\n";
   t1.join();
   std::cout &lt;&lt; "f's thread::id can be reused here because f has terminated and is joined.\n";
   std::cout &lt;&lt; "f id = " &lt;&lt; t1.get_id() &lt;&lt; "\n";
}

main id = 0x7fff71197ca0
f id = 0x100381000 terminating
g id = 0x100581000 terminating
g's thread::id can be reused here because g has terminated and is detached.
f's thread::id can't be reused here because f has terminated but is still joinable.
f id = 0x100381000
f's thread::id can be reused here because f has terminated and is joined.
f id = 0x0
</pre></blockquote>

<p><i>[2011-02-11 Reflector discussion]</i></p>

<p>
Moved to Tentatively NAD after 5 votes.
</p>




<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1486"></a>1486. [FCD] Value of <tt>this_thread::get_id()</tt> underspecified for detached thread</h3>
<p><b>Section:</b> 30.3.2 [thread.thread.this] <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Switzerland <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2011-02-20</p>
<p><b>View other</b> <a href="lwg-index-open.html#thread.thread.this">active issues</a> in [thread.thread.this].</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.thread.this">issues</a> in [thread.thread.this].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses CH-24</b></p>
<p>
What would be the value <tt>this_thread::get_id()</tt> when called from a detached thread?
</p>
<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<p>
Add some text to clarify that <tt>get_id()</tt> still returns the same value even after detaching.
</p>

<p><i>[
2010-11-22 Howard Hinnant observes
]</i></p>


<p>
30.3.2 [thread.thread.this]/1 contains the following sentence describing <tt>this_thread::get_id()</tt>:
</p>

<blockquote><p>
... No other thread of execution shall have this id and this thread of execution shall always have this id.
</p></blockquote>

<p>I don't object to adding "even if detached" to this sentence, but it seems unnecessary to me. "Always" means always.</p>

<p><i>[2011-02-11 Reflector discussion]</i></p>

<p>
Moved to Tentatively NAD after 5 votes.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1497"></a>1497. [FCD] <tt>lock()</tt> postcondition can not be generally achieved</h3>
<p><b>Section:</b> 30.5 [thread.condition] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Switzerland <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2011-02-20</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.condition">issues</a> in [thread.condition].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses CH-30</b></p>
<p>
If <tt>lock.lock()</tt> throws an exception, the postcondition can not be generally achieved.
</p>
<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote><p>
Either state that the postcondition might not be achieved, depending on the error condition, or
state that <tt>terminate()</tt> is called in this case.
</p></blockquote>

<p><i>[
2010-08-13 Peter Sommerlad comments and provides wording
]</i></p>


<blockquote><p>
30.5.1 [thread.condition.condvar], 30.5.2 [thread.condition.condvarany]
<p/>
p. 13, last bullet, and corresponding paragraphs in all wait functions
<p/>
Problem:<br/>
Condition variable wait might fail, because the lock cannot be acquired when notified.
CH-30 says: "If lock.lock() throws an exception, the postcondition can not be generally achieved."
CH-30 proposes: "Either state that the postcondition might not be achieved, depending on the error 
condition, or state that terminate() is called in this case."
<p/>
The discussion in Rapperswil concluded that calling <tt>terminate()</tt> might be too drastic in 
this case and a corresponding exception should be thrown&#47;passed on and one should use a lock type 
that allows querying its status, which <tt>unique_lock</tt> allows for <tt>std::condition_variable</tt>
<p/>
We also had some additional observations while discussing in Rapperswil:
</p>
<ul>
<li>in 30.5.1 [thread.condition.condvar] <tt>wait</tt> with predicate and <tt>wait_until</tt> with 
predicate lack the precondition, postcondition and Error conditions sections. the lack of the precondition 
would allow to call <tt>pred()</tt> without holding the lock.
</li>
<li>in 30.5.1 [thread.condition.condvar] <tt>wait_until</tt> and <tt>wait_for</tt> and 
30.5.2 [thread.condition.condvarany] <tt>wait_for</tt> still specify an 
error condition for a violated precondition. This should be removed.
</li>
</ul>
<p>
and add the following proposed solution:
</p>
</blockquote>


<p><b>Proposed resolution:</b></p>
<ol>
<li>Change 30.5.1 [thread.condition.condvar] as indicated:
<blockquote><pre>
void wait(unique_lock&lt;mutex&gt;&amp; lock);
</pre></blockquote>
<blockquote><p>
12 <i>Requires</i>: <tt>lock</tt><ins><tt>.owns_lock()</tt> is <tt>true</tt> and <tt>lock.mutex()</tt></ins> is locked by the calling thread, and either
</p>
<ul>
<li>no other thread is waiting on this <tt>condition_variable</tt> object or
</li>
<li><tt>lock.mutex()</tt> returns the same value for each of the <tt>lock</tt> arguments supplied by all concurrently
waiting (via <tt>wait</tt> or <tt>timed_wait</tt>) threads.
</li>
</ul>
</blockquote>
[..]
<blockquote><p>
14 <em>Postcondition</em>: <tt>lock</tt><ins><tt>.owns_lock()</tt> is <tt>true</tt> and <tt>lock.mutex()</tt></ins> is locked by the calling thread.
</p></blockquote>
[..]
<blockquote><pre>
template &lt;class Predicate&gt;
void wait(unique_lock&lt;mutex&gt;&amp; lock, Predicate pred);
</pre></blockquote>
<blockquote><p>
<ins>?? <i>Requires</i>: <tt>lock.owns_lock()</tt> is <tt>true</tt> and <tt>lock.mutex()</tt> is locked by the calling thread, and either</ins>
</p>
<ul>
<li><ins>no other thread is waiting on this <tt>condition_variable</tt> object or</ins>
</li>
<li><ins><tt>lock.mutex()</tt> returns the same value for each of the <tt>lock</tt> arguments supplied by all concurrently
waiting (via <tt>wait</tt> or <tt>timed_wait</tt>) threads.</ins>
</li>
</ul>
</blockquote>
<blockquote><p>
17 <i>Effects</i>:
</p><blockquote><pre>
while (!pred())
  wait(lock);
</pre></blockquote>
</blockquote>

<blockquote><p>
<ins>?? <i>Postcondition</i>: <tt>lock.owns_lock()</tt> is <tt>true</tt> and <tt>lock.mutex()</tt> is locked by the calling thread.</ins>
</p></blockquote>
<blockquote><p>
<ins>?? <i>Throws</i>: <tt>std::system_error</tt> when an exception is required (30.2.2).</ins>
</p></blockquote>
<blockquote><p>
<ins>?? <em>Error conditions</em>:</ins>
</p>
<ul>
<li><ins>equivalent error condition from <tt>lock.lock()</tt> or <tt>lock.unlock()</tt>.</ins>
</li>
</ul>
</blockquote>

<blockquote><pre>
template &lt;class Clock, class Duration&gt;
cv_status wait_until(unique_lock&lt;mutex&gt;&amp; lock,
  const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);
</pre></blockquote>
<blockquote><p>
18 <i>Requires</i>: <tt>lock</tt><ins><tt>.owns_lock()</tt> is <tt>true</tt> and <tt>lock.mutex()</tt></ins> is locked by the calling thread, and either
</p>
<ul>
<li>no other thread is waiting on this <tt>condition_variable</tt> object or
</li>
<li><tt>lock.mutex()</tt> returns the same value for each of the <tt>lock</tt> arguments supplied by all concurrently
waiting (via <tt>wait</tt>, <tt>wait_for</tt>, or <tt>wait_until</tt>) threads.
</li>
</ul>
</blockquote><p>
[..]
</p><blockquote><p>
20 <em>Postcondition</em>: <tt>lock</tt><ins><tt>.owns_lock()</tt> is <tt>true</tt> and <tt>lock.mutex()</tt></ins> is locked by the calling thread.
</p></blockquote>
[..]
<blockquote><p>
23 <em>Error conditions</em>:
</p>
<ul>
<li><del><tt>operation_not_permitted</tt> &mdash; if the thread does not own the lock.</del>
</li>
<li>equivalent error condition from <tt>lock.lock()</tt> or <tt>lock.unlock()</tt>.
</li>
</ul>
</blockquote>
<blockquote><pre>
template &lt;class Rep, class Period&gt;
cv_status wait_for(unique_lock&lt;mutex&gt;&amp; lock,
  const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
</pre></blockquote>
<blockquote><p>
24 <i>Requires</i>: <tt>lock</tt><ins><tt>.owns_lock()</tt> is <tt>true</tt> and <tt>lock.mutex()</tt></ins> is locked by the calling thread, and either
</p>
<ul>
<li>no other thread is waiting on this <tt>condition_variable</tt> object or
</li>
<li><tt>lock.mutex()</tt> returns the same value for each of the <tt>lock</tt> arguments supplied by all concurrently
waiting (via <tt>wait</tt>, <tt>wait_for</tt>, or <tt>wait_until</tt>) threads.
</li>
</ul>
</blockquote><p>
[..]
</p><blockquote><p>
27 <em>Postcondition</em>: <tt>lock</tt><ins><tt>.owns_lock()</tt> is <tt>true</tt> and <tt>lock.mutex()</tt></ins> is locked by the calling thread.
</p></blockquote>
[..]
<blockquote><p>
29 <em>Error conditions</em>:
</p>
<ul>
<li><del><tt>operation_not_permitted</tt> &mdash; if the thread does not own the lock.</del>
</li>
<li>equivalent error condition from <tt>lock.lock()</tt> or <tt>lock.unlock()</tt>.
</li>
</ul>
</blockquote>
<blockquote><pre>
template &lt;class Clock, class Duration, class Predicate&gt;
bool wait_until(unique_lock&lt;mutex&gt;&amp; lock,
  const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time,
    Predicate pred);
</pre></blockquote>
<blockquote><p>
<ins>?? <i>Requires</i>: <tt>lock.owns_lock()</tt> is <tt>true</tt> and <tt>lock.mutex()</tt> is locked by the calling thread, and either</ins>
</p>
<ul>
<li><ins>no other thread is waiting on this <tt>condition_variable</tt> object or</ins>
</li>
<li><ins><tt>lock.mutex()</tt> returns the same value for each of the <tt>lock</tt> arguments supplied by all concurrently
waiting (via <tt>wait</tt> or <tt>timed_wait</tt>) threads.</ins>
</li>
</ul>
</blockquote>
<blockquote><p>
30 <i>Effects</i>:
</p><blockquote><pre>
while (!pred())
  if (wait_until(lock, abs_time) == cv_status::timeout)
    return pred();
return true;
</pre></blockquote>
</blockquote>
<blockquote><p>
31 <i>Returns</i>: <tt>pred()</tt>
</p></blockquote>

<blockquote><p>
<ins>?? <i>Postcondition</i>: <tt>lock.owns_lock()</tt> is <tt>true</tt> and <tt>lock.mutex()</tt> is locked by the calling thread.</ins>
</p></blockquote>

<blockquote><p>
32 [ <i>Note</i>: The returned value indicates whether the predicate evaluates to true regardless of whether the
timeout was triggered. &mdash; <i>end note</i> ]
</p></blockquote>

<blockquote><p>
<ins>?? <i>Throws</i>: <tt>std::system_error</tt> when an exception is required (30.2.2).</ins>
</p></blockquote>
<blockquote><p>
<ins>?? <em>Error conditions</em>:</ins>
</p>
<ul>
<li><ins>equivalent error condition from <tt>lock.lock()</tt> or <tt>lock.unlock()</tt>.</ins>
</li>
</ul>
</blockquote>

<blockquote><pre>
template &lt;class Rep, class Period, class Predicate&gt;
bool wait_for(unique_lock&lt;mutex&gt;&amp; lock,
  const chrono::duration&lt;Rep, Period&gt;&amp; rel_time,
    Predicate pred);
</pre></blockquote>
<blockquote><p>
33 <i>Requires</i>: <tt>lock</tt><ins><tt>.owns_lock()</tt> is <tt>true</tt> and <tt>lock.mutex()</tt></ins> is locked by the calling thread, and either
</p>
<ul>
<li>no other thread is waiting on this <tt>condition_variable</tt> object or
</li>
<li><tt>lock.mutex()</tt> returns the same value for each of the <tt>lock</tt> arguments supplied by all concurrently
waiting (via <tt>wait</tt>, <tt>wait_for</tt>, or <tt>wait_until</tt>) threads.
</li>
</ul>
</blockquote><p>
[..]
</p><blockquote><p>
36 <em>Postcondition</em>: <tt>lock</tt><ins><tt>.owns_lock()</tt> is <tt>true</tt> and <tt>lock.mutex()</tt></ins> is locked by the calling thread.
</p></blockquote><p>
[..]
</p><blockquote><p>
40 <em>Error conditions</em>:
</p>
<ul>
<li><del><tt>operation_not_permitted</tt> &mdash; if the thread does not own the lock.</del>
</li>
<li>equivalent error condition from <tt>lock.lock()</tt> or <tt>lock.unlock()</tt>.
</li>
</ul>
</blockquote>

</li>

<li>Change 30.5.2 [thread.condition.condvarany] as indicated:
<p/>
[..]
<blockquote><pre>
template &lt;class Lock, class Predicate&gt;
void wait(Lock&amp; lock, Predicate pred);
</pre></blockquote>
<blockquote><p>
<ins>[<i>Note</i>: if any of the wait functions exits with an exception it is indeterminate if the <tt>Lock</tt> is held. 
One can use a <tt>Lock</tt> type that allows to query that, such as the <tt>unique_lock</tt> wrapper. &mdash; <i>end note</i>]</ins>
</p></blockquote>
<blockquote><p>
14 <i>Effects</i>:
</p><blockquote><pre>
while (!pred())
  wait(lock);
</pre></blockquote>
</blockquote><p>
[..]
</p><blockquote><p>
34 <em>Error conditions</em>:
</p>
<ul>
<li><del><tt>operation_not_permitted</tt> &mdash; if the thread does not own the lock.</del>
</li>
<li>equivalent error condition from <tt>lock.lock()</tt> or <tt>lock.unlock()</tt>.
</li>
</ul>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="1514"></a>1514. [FCD] <tt>packaged_task</tt> constructors need review</h3>
<p><b>Section:</b> 30.6.10.1 [futures.task.members] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2011-02-20</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures.task.members">active issues</a> in [futures.task.members].</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.task.members">issues</a> in [futures.task.members].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-207</b></p>
<p>
The constructor that takes <tt>R(*)(ArgTypes...)</tt> is not
needed; the constructor that takes a callable type works
for this argument type. More generally, the constructors
for packaged_task should parallel those for function.
</p>
<p><i>[
US-207 Suggested Resolution:
]</i></p>


<blockquote><p>
Review the constructors for packaged_task and
provide the same ones as function, except where
inappropriate.
</p></blockquote>

<p><i>[
2010-10-22 Howard provides wording, as requested by the LWG in Rapperswil.
]</i></p>


<p><i>[2011-02-10 Reflector discussion]</i></p>

<p>
Moved to Tentatively Ready after 5 votes.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Alter the list of constructors in both 30.6.10 [futures.task] and in 30.6.10.1 [futures.task.members] as indicated:
</p>
<blockquote>
<pre><del>template &lt;class F&gt;
explicit packaged_task(F f);
template &lt;class F, class Allocator&gt;
explicit packaged_task(allocator_arg_t, const Allocator&amp; a, F f);
explicit packaged_task(R(*f)(ArgTypes...));</del>
template &lt;class F&gt;
explicit packaged_task(F&amp;&amp; f);
template &lt;class F, class Allocator&gt;
explicit packaged_task(allocator_arg_t, const Allocator&amp; a, F&amp;&amp; f);
</pre>
</blockquote>





<hr>
<h3><a name="1515"></a>1515. [FCD] <tt>packaged_task::make_ready_at_thread_exit</tt> has no
synchronization requirements</h3>
<p><b>Section:</b> 30.6.10.1 [futures.task.members] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2011-02-22</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures.task.members">active issues</a> in [futures.task.members].</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.task.members">issues</a> in [futures.task.members].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-208</b></p>

<p>
<tt>packaged_task::make_ready_at_thread_exit</tt> has no
synchronization requirements.
</p>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<p>
Figure out what the synchronization requirements
should be and write them.
</p>

<p><i>[2011-02-09 Anthony provides a proposed resolution]</i></p>


<p><i>[2011-02-19 Additional edits by Hans, shown in the proposed resolution section]</i></p>


<p><i>[2011-02-22 Reflector discussion]</i></p>

<p>
Moved to Tentatively Ready after 5 votes.
</p> 


<p><b>Proposed resolution:</b></p>
<p>Add a new paragraph following 30.6.10.1 [futures.task.members] p. 19:</p>

<blockquote><pre>
void make_ready_at_thread_exit(ArgTypes... args);
</pre></blockquote>
<blockquote>
<p>
19 - ...
</p>
<p>
<ins>?? - <i>Synchronization</i>: Following a successful call to <tt>make_ready_at_thread_exit</tt>, the
destruction of all objects with thread storage duration associated with
the current thread happens before the associated asynchronous state is
made ready. The marking of the associated asynchronous state as ready
synchronizes with (1.10 [intro.multithread]) the successful return from any function that
detects that the state is set to ready.</ins>
</p>
</blockquote>





<hr>
<h3><a name="2000"></a>2000. Missing definition of <tt>packaged_task</tt> specialization of <tt>uses_allocator</tt></h3>
<p><b>Section:</b> 30.6.10.2 [futures.task.nonmembers] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2010-08-29 <b>Last modified:</b> 2011-02-20</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
[futures.task.nonmembers]/3 says:
</p>
<blockquote><pre>
   template &lt;class R, class Alloc&gt;
     struct uses_allocator&lt;packaged_task&lt;R&gt;, Alloc&gt;;
</pre></blockquote>
<p>
This is a declaration, but should be a definition.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change [futures.task.nonmembers]/3:
</p>

<blockquote><pre>
   template &lt;class R, class Alloc&gt;
     struct uses_allocator&lt;packaged_task&lt;R&gt;, Alloc&gt;<del>;</del>
        <ins>: true_type {};</ins>
</pre></blockquote>





<hr>
<h3><a name="2001"></a>2001. Class template <tt>basic_regex</tt> uses non existent <tt>string_type</tt></h3>
<p><b>Section:</b> 28.8.3 [re.regex.assign] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Volker Lukas <b>Opened:</b> 2010-10-21 <b>Last modified:</b> 2011-02-24</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In working draft N3126, subclause 28.8.3 [re.regex.assign], paragraphs 12, 13 and 19, 
the name <tt>string_type</tt> is used. This is presumably a typedef for <tt>basic_string&lt;value_type&gt;</tt>, where 
<tt>value_type</tt> is the character type used by <tt>basic_regex</tt>. The <tt>basic_regex</tt> 
template however defines no such typedef, and neither does the <tt>&lt;regex&gt;</tt> 
header or the <tt>&lt;initializer_list&gt;</tt> header included by <tt>&lt;regex&gt;</tt>.
</p>

<p><i>[
2010-11-03 Daniel comments and suggests alternative wording:
]</i></p>

<blockquote><p>
The proposed resolution needs to use <tt>basic_string&lt;<strong>charT</strong>&gt;</tt> instead of <tt>basic_string&lt;char&gt;</tt>
</p></blockquote>

<p>
Previous Proposed Resolution:
<p/>
Make the following changes to [re.regex.assign]:
</p>
<blockquote>
<pre>
basic_regex&amp; assign(const charT* ptr, flag_type f = regex_constants::ECMAScript);
</pre>
<blockquote><p>
12 <i>Returns</i>: <tt>assign(<del>string_type</del><ins>basic_string&lt;charT&gt;</ins>(ptr), f)</tt>. 
</p></blockquote>

<pre>
basic_regex&amp; assign(const charT* ptr, size_t len,
  flag_type f = regex_constants::ECMAScript);
</pre>
<blockquote><p>
13 <i>Returns</i>: <tt>assign(<del>string_type</del><ins>basic_string&lt;charT&gt;</ins>(ptr, len), f)</tt>.
</p></blockquote>

<pre>
[..]

template &lt;class InputIterator&gt; 
  basic_regex&amp; assign(InputIterator first, InputIterator last, 
                          flag_type f = regex_constants::ECMAScript);
</pre>

<blockquote><p>
18 <i>Requires</i>: The type <tt>InputIterator</tt> shall satisfy the requirements for an Input Iterator (24.2.3).
</p></blockquote>

<blockquote><p>
19 <i>Returns</i>: <tt>assign(<del>string_type</del><ins>basic_string&lt;charT&gt;</ins>(first, last), f)</tt>.
</p></blockquote>

</blockquote>

<p><i>[
2010 Batavia 
]</i></p>


<p>
Unsure if we should just give <tt>basic_regex</tt> a <tt>string_type</tt> typedef. Looking for when <tt>string_type</tt> was 
introduced into <tt>regex</tt>. Howard to draft wording for <tt>typedef typename traits::string_type string_type</tt>, then move to Review. 
</p>

<p><i>[
2011-02-16: Daniel comments and provides an alternative resolution.
]</i></p>


<p>
I'm strongly in favour with the Batavia idea to provide a separate <tt>string_type</tt> within
<tt>basic_regex</tt>, but it seems to me that the issue resultion should add one more
important typedef, namely that of the traits type! Currently, <tt>basic_regex</tt> is the
<em>only</em> template that does not publish the type of the associated traits type. Instead
of opening a new issue, I added this suggestion as part of the proposed wording.
</p>

<p><i>[2011-02-24 Reflector discussion]</i></p>

<p>
Moved to Tentatively Ready after 6 votes.
</p> 


<p><b>Proposed resolution:</b></p>
<p>
Change the class template <tt>basic_regex</tt> synopsis, 28.8 [re.regex] p. 3, as indicated:</p>

<blockquote><pre>
namespace std {
  template &lt;class charT,
            class traits = regex_traits&lt;charT&gt; &gt;
  class basic_regex {
  public:
    // types:
    typedef charT value_type;
    <ins>typedef traits traits_type;</ins>
    <ins>typedef typename traits::string_type string_type;</ins>
    typedef regex_constants::syntax_option_type flag_type;
    typedef typename traits::locale_type locale_type;

    [..]
  };
}
</pre></blockquote>






<hr>
<h3><a name="2004"></a>2004. <tt>duration::operator*</tt> has template parameters in funny order</h3>
<p><b>Section:</b> 20.11.3.5 [time.duration.nonmember] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2010-10-14 <b>Last modified:</b> 2010-11-13</p>
<p><b>View other</b> <a href="lwg-index-open.html#time.duration.nonmember">active issues</a> in [time.duration.nonmember].</p>
<p><b>View all other</b> <a href="lwg-index.html#time.duration.nonmember">issues</a> in [time.duration.nonmember].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In [time] and [time.duration.nonmember] we have:
</p>
<blockquote><pre>
template &lt;class Rep1, class Period, class Rep2>
    duration&lt;typename common_type&lt;Rep1, Rep2>::type, Period>
        operator*(const Rep1&amp; s, const duration&lt;Rep2, Period>&amp; d);
</pre></blockquote>
<p>
Everywhere else, we always have <tt>&lt;rep, period></tt> in that order for a given
type. But here, we have <tt>Period</tt> and <tt>Rep2</tt> in reverse order for
<tt>&lt;Rep2, Period></tt>. This is probably of little importance, since the
template parameters are seldom spelled out for a function like this. But changing it
now will eliminate a potential source of future errors and confusion.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change the signature in [time] and [time.duration.nonmember] to:
</p>
<blockquote><pre>
template &lt;class Rep1, class <del>Period</del><ins>Rep2</ins>, class <del>Rep2</del><ins>Period</ins>>
    duration&lt;typename common_type&lt;Rep1, Rep2>::type, Period>
        operator*(const Rep1&amp; s, const duration&lt;Rep2, Period>&amp; d);
</pre></blockquote>





<hr>
<h3><a name="2006"></a>2006. <tt>emplace</tt> broken for associative containers</h3>
<p><b>Section:</b> 23.2.5 [unord.req] <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Pablo Halpern <b>Opened:</b> 2010-10-18 <b>Last modified:</b> 2011-02-20</p>
<p><b>View other</b> <a href="lwg-index-open.html#unord.req">active issues</a> in [unord.req].</p>
<p><b>View all other</b> <a href="lwg-index.html#unord.req">issues</a> in [unord.req].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current definition of <tt>emplace(args)</tt> for associative containers as
described in Table 99 is:
</p>
<blockquote>
<p>
<i>Requires</i>: <tt>T</tt> shall be constructible from <tt>args</tt>.
<p/>
<i>Effects</i>: Inserts a <tt>T</tt> object <tt>t</tt> constructed with
<tt>std::forward&lt;Args&gt;(args)...</tt> if and only if there is no element
in the container with key equivalent to the key of <tt>t</tt>.  The <tt>bool</tt>
component of the returned <tt>pair</tt> is <tt>true</tt> if and only if the
insertion takes place, and the iterator component of the <tt>pair</tt>
points to the element with key equivalent to the key of <tt>t</tt>.
</p>
</blockquote>
<p>
There is similar language in Table 100 for unordered associative containers.
<p/>
The first issue is editorial: <tt>T</tt> should be <tt>value_type</tt> throughout
both tables.
<p/>
The major issue is that, if the container is <tt>map</tt>, <tt>multimap</tt>,
<tt>unordered_map</tt>, or <tt>unordered_multimap</tt>, then the only way to
construct an object of <tt>value_type</tt> is to supply exactly two arguments
for <tt>Key</tt> and <tt>Value</tt>, a <tt>pair&lt;Key,Value&gt;</tt>, or a
<tt>piecewise_construct_t</tt> followed by two <tt>tuple</tt>s.  The original
<tt>emplace()</tt> proposal would have allowed you to specify a <tt>Key</tt>
value followed by any number of constructor arguments for <tt>Value</tt>.
When we removed the variadic constructor to <tt>pair</tt>, this ability went
away.  I don't think that was deliberate.
<p/>
Fixing this is non-trivial, I think. I think that <tt>emplace()</tt> for <tt>map</tt>
and <tt>multimap</tt> need several overloads: one for each overloaded constructor in
<tt>pair&lt;Key,Value&gt;</tt>, and one for the <tt>emplace(Key, valueargs...)</tt> case.
And it probably needs some SFINAE meta-programming to ensure that the last case
doesn't override any of the other ones.  Alternatively, one could say that
there are exactly two cases: <tt>emplace(args)</tt> where <tt>pair&lt;Key,Value&gt;</tt>
is constructible from <tt>args</tt>, and <tt>emplace(args)</tt> where <tt>Key</tt> is
constructible form the first <tt>arg</tt> and <tt>Value</tt> is constructible from the
rest.
<p/>
Alternatively, the status quo is to use <tt>piecewise_construct_t</tt> if you want to
construct an object.
</p>

<p><i>[
2010 Batavia:
]</i></p>


<p>
N3178 was looked at in session and moved to NAD.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2007"></a>2007. Incorrect specification of return value for <tt>map&lt;&gt;::at()</tt></h3>
<p><b>Section:</b> 23.6.1.2 [map.access] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2010-11-01 <b>Last modified:</b> 2011-02-20</p>
<p><b>View all other</b> <a href="lwg-index.html#map.access">issues</a> in [map.access].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In [map.access]/9, the <i>Returns</i> clause for <tt>map&lt;Key, T&gt;::at(x)</tt> says 
that it returns "a reference to the element whose key is equivalent to <tt>x</tt>." That can't be right. 
The signature for <tt>at()</tt> says that its return type is <tt>T</tt>, but the elements 
of <tt>map&lt;Key, T&gt;</tt> have type <tt>pair&lt;const K, T&gt;</tt>.  (I checked [unord.map.elem] 
and found that its specification of <tt>at()</tt> is correct. This is a problem for <tt>map</tt> only.)
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change the wording in [map.access]/9 so it's identical to what we already say for <tt>operator[]</tt>, 
which is unambiguous and correct.
</p>
<blockquote><p>
<i>Returns</i>: A reference to the <del>element whose key is equivalent</del><ins><tt>mapped_type</tt> 
corresponding</ins> to <tt>x</tt><ins> in <tt>*this</tt></ins>.
</p></blockquote>





<hr>
<h3><a name="2014"></a>2014. More restrictions on macro names</h3>
<p><b>Section:</b> 17.6.3.3.1 [macro.names] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Alberto Ganesh Barbati <b>Opened:</b> 2010-11-16 <b>Last modified:</b> 2011-02-20</p>
<p><b>View all other</b> <a href="lwg-index.html#macro.names">issues</a> in [macro.names].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
A program is currently forbidden to use keywords as macro names. This restriction should be strengthened to include all identifiers 
that could be used by the library as attribute-tokens (for example <tt>noreturn</tt>, which is used by header <tt>&lt;cstdlib&gt;</tt>) 
and the special identifiers introduced recently for override control (these are not currently used in the library public interface,
but could potentially be used by the implementation or in future revisions of the library).
</p>
<p><i>[2011-02-10 Reflector discussion]</i></p>

<p>
Moved to Tentatively Ready after 5 votes.
</p>


<p><b>Proposed resolution:</b></p>
<p>Modify 17.6.3.3.1 [macro.names] paragraph 2 as follows:</p>

<blockquote><p>
A translation unit shall not <tt>#define</tt> or <tt>#undef</tt> names
lexically identical to keywords<ins>, to the identifiers listed in Table
X [Identifiers with special meaning], or to the <i>attribute-tokens</i>
described in clause 7.6 [dcl.attr]</ins>.
</p></blockquote>






<hr>
<h3><a name="2017"></a>2017. <tt>std::reference_wrapper</tt> makes incorrect usage of <tt>std::result_of</tt></h3>
<p><b>Section:</b> 20.8.4 [refwrap] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Nikolay Ivchenkov <b>Opened:</b> 2010-11-15 <b>Last modified:</b> 2011-02-24</p>
<p><b>View other</b> <a href="lwg-index-open.html#refwrap">active issues</a> in [refwrap].</p>
<p><b>View all other</b> <a href="lwg-index.html#refwrap">issues</a> in [refwrap].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>std::reference_wrapper</tt>'s function call operator uses <em>wrong</em>
type encoding for rvalue-arguments. An rvalue-argument of type <tt>T</tt> must
be encoded as <tt>T&amp;&amp;</tt>, not as just <tt>T</tt>.
</p>
<blockquote><pre>
#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;type_traits&gt;
#include &lt;utility&gt;

template &lt;class F, class... Types&gt;
     typename std::result_of&lt;F (Types...)&gt;::type
         f1(F f, Types&amp;&amp;... params)
{
     return f(std::forward&lt;Types...&gt;(params...));
}

template &lt;class F, class... Types&gt;
     typename std::result_of&lt;F (Types<b>&amp;&amp;</b>...)&gt;::type
         f2(F f, Types&amp;&amp;... params)
{
     return f(std::forward&lt;Types...&gt;(params...));
}

struct Functor
{
     template &lt;class T&gt;
         T&amp;&amp; operator()(T&amp;&amp; t) const
     {
         return static_cast&lt;T&amp;&amp;&gt;(t);
     }
};

int main()
{
     typedef std::string const Str;
     std::cout &lt;&lt; f1(Functor(), Str("1")) &lt;&lt; std::endl; // (1)
     std::cout &lt;&lt; f2(Functor(), Str("2")) &lt;&lt; std::endl; // (2)
}
</pre></blockquote>
<p>
Lets consider the function template <tt>f1</tt> (which is similar to
<tt>std::reference_wrapper</tt>'s function call operator). In the invocation
(1) <tt>F</tt> is deduced as '<tt>Functor</tt>' and <tt>Types</tt> is deduced as type sequence
which consists of one type '<tt>std::string const</tt>'. After the substitution
we have the following equivalent:
</p>
<blockquote><pre>
template &lt;&gt;
    std::result_of&lt;F (std::string const)&gt;::type
        f1&lt;Functor, std::string const&gt;(Functor f, std::string const &amp;&amp; params)
{
    return f(std::forward&lt;const std::string&gt;(params));
}
</pre></blockquote>
<p>
The top-level <i>cv</i>-qualifier in the parameter type of '<tt>F (std::string const)</tt>' is removed, so we have
</p>
<blockquote><pre>
template &lt;&gt;
    std::result_of&lt;F (std::string)&gt;::type
        f1&lt;Functor, std::string const&gt;(Functor f, std::string const &amp;&amp; params)
{
    return f(std::forward&lt;const std::string&gt;(params));
}
</pre></blockquote>
<p>
Let <tt>r</tt> be an rvalue of type '<tt>std::string</tt>' and <tt>cr</tt> be an rvalue of type
'<tt>std::string const</tt>'. The expression <tt>Str("1")</tt> is <tt>cr</tt>. The corresponding
return type for the invocation
</p>
<blockquote><pre>
Functor().operator()(r)
</pre></blockquote>
<p>
is '<tt>std::string &amp;&amp;</tt>'. The corresponding return type for the invocation
</p>
<blockquote><pre>
Functor().operator()(cr)
</pre></blockquote>
<p>
is '<tt>std::string const &amp;&amp;</tt>'.
<p/>
<tt>std::result_of&lt;Functor (std::string)&gt;::type</tt> is the same type as the
corresponding return type for the invocation <tt>Functor().operator()(r)</tt>,
i.e. it is '<tt>std::string &amp;&amp;</tt>'. As a consequence, we have wrong reference
binding in the return statement in <tt>f1</tt>.
<p/>
Now lets consider the invocation (2) of the function template <tt>f2</tt>. When
the template arguments are substituted we have the following equivalent:
</p>
<blockquote><pre>
template &lt;&gt;
    std::result_of&lt;F (std::string const &amp;&amp;)&gt;::type
        f2&lt;Functor, std::string const&gt;(Functor f, std::string const &amp;&amp; params)
{
    return f(std::forward&lt;const std::string&gt;(params));
}
</pre></blockquote>
<p>
<tt>std::result_of&lt;F (std::string const &amp;&amp;)&gt;::type</tt> is the same type as
'<tt>std::string const &amp;&amp;</tt>'. This is correct result.
</p>
<p><i>[
2010-12-07 Jonathan Wakely comments and suggests a proposed resolution
]</i></p>


<p>
I agree with the analysis and I think this is a defect in the
standard, it would be a shame if it can't be fixed.
<p/>
In the following example one would expect <tt>f(Str("1"))</tt> and
<tt>std::ref(f)(Str("2"))</tt> to be equivalent but the current wording makes
the invocation through <tt>reference_wrapper</tt> ill-formed:
</p>
<blockquote><pre>
#include &lt;functional&gt;
#include &lt;string&gt;

struct Functor
{
   template &lt;class T&gt;
       T&amp;&amp; operator()(T&amp;&amp; t) const
       {
           return static_cast&lt;T&amp;&amp;&gt;(t);
       }
};

int main()
{
   typedef std::string const Str;
   Functor f;
   f( Str("1") );
   std::ref(f)( Str("2") );  // error
}
</pre></blockquote>

<p><i>[
2010-12-07 Daniel comments and refines the proposed resolution
]</i></p>


<p>
There is one further defect in the usage of <tt>result_of</tt> within
<tt>reference_wrapper</tt>'s function call operator: According to 20.8.4.4 [refwrap.invoke] p. 1
the invokable entity of type <tt>T</tt> is provided as lvalue, but 
<tt>result_of</tt> is fed as if it were an rvalue. This does not only lead to
potentially incorrect result types, but it will also have the effect that
we could never use the function call operator with a function type,
because the type encoding used in <tt>result_of</tt> would form an invalid
function type return a function type. The following program demonstrates
this problem:
</p>
<blockquote><pre>
#include &lt;functional&gt;

void foo(int) {}

int main()
{
   std::ref(foo)(0);  // error
}
</pre></blockquote><p>
The correct solution is to ensure that <tt>T</tt> becomes <tt>T&amp;</tt>
within <tt>result_of</tt>, which solves both problems at once.
</p>

<p><i>[2011-02-24 Reflector discussion]</i></p>

<p>
Moved to Tentatively Ready after 5 votes.
</p> 


<p><b>Proposed resolution:</b></p>
<ol>
<li>
<p>
Change the synopsis in 20.8.4 [refwrap] paragraph 1:
</p>

<blockquote><pre>
namespace std {
  template &lt;class T&gt; class reference_wrapper
  {
  public :
    [...]
    // invocation
    template &lt;class... ArgTypes&gt;
    typename result_of&lt;T<ins>&amp;</ins>(ArgTypes<ins>&amp;&amp;</ins>...)&gt;::type
    operator() (ArgTypes&amp;&amp;...) const;
  };
}
</pre></blockquote>
</li>

<li>
<p>
Change the signature in 20.8.4.4 [refwrap.invoke] before paragraph 1
</p>

<blockquote><pre>
template &lt;class... ArgTypes&gt;
typename result_of&lt;T<ins>&amp;</ins>(ArgTypes<ins>&amp;&amp;</ins>... )&gt;::type
operator()(ArgTypes&amp;&amp;... args) const;
</pre><blockquote><p>
1 <i>Returns</i>: <tt>INVOKE(get(), std::forward&lt;ArgTypes&gt;(args)...)</tt>. (20.8.2)
</p></blockquote></blockquote>
</li>
</ol>





<hr>
<h3><a name="2019"></a>2019. <tt>isblank</tt> not supported by <tt>std::locale</tt></h3>
<p><b>Section:</b> 22.3.3.1 [classification] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2010-11-16 <b>Last modified:</b> 2011-02-24</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>C99 added <tt>isblank</tt> and <tt>iswblank</tt> to <tt>&lt;locale.h&gt;</tt> but <tt>&lt;locale&gt;</tt> does not
provide any equivalent.</p>

<p><i>[2011-02-24 Reflector discussion]</i></p>

<p>
Moved to Tentatively Ready after 6 votes.
</p> 


<p><b>Proposed resolution:</b></p>
<p>Add to 22.3.3.1 [classification] synopsis:</p>
<blockquote><pre>
template &lt;class charT&gt; bool isgraph (charT c, const locale&amp; loc);
<ins>template &lt;class charT&gt; bool isblank (charT c, const locale&amp; loc);</ins>
</pre></blockquote>

<p>Add to 22.4.1 [category.ctype] synopsis:</p>

<blockquote><pre>
static const mask xdigit = 1 &lt;&lt; 8;
<ins>static const mask blank = 1 &lt;&lt; 9;</ins>
static const mask alnum = alpha | digit;
static const mask graph = alnum | punct;
</pre></blockquote>






<hr>
<h3><a name="2020"></a>2020. Time utility arithmetic <tt>constexpr</tt> functions have invalid effects</h3>
<p><b>Section:</b> 20.11.3.5 [time.duration.nonmember] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2010-12-06 <b>Last modified:</b> 2011-02-20</p>
<p><b>View other</b> <a href="lwg-index-open.html#time.duration.nonmember">active issues</a> in [time.duration.nonmember].</p>
<p><b>View all other</b> <a href="lwg-index.html#time.duration.nonmember">issues</a> in [time.duration.nonmember].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
As of issue <a href="lwg-defects.html#1171">1171</a> several time-utility functions have been marked <tt>constexpr</tt>.
Alas this was done without adapting the corresponding return elements, which has the effect that 
none of current arithmetic functions of class template <tt>duration</tt> marked as <tt>constexpr</tt> 
can ever be <tt>constexpr</tt> functions (which makes them ill-formed, no diagnostics required as 
of recent core rules), because they invoke a non-constant expression, e.g. 20.11.3.5 [time.duration.nonmember]/2:
</p>
<blockquote><pre>
template &lt;class Rep1, class Period1, class Rep2, class Period2>
constexpr typename common_type&lt;duration&lt;Rep1, Period1&gt;, duration&lt;Rep2, Period2&gt;{&gt;}::type
operator+(const duration&lt;Rep1, Period1>&amp; lhs, const duration&lt;Rep2, Period2&gt;&amp; rhs);

2 Returns: CD(lhs) += rhs.
</pre></blockquote>
<p>
The real problem is, that we cannot defer to as-if rules here: The returns element
specifies an indirect calling contract of a potentially user-defined function. This <em>cannot</em> be
the <tt>+=</tt> assignment operator of such a user-defined type, but must be the corresponding
immutable binary <tt>operator+</tt> (unless we require that <tt>+=</tt> shall be an immutable function
which does not really makes sense).
</p>
<p><i>[2011-02-17 Reflector discussion]</i></p>

<p>
Moved to Tentatively Ready after 5 votes.
</p>



<p><b>Proposed resolution:</b></p>
<p>
The suggested wording changes are against the working draft N3225. Additional to the normative wording
changes some editorial fixes are suggested.
</p>
<ol>
<li>
<p>Change the following arithmetic function specifications as follows:</p>
<blockquote><pre>
template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
constexpr typename common_type&lt;duration&lt;Rep1, Period1&gt;, duration&lt;Rep2, Period2&gt;<del>{</del>&gt;<del>}</del>::type
operator+(const duration&lt;Rep1, Period1&gt;&amp; lhs, const duration&lt;Rep2, Period2&gt;&amp; rhs);
</pre><blockquote><p>
2 <i>Returns</i>: <del><tt>CD(lhs) += rhs</tt></del><ins><tt>CD(CD(lhs).count() + CD(rhs).count())</tt></ins>.
</p></blockquote></blockquote>

<blockquote><pre>
template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
constexpr typename common_type&lt;duration&lt;Rep1, Period1&gt;, duration&lt;Rep2, Period2&gt;<del>{</del>&gt;<del>}</del>::type
operator-(const duration&lt;Rep1, Period1&gt;&amp; lhs, const duration&lt;Rep2, Period2&gt;&amp; rhs);
</pre><blockquote><p>
3 <i>Returns</i>: <del><tt>CD(lhs) -= rhs</tt></del><ins><tt>CD(CD(lhs).count() - CD(rhs).count())</tt></ins>.
</p></blockquote></blockquote>

<blockquote><pre>
template &lt;class Rep1, class Period, class Rep2&gt;
constexpr duration&lt;typename common_type&lt;Rep1, Rep2&gt;::type, Period&gt;
operator*(const duration&lt;Rep1, Period&gt;&amp; d, const Rep2&amp; s);
</pre><blockquote><p>
4 <i>Remarks</i>: This operator shall not participate in overload resolution unless <tt>Rep2</tt> is implicitly convertible
to <tt>CR(Rep1, Rep2)</tt>.
<p/>
5 <i>Returns</i>: <del><tt>duration&lt;CR(Rep1, Rep2), Period&gt;(d) *= s</tt></del><ins><tt>CD(CD(d).count() * s)</tt></ins>.
</p></blockquote></blockquote>

<blockquote><p>
<tt>[...]</tt>
</p></blockquote>

<blockquote><pre>
template &lt;class Rep1, class Period, class Rep2&gt;
constexpr duration&lt;typename common_type&lt;Rep1, Rep2&gt;::type, Period&gt;
operator/(const duration&lt;Rep1, Period&gt;&amp; d, const Rep2&amp; s);
</pre><blockquote><p>
8 <i>Remarks</i>: This operator shall not participate in overload resolution unless <tt>Rep2</tt> is implicitly convertible
to <tt>CR(Rep1, Rep2)</tt> and <tt>Rep2</tt> is not an instantiation of <tt>duration</tt>.
<p/>
9 <i>Returns</i>: <del><tt>duration&lt;CR(Rep1, Rep2), Period&gt;(d) &#47;= s</tt></del><ins><tt>CD(CD(d).count() &#47; s)</tt></ins>.
</p></blockquote></blockquote>

<blockquote><p>
<tt>[...]</tt>
</p></blockquote>

<blockquote><pre>
template &lt;class Rep1, class Period, class Rep2&gt;
constexpr duration&lt;typename common_type&lt;Rep1, Rep2&gt;::type, Period&gt;
operator%(const duration&lt;Rep1, Period&gt;&amp; d, const Rep2&amp; s);
</pre><blockquote><p>
11 <i>Remarks</i>: This operator shall not participate in overload resolution unless <tt>Rep2</tt> is implicitly convertible
to <tt>CR(Rep1, Rep2)</tt> and <tt>Rep2</tt> is not an instantiation of <tt>duration</tt>.
<p/>
12 <i>Returns</i>: <del><tt>duration&lt;CR(Rep1, Rep2), Period&gt;(d) %= s</tt></del><ins><tt>CD(CD(d).count() % s)</tt></ins>
</p></blockquote></blockquote>

<blockquote><pre>
template &lt;class Rep1, class Period1, class Rep2, class Period2&gt;
constexpr typename common_type&lt;duration&lt;Rep1, Period1&gt;, duration&lt;Rep2, Period2&gt;&gt;::type
operator%(const duration&lt;Rep1, Period1&gt;&amp; lhs, const duration&lt;Rep2, Period2&gt;&amp; rhs);
</pre><blockquote><p>
13 Returns: <del><tt>common_type&lt;duration&lt;Rep1, Period1&gt;, duration&lt;Rep2, Period2&gt; &gt;::type(lhs) 
 %= rhs</tt></del><ins><tt>CD(CD(lhs).count() % CD(rhs).count())</tt></ins>.
</p></blockquote></blockquote>
</li>
</ol>





<hr>
<h3><a name="2022"></a>2022. <tt>reference_wrapper&lt;T&gt;::result_type</tt> is underspecified</h3>
<p><b>Section:</b> 20.8.4 [refwrap] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2010-12-08 <b>Last modified:</b> 2011-02-23</p>
<p><b>View other</b> <a href="lwg-index-open.html#refwrap">active issues</a> in [refwrap].</p>
<p><b>View all other</b> <a href="lwg-index.html#refwrap">issues</a> in [refwrap].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Issue <a href="lwg-defects.html#1295">1295</a> correctly removed function types and references to function types from the
bullet 1 of 20.8.2 [func.require] p. 3 because neither function types nor function references
satisfy the requirements for a target object which is <em>defined</em> to be an object of a callable 
type. This has the effect that the reference in 20.8.4 [refwrap] p. 2
</p>
<blockquote><p>
<tt>reference_wrapper</tt> has a weak result type (20.8.2).
</p></blockquote>
<p>
is insufficient as a reference to define the member type <tt>result_type</tt> when the template argument 
<tt>T</tt> is a function type.
<p/>
There are basically two approaches to solve the problem:
</p>
<ol>
<li><p>Extend the definition of a <i>weak result type</i> in 20.8.2 [func.require] p. 3 to both
function types and references thereof. This extension must be specified independend from the concept
of a call wrapper, though.</p>
</li>
<li><p>Add one extra sentence to 20.8.4 [refwrap] p. 2 that simply defines the member type
<tt>result_type</tt> for <tt>reference_wrapper&lt;T&gt;</tt>, when <tt>T</tt> is a function type.</p>
</li>
</ol>
<p>
I checked the current usages of <i>weak result type</i> to have a base to argue for one or the other
approach. It turns out, that there is no further reference to this definition in regard to
function types or references thereof. The only other reference can be found in 
20.8.10.1.2 [func.bind.bind] p. 3, where <tt>g</tt> is required to be a class type.
</p>

<p><i>[2011-02-23 Reflector discussion]</i></p>

<p>
Moved to Tentatively Ready after 5 votes.
</p> 


<p><b>Proposed resolution:</b></p>
<p>
The suggested wording changes are against the working draft N3225.
</p>

<ol>
<li>
<p>Change 20.8.4 [refwrap] p. 2 as indicated:</p>

<blockquote><p>
2 <tt>reference_wrapper<ins>&lt;T&gt;</ins></tt> has a weak result type (20.8.2). <ins>If <tt>T</tt> is a function type, 
<tt>result_type</tt> shall be a synonym for the return type of <tt>T</tt>.</ins>
</p></blockquote>

</li>

</ol>





<hr>
<h3><a name="2023"></a>2023. Incorrect requirements for <tt>lock_guard</tt> and <tt>unique_lock</tt></h3>
<p><b>Section:</b> 30.4.2.1 [thread.lock.guard], 30.4.2.2 [thread.lock.unique] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2010-12-08 <b>Last modified:</b> 2011-02-24</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
There are two different <tt>*Lockable</tt> requirements imposed on template arguments
of the class template <tt>lock_guard</tt> as of 30.4.2.1 [thread.lock.guard] p. 1+2:
</p>
<blockquote><p>
1 [..] The supplied <tt>Mutex</tt> type shall meet the <tt>BasicLockable</tt> requirements (30.2.5.2).
</p></blockquote>

<blockquote><p>
2 The supplied <tt>Mutex</tt> type shall meet the <tt>Lockable</tt> requirements (30.2.5.3).
</p></blockquote>
<p>
The <tt>Lockable</tt> requirements include the availability of a member function <tt>try_lock()</tt>,
but there is no operational semantics in the specification of <tt>lock_guard</tt> that would rely
on such a function. It seems to me that paragraph 2 should be removed.
<p/>
Similarly, 30.4.2.2 [thread.lock.unique] p. 1+2 refer to exactly the same two requirements.
In this case it seems as if the intention was that the template arguement <tt>Mutex</tt> should
always provide the <tt>try_lock()</tt> member function, because several member functions of
<tt>unique_lock</tt> (<tt>unique_lock(mutex_type&amp; m, try_to_lock_t)</tt> or <tt>bool try_lock()</tt>) 
take advantage of such a function without adding extra requirements for this.
It seems that the requirement subset <tt>BasicLockable</tt> should be removed.
<p/>
I searched for further possible misusages of the <tt>*Lockable</tt> requirements, but could not
find any more.
</p>

<p><i>[2011-02-23]</i></p>


<p>Howard suggests an alternative approach in regard to <tt>unique_lock</tt>: The current
minimum requirements on its template argument should better be reduced to <tt>BasicLockable</tt> 
instead of the current <tt>Lockable</tt>, including ammending member-wise constraints where required. 
This suggestions was supported by Anthony, Daniel, and Pablo.
<p/>
Daniel drafts wording that follows this separation strategy.
</p>

<p><i>[2011-02-24 Reflector discussion]</i></p>

<p>
Moved to Tentatively Ready after 5 votes.
</p> 


<p><b>Proposed resolution:</b></p>
<p>
The suggested wording changes are against the working draft N3225.
</p>

<ol>
<li>
<p>Remove 30.4.2.1 [thread.lock.guard] p. 2 completely:</p>

<blockquote><p>
<del>2 The supplied <tt>Mutex</tt> type shall meet the <tt>Lockable</tt> requirements (30.2.5.3).</del>
</p></blockquote>

</li>

<li>
<p>Change 30.4.2.2 [thread.lock.unique] p. 1-3 as indicated. The intend is to make <tt>BasicLockable</tt>
the fundamental requirement for <tt>unique_lock</tt>. We also update the note to reflect these changes and
synchronize one remaining reference of 'mutex' by the proper term 'lockable object' in sync
to the wording changes of <tt>lock_guard</tt>:</p>

<blockquote><p>
1 [..] The behavior of a program is undefined if the contained pointer <tt>pm</tt> is not null
and the <del>mutex</del><ins>lockable object</ins> pointed to by <tt>pm</tt> does not exist for the entire remaining lifetime (3.8) 
of the <tt>unique_lock</tt> object. The supplied <tt>Mutex</tt> type shall meet the 
<tt>BasicLockable</tt> requirements (30.2.5.2). <del>[Editor's note:
BasicLockable is redundant, since the following additional paragraph requires Lockable.]</del>
</p></blockquote>

<blockquote><p>
<del>2 The supplied <tt>Mutex</tt> type shall meet the <tt>Lockable</tt> requirements (30.2.5.3).</del>
</p></blockquote>

<blockquote><p>
3 [ <i>Note</i>: <tt>unique_lock&lt;Mutex&gt;</tt> meets the <tt><ins>Basic</ins>Lockable</tt> requirements. If 
<ins><tt>Mutex</tt> meets the <tt>Lockable</tt> requirements ([thread.req.lockable.req]), <tt>unique_lock&lt;Mutex&gt;</tt> 
also meets the <tt>Lockable</tt> requirements and if</ins> <tt>Mutex</tt> meets the <tt>TimedLockable</tt> 
requirements (30.2.5.4), <tt>unique_lock&lt;Mutex&gt;</tt> also meets the <tt>TimedLockable</tt> 
requirements. &mdash; <i>end note</i> ]
</p></blockquote>

</li>

<li><p>Modify 30.4.2.2.1 [thread.lock.unique.cons] to add the now necessary member-wise
additional constraints for <tt>Lockable</tt>:</p>

<blockquote><pre>
unique_lock(mutex_type&amp; m, try_to_lock_t) noexcept;
</pre><blockquote><p>
8 <i>Requires</i>: <ins>The supplied <tt>Mutex</tt> type shall meet the <tt>Lockable</tt> requirements ([thread.req.lockable.req]).</ins> 
If <tt>mutex_type</tt> is not a recursive mutex the calling thread does not own the mutex.
<p/>
9 <i>Effects</i>: Constructs an object of type <tt>unique_lock</tt> and calls <tt>m.try_lock()</tt>.
</p></blockquote></blockquote>
</li>

<li><p>Modify 30.4.2.2.2 [thread.lock.unique.locking] to add the now necessary member-wise
additional constraints for <tt>Lockable</tt>:</p>

<blockquote><pre>
bool try_lock();
</pre><blockquote><p>
<ins>? <i>Requires</i>: The supplied <tt>Mutex</tt> type shall meet the <tt>Lockable</tt> requirements ([thread.req.lockable.req]).</ins> 
<p/>
4 <i>Effects</i>: <tt>pm-&gt;try_lock()</tt>
</p></blockquote></blockquote>
</li>
</ol>





<hr>
<h3><a name="2024"></a>2024. Inconsistent implementation requirements for <tt>atomic&lt;<i>integral</i>&gt;</tt> and <tt>atomic&lt;T*&gt;</tt></h3>
<p><b>Section:</b> 29.5 [atomics.types.generic] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2010-12-08 <b>Last modified:</b> 2011-02-20</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.types.generic">issues</a> in [atomics.types.generic].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
Paragraph 5 and 6 of 29.5 [atomics.types.generic] impose different requirements on implementations for
specializations of the <tt>atomic</tt> class template for integral types and for pointer types:
</p>
<blockquote><p>
5 The atomic integral specializations and the specialization <tt>atomic&lt;bool&gt;</tt> shall have standard layout. 
They shall each have a trivial default constructor and a trivial destructor. They shall each support aggregate
initialization syntax.
</p></blockquote>

<blockquote><p>
6 There are pointer partial specializations on the <tt>atomic</tt> class template. These specializations shall have 
trivial default constructors and trivial destructors.
</p></blockquote>

<p>
It looks like an oversight to me, that for pointer specializations the requirements for standard layout and
support for aggregate initialization syntax are omitted. In fact, this been confirmed by the 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3193.htm">N3193</a> proposal author. I suggest
to impose the same implementation requirements for pointer types as for integral types, this should not impose 
unrealistic requirements on implementations.
</p>

<p><i>[2011-02-10 Reflector discussion]</i></p>

<p>
Moved to Tentatively Ready after 5 votes.
</p>


<p><b>Proposed resolution:</b></p>
<p>
The suggested wording changes are against the working draft N3225.
</p>

<ol>
<li>
<p>Change 29.5 [atomics.types.generic] p. 6 as indicated:</p>

<blockquote><p>
6 There are pointer partial specializations on the <tt>atomic</tt> class template. These specializations shall have 
<ins>standard layout,</ins> trivial default constructors<ins>,</ins> and trivial destructors. <ins> They shall each 
support aggregate initialization syntax.</ins>
</p></blockquote>

</li>
</ol>





<hr>
<h3><a name="2029"></a>2029. Missing '<tt>noexcept</tt>' on <tt>basic_regex</tt> move-assignment operator</h3>
<p><b>Section:</b> 28.8 [re.regex] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2011-02-16 <b>Last modified:</b> 2011-02-24</p>
<p><b>View other</b> <a href="lwg-index-open.html#re.regex">active issues</a> in [re.regex].</p>
<p><b>View all other</b> <a href="lwg-index.html#re.regex">issues</a> in [re.regex].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3149.html">N3149</a> replaced 
the "<tt>Throws: nothing</tt>" clause on <tt>basic_regex::assign(basic_regex&amp;&amp;)</tt> with 
the <tt>noexcept</tt> keyword. The effects of the move-assignment operator are defined in terms of 
the <tt>assign()</tt> function, so the "<tt>Throws: nothing</tt>" applied there too, and a
<tt>noexcept</tt>-specification should be added there too.
</p>

<p><i>[2011-02-24 Reflector discussion]</i></p>

<p>
Moved to Tentatively Ready after 7 votes.
</p> 


<p><b>Proposed resolution:</b></p>

<ol>
<li>
<p>Modify the <tt>basic_regex</tt> synopsis in 28.8 [re.regex] p. 3:</p>

<blockquote><pre>
namespace std {
  template &lt;class charT,
            class traits = regex_traits&lt;charT&gt; &gt;
  class basic_regex {
  public:
    ...
    basic_regex&amp; operator=(const basic_regex&amp;);
    basic_regex&amp; operator=(basic_regex&amp;&amp;) <ins>noexcept</ins>;
    basic_regex&amp; operator=(const charT* ptr);
    ...
  };
}
</pre></blockquote>

</li>

<li>
<p>Modify 28.8.3 [re.regex.assign] p. 2:</p>

<blockquote><pre>
basic_regex&amp; operator=(basic_regex&amp;&amp; e) <ins>noexcept</ins>;
</pre>
<blockquote><p>
2 <em>Effects</em>: returns <tt>assign(std::move(e))</tt>.
</p></blockquote>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2030"></a>2030. <tt>packaged_task::result_type</tt> should be removed</h3>
<p><b>Section:</b> 30.6.10 [futures.task] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Anthony Williams <b>Opened:</b> 2010-11-12 <b>Last modified:</b> 2011-02-24</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.task">issues</a> in [futures.task].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
<tt>packaged_task::operator()</tt> always returns <tt>void</tt>, regardless of the return
type of the wrapped task. However, <tt>packaged_task::result_type</tt> is a
typedef to the return type of the wrapped task. This is inconsistent
with other uses of <tt>result_type</tt> in the standard, where it matches the
return type of <tt>operator()</tt> (e.g. <tt>function</tt>, <tt>owner_less</tt>). This is confusing.
</p>

<p>
It also violates the TR1 <tt>result_of</tt> protocol, and thus makes
<tt>packaged_task</tt> harder to use with anything that respects that protocol.
</p>

<p>
Finally, it is of little use anyway.
</p>

<p><tt>packaged_task::result_type</tt> should therefore be removed.</p>

<p><i>[2011-02-24 Reflector discussion]</i></p>

<p>
Moved to Tentatively Ready after 5 votes.
</p> 


<p><b>Proposed resolution:</b></p>
<p>Alter the class definition of <tt>packaged_task</tt> in 30.6.10 [futures.task] p. 2 as follows:</p>
<blockquote><pre>
template&lt;class R, class... ArgTypes&gt;
class packaged_task&lt;R(ArgTypes...)&gt; {
public:
  <del>typedef R result_type;</del>
  [...]
};
</pre></blockquote>





<hr>
<h3><a name="2031"></a>2031. <tt>std::future&lt;&gt;::share()</tt> only applies to rvalues</h3>
<p><b>Section:</b> 30.6.6 [futures.unique_future] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Anthony Williams <b>Opened:</b> 2011-02-17 <b>Last modified:</b> 2011-02-22</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.unique_future">issues</a> in [futures.unique_future].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
As specified, <tt>future&lt;&gt;::share()</tt> has the signature
</p>

<blockquote><pre>
shared_future&lt;R&gt; share() &amp;&amp;;
</pre></blockquote>

<p>
This means that it can only be applied to rvalues. One of the key benefits of <tt>share()</tt> is 
that it can be used with the new <tt>auto</tt> facility:
</p>

<blockquote><pre>
std::promise&lt;<em>some_long_winded_type_name</em>&gt; some_promise;
auto f = some_promise.get_future(); // std::future
auto sf = std::move(f).share();
</pre></blockquote>

<p>
<tt>share()</tt> is sufficiently explicit that the move should not be required. We should be able to write:
</p>

<blockquote><pre>
auto sf = f.share();
</pre></blockquote>

<p><i>[2011-02-22 Reflector discussion]</i></p>

<p>
Moved to Tentatively Ready after 5 votes.
</p> 


<p><b>Proposed resolution:</b></p>
<p>Alter the declaration of <tt>share()</tt> to remove the "&amp;&amp;" rvalue qualifier in 
30.6.6 [futures.unique_future] p. 3, and 30.6.6 [futures.unique_future] p. 11:</p>

<blockquote><pre>
shared_future&lt;R&gt; share() <del>&amp;&amp;</del>;
</pre></blockquote>






</body>
</html>
