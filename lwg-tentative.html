<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>C++ Standard Library Tentative Issues</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
</style>
</head>
<body>
<p>Revised 2011-02-16 at 00:02:55 UTC</p>
<h2>Tentative Issues</h2>
<hr>
<h3><a name="1215"></a>1215. <tt>list::merge</tt> with unequal allocators</h3>
<p><b>Section:</b> 23.3.4.4 [list.ops] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Pablo Halpern <b>Opened:</b> 2009-09-24 <b>Last modified:</b> 2010-11-13</p>
<p><b>View all other</b> <a href="lwg-index.html#list.ops">issues</a> in [list.ops].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In Bellevue (I think), we passed
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2525.pdf">N2525</a>,
which, among other things, specifies that the behavior of
<tt>list::splice</tt> is undefined if the allocators of the two lists
being spliced do not compare equal. The same rationale should apply to
<tt>list::merge</tt>. The intent of <tt>list::merge</tt> (AFAIK) is to
move nodes from one sorted <tt>list</tt> into another sorted
<tt>list</tt> without copying the elements. This is possible only if the
allocators compare equal.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Relative to the August 2009 WP,
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2857.pdf">N2857</a>,
change 23.3.4.4 [list.ops],
paragraphs 22-25 as follows:
</p>

<blockquote>
<pre>
void merge(list&amp;&amp; x);
template &lt;class Compare&gt; void merge(list&amp;&amp; x, Compare comp);
</pre>
<blockquote>
<p>
<i>Requires</i>: both the list and the argument list shall be sorted
according to operator&lt; or comp.
</p>
<p>
<i>Effects</i>: If <tt>(&amp;x == this)</tt> does nothing; otherwise, merges the
two sorted ranges <tt>[begin(), end())</tt> and <tt>[x.begin(),
x.end())</tt>. The result is a range in which the elements will be
sorted in non-decreasing order according to the ordering defined by
<tt>comp</tt>; that is, for every iterator <tt>i</tt>, in the range other than the
<tt>first</tt>, the condition <tt>comp(*i, *(i - 1)<ins>)</ins></tt> will be
<tt>false</tt>.
</p>
<p>
<i>Remarks</i>: Stable. If <tt>(&amp;x != this)</tt> the range <tt>[x.begin(), x.end())</tt> is
empty after the merge. <ins>No elements are copied by this operation.
The behavior is undefined if <tt>this-&gt;get_allocator() !=
x.get_allocator()</tt>.</ins>
</p>
<p>
<i>Complexity</i>: At most <tt>size() + x.size() - 1</tt> applications of <tt>comp</tt>
if <tt>(&amp;x != this)</tt>; otherwise, no applications of <tt>comp</tt> are performed. If an
exception is thrown other than by a comparison there are no effects.
</p>
</blockquote>
</blockquote>





<hr>
<h3><a name="1253"></a>1253. invalidation of iterators and <tt>emplace</tt> vs. <tt>insert</tt> inconsistence in assoc. containers</h3>
<p><b>Section:</b> 23.2.4 [associative.reqmts] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Boris Du&scaron;ek <b>Opened:</b> 2009-10-24 <b>Last modified:</b> 2010-11-13</p>
<p><b>View other</b> <a href="lwg-index-open.html#associative.reqmts">active issues</a> in [associative.reqmts].</p>
<p><b>View all other</b> <a href="lwg-index.html#associative.reqmts">issues</a> in [associative.reqmts].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In the latest published draft
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2960.pdf">N2960</a>,
section 23.2.4 [associative.reqmts], paragraph 8, it is specifies
that that <tt>insert</tt> does not invalidate any iterators. As per
23.2.1 [container.requirements.general], paragraph 12, this holds
true not only for <tt>insert</tt>, but <tt>emplace</tt> as well. This
gives the <tt>insert</tt> member a special treatment w.r.t.
<tt>emplace</tt> member in 23.2.4 [associative.reqmts], par. 8,
since both modify the container. For the sake of consistency, in 23.2.4 [associative.reqmts], par. 8: either reference to
<tt>insert</tt> should be removed (i.e. count on 23.2.1 [container.requirements.general], par. 12), or reference to
<tt>emplace</tt> be added (i.e. mention all members of assoc. containers
that modify it).
</p>

<p><i>[
2009-11-18 Chris provided wording.
]</i></p>


<blockquote>
This suggested wording covers both the issue discussed, and a number of other
identical issues (namely insert being discussed without emplace). I'm happy to
go back and split and introduce a new issue if appropriate, but I think the
changes are fairly mechanical and obvious.
</blockquote>

<p><i>[
2010-01-23 Daniel Kr&uuml;gler and J. Daniel Garc&iacute;a updated wording to
make the use of <tt>hint</tt> consistent with <tt>insert</tt>.
]</i></p>




<p><b>Proposed resolution:</b></p>
<p>
Modify bullet 1 of 23.2.1 [container.requirements.general], p10:
</p>

<p>
10 Unless otherwise specified (see 23.2.4.1, 23.2.5.1, 23.3.2.3, and 23.3.6.4)
all container types defined in this Clause meet the following additional
requirements:
</p>

<ul>
<li>
if an exception is thrown by an <tt>insert()</tt> <ins>or
<tt>emplace()</tt></ins> function while inserting a single element, that
function has no effects.
</li>
<li>...</li>
</ul>

<p>
Modify 23.2.4 [associative.reqmts], p4:
</p>

<blockquote>
4 An associative container supports <i>unique keys</i> if it may contain at most
one element for each key. Otherwise, it supports <i>equivalent keys</i>. The
<tt>set</tt> and <tt>map</tt> classes support unique keys; the <tt>multiset</tt>
and <tt>multimap</tt> classes support equivalent keys. For <tt>multiset</tt> and
<tt>multimap</tt>, <tt>insert</tt><ins>, <tt>emplace</tt>,</ins> and
<tt>erase</tt> preserve the relative ordering of equivalent elements.
</blockquote>

<p>
Modify Table 96 &mdash; Associative container requirements in 23.2.4 [associative.reqmts]:
</p>

<blockquote>
<table border="1">
<caption>Table 96 &mdash; Associative container requirements (in addition to container)</caption>
<tr>
<th>Expression</th>
<th>Return type</th>
<th>Assertion/note<br/>pre-/post-condition</th>
<th>Complexity</th>
</tr>

<tr>
<td colspan="4"><center>...</center></td>
</tr>

<tr>
<td><tt>a_eq.emplace(args)</tt></td>
<td><tt>iterator</tt></td>
<td>inserts a <tt>T</tt> object <tt>t</tt> constructed with
<tt>std::forward&lt;Args&gt;(args)...</tt> and returns the iterator pointing to
the newly inserted element. <ins>If a range containing elements equivalent to
<tt>t</tt> exists in <tt>a_eq</tt>, <tt>t</tt> is inserted at the end of that
range.</ins></td>
<td>logarithmic</td>
</tr>

<tr>
<td><tt>a.emplace_hint(p, args)</tt></td>
<td><tt>iterator</tt></td>
<td>equivalent to <tt>a.emplace(std::forward&lt;Args&gt;(args)...)</tt>. Return
value is an iterator pointing to the element with the key equivalent to the
newly inserted element. <del>The <tt>const_iterator p</tt> is a hint pointing to
where the search should start.</del> <ins>The element is inserted as close as
possible to the position just prior to <tt>p</tt>.</ins> <del>Implementations
are permitted to ignore the hint.</del></td>
<td>logarithmic in general, but amortized constant if the element is inserted
right <del>after</del> <ins>before</ins> <tt>p</tt></td>
</tr>

<tr>
<td colspan="4"><center>...</center></td>
</tr>

</table>
</blockquote>

<p>
Modify 23.2.4 [associative.reqmts], p8:
</p>

<blockquote>
8 The <tt>insert</tt> <ins>and <tt>emplace</tt></ins> members shall not affect
the validity of iterators and references to the container, and the
<tt>erase</tt> members shall invalidate only iterators and references to the
erased elements.
</blockquote>

<p>
Modify 23.2.4.1 [associative.reqmts.except], p2:
</p>

<blockquote>
2 For associative containers, if an exception is thrown by any operation from
within an <tt>insert()</tt> <ins> or <tt>emplace()</tt></ins> function inserting
a single element, the <del><tt>insert()</tt> function</del> <ins>insertion</ins>
has no effect.
</blockquote>

<p>
Modify 23.2.5 [unord.req], p6, p12 and p13:
</p>

<blockquote>
<p>
6 An unordered associative container supports <i>unique keys</i> if it may
contain at most one element for each key. Otherwise, it supports <i>equivalent
keys</i>. <tt>unordered_set</tt> and <tt>unordered_map</tt> support unique keys.
<tt>unordered_multiset</tt> and <tt>unordered_multimap</tt> support equivalent
keys. In containers that support equivalent keys, elements with equivalent keys
are adjacent to each other. For <tt>unordered_multiset</tt> and
<tt>unordered_multimap</tt>, <tt>insert</tt><ins>, <tt>emplace</tt>,</ins> and
<tt>erase</tt> preserve the relative ordering of equivalent elements.
</p>

<p>
12 The <tt>insert</tt> <ins>and <tt>emplace</tt></ins> members shall not affect
the validity of references to container elements, but may invalidate all
iterators to the container. The erase members shall invalidate only iterators
and references to the erased elements.
</p>

<p>
13 The <tt>insert</tt> <ins>and <tt>emplace</tt></ins> members shall not affect
the validity of iterators if <tt>(N+n) &lt; z * B</tt>, where <tt>N</tt> is the
number of elements in the container prior to the insert operation, <tt>n</tt> is
the number of elements inserted, <tt>B</tt> is the container's bucket count, and
<tt>z</tt> is the container's maximum load factor.
</p>
</blockquote>

<p>
Modify 23.2.5.1 [unord.req.except], p2:
</p>

<blockquote>
2 For unordered associative containers, if an exception is thrown by any
operation other than the container's hash function from within an
<tt>insert()</tt> <ins>or <tt>emplace()</tt></ins> function inserting a single
element, the <del><tt>insert()</tt></del> <ins>insertion</ins>
<del>function</del> has no effect.
</blockquote>





<hr>
<h3><a name="1310"></a>1310. <tt>forward_list splice_after</tt> from lvalues</h3>
<p><b>Section:</b> 23.3.3.5 [forwardlist.ops] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2010-02-05 <b>Last modified:</b> 2010-11-13</p>
<p><b>View all other</b> <a href="lwg-index.html#forwardlist.ops">issues</a> in [forwardlist.ops].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
We've moved <a href="lwg-defects.html#1133">1133</a> to Tentatively Ready and I'm fine with that.
</p>

<p>
<a href="lwg-defects.html#1133">1133</a> adds lvalue-references to the <tt>splice</tt> signatures for <tt>list</tt>.  So now
<tt>list</tt> can <tt>splice</tt> from lvalue and rvalue lists (which was the intent of the
original move papers btw).  During the discussion of this issue it was mentioned
that if we want to give the same treatment to <tt>forward_list</tt>, that should be a
separate issue.
</p>

<p>
This is that separate issue.
</p>

<p>
Consider the following case where you want to splice elements from one place in
a <tt>forward_list</tt> to another.  Currently this must be coded like so:
</p>

<blockquote><pre>
fl.splice_after(to_here, std::move(fl), from1, from2);
</pre></blockquote>

<p>
This looks pretty shocking to me.  I would expect to be able to code instead:
</p>

<blockquote><pre>
fl.splice_after(to_here, fl, from1, from2);
</pre></blockquote>

<p>
but we currently don't allow it.
</p>

<p>
When I say <tt>move(fl)</tt>, I consider that as saying that I don't care about
the value of <tt>fl</tt> any more (until I assign it a new value).  But in the
above example, this simply isn't true.  I do care about the value of <tt>fl</tt>
after the move, and I'm not assigning it a new value.  I'm merely permuting its
current value.
</p>

<p>
I propose adding <tt>forward_list&amp;</tt> overloads to the 3
<tt>splice_after</tt> members.  For consistency's sake (principal of least
surprise) I'm also proposing to overload <tt>merge</tt> this way as well.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Add to the synopsis of 23.3.3 [forwardlist]:
</p>

<blockquote><pre>
template &lt;class T, class Allocator = allocator&lt;T&gt; &gt;
class forward_list {
public:
  ...
  <ins>void splice_after(const_iterator p, forward_list&amp; x);</ins>
  void splice_after(const_iterator p, forward_list&amp;&amp; x);
  <ins>void splice_after(const_iterator p, forward_list&amp; x, const_iterator i);</ins>
  void splice_after(const_iterator p, forward_list&amp;&amp; x, const_iterator i);
  <ins>void splice_after(const_iterator p, forward_list&amp; x,
                    const_iterator first, const_iterator last);</ins>
  void splice_after(const_iterator p, forward_list&amp;&amp; x,
                    const_iterator first, const_iterator last);
  ...
  <ins>void merge(forward_list&amp; x);</ins>
  void merge(forward_list&amp;&amp; x);
  <ins>template &lt;class Compare&gt; void merge(forward_list&amp; x, Compare comp);</ins>
  template &lt;class Compare&gt; void merge(forward_list&amp;&amp; x, Compare comp);
  ...
};
</pre></blockquote>

<p>
Add to the signatures of 23.3.3.5 [forwardlist.ops]:
</p>

<blockquote>
<pre>
<ins>void splice_after(const_iterator p, forward_list&amp; x);</ins>
void splice_after(const_iterator p, forward_list&amp;&amp; x);
</pre>
<blockquote>
<p>1 ...</p>
</blockquote>

<pre>
<ins>void splice_after(const_iterator p, forward_list&amp; x, const_iterator i);</ins>
void splice_after(const_iterator p, forward_list&amp;&amp; x, const_iterator i);
</pre>
<blockquote>
<p>5 ...</p>
</blockquote>

<pre>
<ins>void splice_after(const_iterator p, forward_list&amp; x,
                const_iterator first, const_iterator last);</ins>
void splice_after(const_iterator p, forward_list&amp;&amp; x,
                const_iterator first, const_iterator last);
</pre>
<blockquote>
<p>9 ...</p>
</blockquote>

<pre>
<ins>void merge(forward_list&amp; x);</ins>
void merge(forward_list&amp;&amp; x);
<ins>template &lt;class Compare&gt; void merge(forward_list&amp; x, Compare comp);</ins>
template &lt;class Compare&gt; void merge(forward_list&amp;&amp; x, Compare comp);
</pre>
<blockquote>
<p>18 ...</p>
</blockquote>

</blockquote>






<hr>
<h3><a name="1320"></a>1320. Header for <tt>iter_swap</tt></h3>
<p><b>Section:</b> 24.3 [iterator.synopsis] <b>Status:</b> <a href="lwg-active.html#NAD Future">Tentatively NAD Future</a>
 <b>Submitter:</b> Alisdair Meredith <b>Opened:</b> 2010-02-16 <b>Last modified:</b> 2010-11-13</p>
<p><b>Discussion:</b></p>
<p>
The <tt>iter_swap</tt> function template appears in the
<tt>&lt;algorithm&gt;</tt> header, yet its main use is in building further
algorithms, not calling existing ones. The main clients are implementers of data
structures and their iterators, so it seems most appropriate to place the
template in the <tt>&lt;iterator&gt;</tt> header instead.
</p>

<p>
Note that this is not an issue for implementers of the standard library, as they
rarely use the standard headers directly, designing a more fine-grained set of
headers for their own internal use.  This option is not available to customers
of the standard library.
</p>

<p>
Note that we cannot remove <tt>iter_swap</tt> from <tt>&lt;algorithm&gt;</tt>
without breaking code, but there is no reason we cannot offer the same
declaration via two standard headers.  Alternatively, require
<tt>&lt;algorithm&gt;</tt> to <tt>#include &lt;iterator&gt;</tt>, but
introducing the dependency on the iterator adaptors seems un-necessary.
</p>

<p><i>[
]</i></p>


<p>
Discussed possibly moving to <tt>&lt;utility&gt;</tt> but don't like that. Some not seeing this 
as a defect, and want to keep it in <tt>&lt;algorithm&gt;</tt>. No one seems to feel strongly 
about moving to <tt>&lt;iterator&gt;</tt>.
</p>


<p><b>Proposed resolution:</b></p>

<p>
Add the declaration of <tt>iter_swap</tt> to the <tt>&lt;iterator&gt;</tt>
header synopsis (24.3 [iterator.synopsis]), with a note that it is
documented in clause 25 [algorithms].
</p>

<blockquote><pre>
...
template &lt;class T, size_t N&gt; T* end(T (&amp;array)[N]);

<ins><i>// documented in 25 [algorithms]</i>
template&lt;class ForwardIterator1, class ForwardIterator2&gt;
  void iter_swap(ForwardIterator1 a, ForwardIterator2 b);</ins>
</pre></blockquote>






<hr>
<h3><a name="1371"></a>1371. [FCD] standard exceptions require stronger no-throw guarantees</h3>
<p><b>Section:</b> 19 [diagnostics] <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-14</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-75</b></p>
<p>
None of the exception types defined in clause 19 are
allowed to throw an exception on copy or move
operations, but there is no clear specification that the
operations have an exception specification to prove it.
Note that the implicitly declared constructors, taking the
exception specification from their base class (ultimately
<tt>std::exception</tt>) will implicitly generate a <tt>noexcept</tt>
exception specification if all of their data members
similarly declare <tt>noexcept</tt> operations. As the
representation is unspecified, we cannot assume nonthrowing
operations unless we explicitly state this as a
constraint on the implementation.
</p>

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<p>
Add a global guarantee that all exception types
defined in clause 19 that rely on implicitly declared
operations have a non-throwing exception
specification on those operations.
</p>

<p><i>[
2010 Batavia:
]</i></p>

<p>
This is addressed by the current words in 18.8.1 [exception], p2
</p>
<blockquote>
Each standard library class <tt>T</tt> that derives from class <tt>exception</tt> 
shall have a publicly accessible copy constructor and a publicly accessible copy
assignment operator that do not exit with an exception.
</blockquote>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1413"></a>1413. [FCD] Specify whether <tt>high_resolution_clock</tt> is a distinct type or a typedef</h3>
<p><b>Section:</b> 20.11.5.3 [time.clock.hires] <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-14</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-112</b></p>
<p>
What it means for <tt>high_resolution_clock</tt> to be a synonym
is undefined. If it may or may not be a typedef, then
certain classes of programs become unportable.
</p>

<p><i>[
Resolution proposed in ballot comment
]</i></p>

<p>
Require that it be a distinct class type.
</p>

<p><i>[
2010 Batavia
]</i></p>

<p>
This is not a defect.  Threre are a number of places in the standard where
we allow implentations to choose their preferred technique, the most obvious
example being the <tt>iterator</tt>/<tt>const_iterator</tt> types of <tt>set</tt>.
</p>
<p>
Typically, this means it is not portable to declare function overloads that differ
only in their use of these types.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1456"></a>1456. [FCD] Missing fixed-size atomic_ typedefs</h3>
<p><b>Section:</b> 29 [atomics] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> BSI <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2011-02-15</p>
<p><b>View other</b> <a href="lwg-index-open.html#atomics">active issues</a> in [atomics].</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics">issues</a> in [atomics].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses GB-129</b></p>

Table 143 lists the typedefs for various atomic types
corresponding to the various standard integer typedefs,
such as <tt>atomic_int_least8_t</tt> for <tt>int_least8_t</tt>, and
<tt>atomic_uint_fast64_t</tt> for <tt>uint_fast64_t</tt>. However, there are
no atomic typedefs corresponding to the fixed-size
standard typedefs <tt>int8_t</tt>, <tt>int16_t</tt>, and so forth.

<p><i>[
2010-10-24 Daniel adds:
]</i></p>


<blockquote>
Accepting <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3164.html">n3164</a> would solve this issue.
</blockquote>

<p><i>[
2011-02-15 Anthony corrects numbering/naming for N3225, Howard suggests improvement for the position
of '(optional)', Daniel reorders rows in harmony to remaining entries and suggests specific optionality
comments:
]</i></p>


<p><i>[2011-02-16 Reflector discussion]</i></p>

<p>
Moved to Tentatively Ready after 5 votes.
</p>


<p><b>Proposed resolution:</b></p>
Add the following entries to table 143:

<blockquote>
<table border="1">
<caption>Table 146 &mdash; <tt>atomic</tt> <tt>&lt;inttypes.h&gt;</tt> typedefs</caption>
<tr>
<th>Atomic typedef</th>
<th><tt>&lt;inttypes.h&gt;</tt> type</th>
</tr>
<tr>
<td><tt>...</tt></td>
<td><tt>...</tt></td>
</tr>
<tr>
<td><tt>atomic_intmax_t</tt></td>
<td><tt>intmax_t</tt></td>
</tr>
<tr>
<td><tt>atomic_uintmax_t</tt></td>
<td><tt>uintmax_t</tt></td>
</tr>
<tr>
<td><ins><tt>atomic_int8_t&nbsp;</tt>// <em>iff <tt>int8_t</tt> is provided</em></ins></td>
<td><ins><tt>int8_t</tt></ins></td>
</tr>
<tr>
<td><ins><tt>atomic_uint8_t&nbsp;</tt>// <em>iff <tt>uint8_t</tt> is provided</em></ins></td>
<td><ins><tt>uint8_t</tt></ins></td>
</tr>
<tr>
<td><ins><tt>atomic_int16_t&nbsp;</tt>// <em>iff <tt>int16_t</tt> is provided</em></ins></td>
<td><ins><tt>int16_t</tt></ins></td>
</tr>
<tr>
<td><ins><tt>atomic_uint16_t&nbsp;</tt>// <em>iff <tt>uint16_t</tt> is provided</em></ins></td>
<td><ins><tt>uint16_t</tt></ins></td>
</tr>
<tr>
<td><ins><tt>atomic_int32_t&nbsp;</tt>// <em>iff <tt>int32_t</tt> is provided</em></ins></td>
<td><ins><tt>int32_t</tt></ins></td>
</tr>
<tr>
<td><ins><tt>atomic_uint32_t&nbsp;</tt>// <em>iff <tt>uint32_t</tt> is provided</em></ins></td>
<td><ins><tt>uint32_t</tt></ins></td>
</tr>
<tr>
<td><ins><tt>atomic_int64_t&nbsp;</tt>// <em>iff <tt>int64_t</tt> is provided</em></ins></td>
<td><ins><tt>int64_t</tt></ins></td>
</tr>
<tr>
<td><ins><tt>atomic_uint64_t&nbsp;</tt>// <em>iff <tt>uint64_t</tt> is provided</em></ins></td>
<td><ins><tt>uint64_t</tt></ins></td>
</tr>
</table>
</blockquote> 





<hr>
<h3><a name="1485"></a>1485. [FCD] Unclear <tt>thread::id</tt> specification</h3>
<p><b>Section:</b> 30.3.1.1 [thread.thread.id] <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2011-02-14</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.thread.id">issues</a> in [thread.thread.id].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-184</b></p>

It is unclear when a <tt>thread::id</tt> ceases to be meaningful.
The sentence "The library may reuse the value of a
<tt>thread::id</tt> of a terminated thread that can no longer be
joined." implies that some terminated threads can be
joined. It says nothing about detached threads.

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote>
Require a unique <tt>thread::id</tt> for every thread that is
(1) detached and not terminated or (2) has an associated <tt>std::thread</tt> 
object.
</blockquote>

<p><i>[
2010-11-22 Howard Hinnant observes
]</i></p>


<p>
A thread can either be running or terminated.  Additionally a thread can be joined, detached, or neither.  These combine into the five possible states shown in this table:
</p>

<table border="1">
<tr>
<th></th><th>Running</th><th>Terminated</th>
</tr>
<tr>
<th>Neither joined nor detached</th><td>shall not reuse id</td><td>shall not reuse id</td>
</tr>
<tr>
<th>detached</th><td>shall not reuse id</td><td>may reuse id</td>
</tr>
<tr>
<th>joined</th><td>impossible state</td><td>may reuse id</td>
</tr>
</table>
<p>
Only if a thread is neither joined nor detached can it be joined.  Or said differently, if a thread has already been joined or detached, then it can not be joined.  The sentence:
<blockquote>
The library may reuse the value of a <tt>thread::id</tt> of a terminated thread that can no longer be joined.
</blockquote>
precisely defines the two states shown in the above table where a thread::id may be reused.
</p>
<p>
The following program illustrates all of the possibilities:
</p>
<blockquote><pre>
#include &lt;mutex>
#include &lt;thread>
#include &lt;iostream>
#include &lt;chrono>

std::mutex mut;

void f()
{
   std::lock_guard&lt;std::mutex> _(mut);
   std::cout &lt;&lt; "f id = " &lt;&lt; std::this_thread::get_id() &lt;&lt; " terminating\n";
}

void g()
{
   std::lock_guard&lt;std::mutex> _(mut);
   std::cout &lt;&lt; "g id = " &lt;&lt; std::this_thread::get_id() &lt;&lt; " terminating\n";
}

int main()
{
   std::cout &lt;&lt; "main id = " &lt;&lt; std::this_thread::get_id() &lt;&lt; "\n";
   std::thread t1(f);
   std::thread(g).detach();
   std::this_thread::sleep_for(std::chrono::seconds(1));
   std::cout &lt;&lt; "g's thread::id can be reused here because g has terminated and is detached.\n";
   std::cout &lt;&lt; "f's thread::id can't be reused here because f has terminated but is still joinable.\n";
   std::cout &lt;&lt; "f id = " &lt;&lt; t1.get_id() &lt;&lt; "\n";
   t1.join();
   std::cout &lt;&lt; "f's thread::id can be reused here because f has terminated and is joined.\n";
   std::cout &lt;&lt; "f id = " &lt;&lt; t1.get_id() &lt;&lt; "\n";
}

main id = 0x7fff71197ca0
f id = 0x100381000 terminating
g id = 0x100581000 terminating
g's thread::id can be reused here because g has terminated and is detached.
f's thread::id can't be reused here because f has terminated but is still joinable.
f id = 0x100381000
f's thread::id can be reused here because f has terminated and is joined.
f id = 0x0
</pre></blockquote>

<p><i>[2011-02-11 Reflector discussion]</i></p>

<p>
Moved to Tentatively NAD after 5 votes.
</p>




<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1486"></a>1486. [FCD] Value of <tt>this_thread::get_id()</tt> underspecified for detached thread</h3>
<p><b>Section:</b> 30.3.2 [thread.thread.this] <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Switzerland <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2011-02-14</p>
<p><b>View other</b> <a href="lwg-index-open.html#thread.thread.this">active issues</a> in [thread.thread.this].</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.thread.this">issues</a> in [thread.thread.this].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses CH-24</b></p>

What would be the value <tt>this_thread::get_id()</tt> when called from a detached thread?

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<p>
Add some text to clarify that get_id() still returns
the same value even after detaching.
</p>

<p><i>[
2010-11-22 Howard Hinnant observes
]</i></p>


<p>
30.3.2 [thread.thread.this]/1 contains the following sentence describing <tt>this_thread::get_id()</tt>:
</p>

<blockquote>
... No other thread of execution shall have this id and this thread of execution shall always have this id.
</blockquote>

I don't object to adding "even if detached" to this sentence, but it seems unnecessary to me.  "Always" means always.

<p><i>[2011-02-11 Reflector discussion]</i></p>

<p>
Moved to Tentatively NAD after 5 votes.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="1497"></a>1497. [FCD] <tt>lock()</tt> postcondition can not be generally achieved</h3>
<p><b>Section:</b> 30.5 [thread.condition] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Switzerland <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2010-11-08</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.condition">issues</a> in [thread.condition].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses CH-30</b></p>

If <tt>lock.lock()</tt> throws an exception, the postcondition can not be generally achieved.

<p><i>[
Resolution proposed by ballot comment:
]</i></p>

<blockquote>
Either state that the postcondition might not be achieved, depending on the error condition, or
state that <tt>terminate()</tt> is called in this case.
</blockquote>

<p><i>[
2010-08-13 Peter Sommerlad comments and provides wording
]</i></p>


<blockquote>
30.5.1 [thread.condition.condvar], 30.5.2 [thread.condition.condvarany]
<p/>
p. 13, last bullet, and corresponding paragraphs in all wait functions
<p/>
Problem:<br/>
Condition variable wait might fail, because the lock cannot be acquired when notified.
CH-30 says: "If lock.lock() throws an exception, the postcondition can not be generally achieved."
CH-30 proposes: "Either state that the postcondition might not be achieved, depending on the error 
condition, or state that terminate() is called in this case."
<p/>
The discussion in Rapperswil concluded that calling <tt>terminate()</tt> might be too drastic in 
this case and a corresponding exception should be thrown/passed on and one should use a lock type 
that allows querying its status, which <tt>unique_lock</tt> allows for <tt>std::condition_variable</tt>
<p/>
We also had some additional observations while discussing in Rapperswil:
<ul>
<li>in 30.5.1 [thread.condition.condvar] <tt>wait</tt> with predicate and <tt>wait_until</tt> with 
predicate lack the precondition, postcondition and Error conditions sections. the lack of the precondition 
would allow to call <tt>pred()</tt> without holding the lock.
</li>
<li>in 30.5.1 [thread.condition.condvar] <tt>wait_until</tt> and <tt>wait_for</tt> and 
30.5.2 [thread.condition.condvarany] <tt>wait_for</tt> still specify an 
error condition for a violated precondition. This should be removed.
</li>
</ul>
and add the following proposed solution:
</blockquote>


<p><b>Proposed resolution:</b></p>
<ol>
<li>Change 30.5.1 [thread.condition.condvar] as indicated:
<blockquote><pre>
void wait(unique_lock&lt;mutex&gt;&amp; lock);
</pre></blockquote>
<blockquote>
12 <i>Requires</i>: <tt>lock</tt><ins><tt>.owns_lock()</tt> is <tt>true</tt> and <tt>lock.mutex()</tt></ins> is locked by the calling thread, and either
<ul>
<li>no other thread is waiting on this <tt>condition_variable</tt> object or
</li>
<li><tt>lock.mutex()</tt> returns the same value for each of the <tt>lock</tt> arguments supplied by all concurrently
waiting (via <tt>wait</tt> or <tt>timed_wait</tt>) threads.
</li>
</ul>
</blockquote>
[..]
<blockquote>
14 <em>Postcondition</em>: <tt>lock</tt><ins><tt>.owns_lock()</tt> is <tt>true</tt> and <tt>lock.mutex()</tt></ins> is locked by the calling thread.
</blockquote>
[..]
<blockquote><pre>
template &lt;class Predicate&gt;
void wait(unique_lock&lt;mutex&gt;&amp; lock, Predicate pred);
</pre></blockquote>
<blockquote>
<ins>?? <i>Requires</i>: <tt>lock.owns_lock()</tt> is <tt>true</tt> and <tt>lock.mutex()</tt> is locked by the calling thread, and either</ins>
<ul>
<li><ins>no other thread is waiting on this <tt>condition_variable</tt> object or</ins>
</li>
<li><ins><tt>lock.mutex()</tt> returns the same value for each of the <tt>lock</tt> arguments supplied by all concurrently
waiting (via <tt>wait</tt> or <tt>timed_wait</tt>) threads.</ins>
</li>
</ul>
</blockquote>
<blockquote>
17 <i>Effects</i>:
<blockquote><pre>
while (!pred())
  wait(lock);
</pre></blockquote>
</blockquote>

<blockquote>
<ins>?? <i>Postcondition</i>: <tt>lock.owns_lock()</tt> is <tt>true</tt> and <tt>lock.mutex()</tt> is locked by the calling thread.</ins>
</blockquote>
<blockquote>
<ins>?? <i>Throws</i>: <tt>std::system_error</tt> when an exception is required (30.2.2).</ins>
</blockquote>
<blockquote>
<ins>?? <em>Error conditions</em>:</ins>
<ul>
<li><ins>equivalent error condition from <tt>lock.lock()</tt> or <tt>lock.unlock()</tt>.</ins>
</li>
</ul>
</blockquote>

<blockquote><pre>
template &lt;class Clock, class Duration&gt;
cv_status wait_until(unique_lock&lt;mutex&gt;&amp; lock,
  const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time);
</pre></blockquote>
<blockquote>
18 <i>Requires</i>: <tt>lock</tt><ins><tt>.owns_lock()</tt> is <tt>true</tt> and <tt>lock.mutex()</tt></ins> is locked by the calling thread, and either
<ul>
<li>no other thread is waiting on this <tt>condition_variable</tt> object or
</li>
<li><tt>lock.mutex()</tt> returns the same value for each of the <tt>lock</tt> arguments supplied by all concurrently
waiting (via <tt>wait</tt>, <tt>wait_for</tt>, or <tt>wait_until</tt>) threads.
</li>
</ul>
</blockquote>
[..]
<blockquote>
20 <em>Postcondition</em>: <tt>lock</tt><ins><tt>.owns_lock()</tt> is <tt>true</tt> and <tt>lock.mutex()</tt></ins> is locked by the calling thread.
</blockquote>
[..]
<blockquote>
23 <em>Error conditions</em>:
<ul>
<li><del><tt>operation_not_permitted</tt> &mdash; if the thread does not own the lock.</del>
</li>
<li>equivalent error condition from <tt>lock.lock()</tt> or <tt>lock.unlock()</tt>.
</li>
</ul>
</blockquote>
<blockquote><pre>
template &lt;class Rep, class Period&gt;
cv_status wait_for(unique_lock&lt;mutex&gt;&amp; lock,
  const chrono::duration&lt;Rep, Period&gt;&amp; rel_time);
</pre></blockquote>
<blockquote>
24 <i>Requires</i>: <tt>lock</tt><ins><tt>.owns_lock()</tt> is <tt>true</tt> and <tt>lock.mutex()</tt></ins> is locked by the calling thread, and either
<ul>
<li>no other thread is waiting on this <tt>condition_variable</tt> object or
</li>
<li><tt>lock.mutex()</tt> returns the same value for each of the <tt>lock</tt> arguments supplied by all concurrently
waiting (via <tt>wait</tt>, <tt>wait_for</tt>, or <tt>wait_until</tt>) threads.
</li>
</ul>
</blockquote>
[..]
<blockquote>
27 <em>Postcondition</em>: <tt>lock</tt><ins><tt>.owns_lock()</tt> is <tt>true</tt> and <tt>lock.mutex()</tt></ins> is locked by the calling thread.
</blockquote>
[..]
<blockquote>
29 <em>Error conditions</em>:
<ul>
<li><del><tt>operation_not_permitted</tt> &mdash; if the thread does not own the lock.</del>
</li>
<li>equivalent error condition from <tt>lock.lock()</tt> or <tt>lock.unlock()</tt>.
</li>
</ul>
</blockquote>
<blockquote><pre>
template &lt;class Clock, class Duration, class Predicate&gt;
bool wait_until(unique_lock&lt;mutex&gt;&amp; lock,
  const chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time,
    Predicate pred);
</pre></blockquote>
<blockquote>
<ins>?? <i>Requires</i>: <tt>lock.owns_lock()</tt> is <tt>true</tt> and <tt>lock.mutex()</tt> is locked by the calling thread, and either</ins>
<ul>
<li><ins>no other thread is waiting on this <tt>condition_variable</tt> object or</ins>
</li>
<li><ins><tt>lock.mutex()</tt> returns the same value for each of the <tt>lock</tt> arguments supplied by all concurrently
waiting (via <tt>wait</tt> or <tt>timed_wait</tt>) threads.</ins>
</li>
</ul>
</blockquote>
<blockquote>
30 <i>Effects</i>:
<blockquote><pre>
while (!pred())
  if (wait_until(lock, abs_time) == cv_status::timeout)
    return pred();
return true;
</pre></blockquote>
</blockquote>
<blockquote>
31 <i>Returns</i>: <tt>pred()</tt>
</blockquote>

<blockquote>
<ins>?? <i>Postcondition</i>: <tt>lock.owns_lock()</tt> is <tt>true</tt> and <tt>lock.mutex()</tt> is locked by the calling thread.</ins>
</blockquote>

<blockquote>
32 [ <i>Note</i>: The returned value indicates whether the predicate evaluates to true regardless of whether the
timeout was triggered. &mdash; <i>end note</i> ]
</blockquote>

<blockquote>
<ins>?? <i>Throws</i>: <tt>std::system_error</tt> when an exception is required (30.2.2).</ins>
</blockquote>
<blockquote>
<ins>?? <em>Error conditions</em>:</ins>
<ul>
<li><ins>equivalent error condition from <tt>lock.lock()</tt> or <tt>lock.unlock()</tt>.</ins>
</li>
</ul>
</blockquote>

<blockquote><pre>
template &lt;class Rep, class Period, class Predicate&gt;
bool wait_for(unique_lock&lt;mutex&gt;&amp; lock,
  const chrono::duration&lt;Rep, Period&gt;&amp; rel_time,
    Predicate pred);
</pre></blockquote>
<blockquote>
33 <i>Requires</i>: <tt>lock</tt><ins><tt>.owns_lock()</tt> is <tt>true</tt> and <tt>lock.mutex()</tt></ins> is locked by the calling thread, and either
<ul>
<li>no other thread is waiting on this <tt>condition_variable</tt> object or
</li>
<li><tt>lock.mutex()</tt> returns the same value for each of the <tt>lock</tt> arguments supplied by all concurrently
waiting (via <tt>wait</tt>, <tt>wait_for</tt>, or <tt>wait_until</tt>) threads.
</li>
</ul>
</blockquote>
[..]
<blockquote>
36 <em>Postcondition</em>: <tt>lock</tt><ins><tt>.owns_lock()</tt> is <tt>true</tt> and <tt>lock.mutex()</tt></ins> is locked by the calling thread.
</blockquote>
[..]
<blockquote>
40 <em>Error conditions</em>:
<ul>
<li><del><tt>operation_not_permitted</tt> &mdash; if the thread does not own the lock.</del>
</li>
<li>equivalent error condition from <tt>lock.lock()</tt> or <tt>lock.unlock()</tt>.
</li>
</ul>
</blockquote>

</li>

<li>Change 30.5.2 [thread.condition.condvarany] as indicated:
<p/>
[..]
<blockquote><pre>
template &lt;class Lock, class Predicate&gt;
void wait(Lock&amp; lock, Predicate pred);
</pre></blockquote>
<blockquote>
<ins>[<i>Note</i>: if any of the wait functions exits with an exception it is indeterminate if the <tt>Lock</tt> is held. 
One can use a <tt>Lock</tt> type that allows to query that, such as the <tt>unique_lock</tt> wrapper. &mdash; <i>end note</i>]</ins>
</blockquote>
<blockquote>
14 <i>Effects</i>:
<blockquote><pre>
while (!pred())
  wait(lock);
</pre></blockquote>
</blockquote>

[..]
<blockquote>
34 <em>Error conditions</em>:
<ul>
<li><del><tt>operation_not_permitted</tt> &mdash; if the thread does not own the lock.</del>
</li>
<li>equivalent error condition from <tt>lock.lock()</tt> or <tt>lock.unlock()</tt>.
</li>
</ul>
</blockquote>
</li>

</ol>





<hr>
<h3><a name="1514"></a>1514. [FCD] <tt>packaged_task</tt> constructors need review</h3>
<p><b>Section:</b> 30.6.10.1 [futures.task.members] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> INCITS <b>Opened:</b> 2010-08-25 <b>Last modified:</b> 2011-02-11</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures.task.members">active issues</a> in [futures.task.members].</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.task.members">issues</a> in [futures.task.members].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p><b>Addresses US-207</b></p>

The constructor that takes <tt>R(*)(ArgTypes...)</tt> is not
needed; the constructor that takes a callable type works
for this argument type. More generally, the constructors
for packaged_task should parallel those for function.

<p><i>[
US-207 Suggested Resolution:
]</i></p>


<blockquote>
Review the constructors for packaged_task and
provide the same ones as function, except where
inappropriate.
</blockquote>

<p><i>[
2010-10-22 Howard provides wording, as requested by the LWG in Rapperswil.
]</i></p>


<p><i>[2011-02-10 Reflector discussion]</i></p>

<p>
Moved to Tentatively Ready after 5 votes.
</p>


<p><b>Proposed resolution:</b></p>
Alter the list of constructors in both [futures.task] and in [futures.task.members] as indicated:

<blockquote>
<pre><del>template &lt;class F&gt;
explicit packaged_task(F f);
template &lt;class F, class Allocator&gt;
explicit packaged_task(allocator_arg_t, const Allocator&amp; a, F f);
explicit packaged_task(R(*f)(ArgTypes...));</del>
template &lt;class F&gt;
explicit packaged_task(F&amp;&amp; f);
template &lt;class F, class Allocator&gt;
explicit packaged_task(allocator_arg_t, const Allocator&amp; a, F&amp;&amp; f);
</pre>
</blockquote>





<hr>
<h3><a name="2000"></a>2000. Missing definition of <tt>packaged_task</tt> specialization of <tt>uses_allocator</tt></h3>
<p><b>Section:</b> 30.6.10.2 [futures.task.nonmembers] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Howard Hinnant <b>Opened:</b> 2010-08-29 <b>Last modified:</b> 2010-11-13</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
[futures.task.nonmembers]/3 says:
<blockquote><pre>
   template &lt;class R, class Alloc&gt;
     struct uses_allocator&lt;packaged_task&lt;R&gt;, Alloc&gt;;
</pre></blockquote>

This is a declaration, but should be a definition.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change [futures.task.nonmembers]/3:
</p>

<blockquote><pre>
   template &lt;class R, class Alloc&gt;
     struct uses_allocator&lt;packaged_task&lt;R&gt;, Alloc&gt;<del>;</del>
        <ins>: true_type {};</ins>
</pre></blockquote>





<hr>
<h3><a name="2004"></a>2004. <tt>duration::operator*</tt> has template parameters in funny order</h3>
<p><b>Section:</b> 20.11.3.5 [time.duration.nonmember] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2010-10-14 <b>Last modified:</b> 2010-11-13</p>
<p><b>View other</b> <a href="lwg-index-open.html#time.duration.nonmember">active issues</a> in [time.duration.nonmember].</p>
<p><b>View all other</b> <a href="lwg-index.html#time.duration.nonmember">issues</a> in [time.duration.nonmember].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In [time] and [time.duration.nonmember] we have:
</p>
<blockquote><pre>
template &lt;class Rep1, class Period, class Rep2>
    duration&lt;typename common_type&lt;Rep1, Rep2>::type, Period>
        operator*(const Rep1&amp; s, const duration&lt;Rep2, Period>&amp; d);
</pre></blockquote>
<p>
Everywhere else, we always have <tt>&lt;rep, period></tt> in that order for a given
type. But here, we have <tt>Period</tt> and <tt>Rep2</tt> in reverse order for
<tt>&lt;Rep2, Period></tt>. This is probably of little importance, since the
template parameters are seldom spelled out for a function like this. But changing it
now will eliminate a potential source of future errors and confusion.
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change the signature in [time] and [time.duration.nonmember] to:
</p>
<blockquote><pre>
template &lt;class Rep1, class <del>Period</del><ins>Rep2</ins>, class <del>Rep2</del><ins>Period</ins>>
    duration&lt;typename common_type&lt;Rep1, Rep2>::type, Period>
        operator*(const Rep1&amp; s, const duration&lt;Rep2, Period>&amp; d);
</pre></blockquote>





<hr>
<h3><a name="2006"></a>2006. <tt>emplace</tt> broken for associative containers</h3>
<p><b>Section:</b> 23.2.5 [unord.req] <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Pablo Halpern <b>Opened:</b> 2010-10-18 <b>Last modified:</b> 2010-11-13</p>
<p><b>View other</b> <a href="lwg-index-open.html#unord.req">active issues</a> in [unord.req].</p>
<p><b>View all other</b> <a href="lwg-index.html#unord.req">issues</a> in [unord.req].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The current definition of <tt>emplace(args)</tt> for associative containers as
described in Table 99 is:
<blockquote>
<p>
<i>Requires</i>: <tt>T</tt> shall be constructible from <tt>args</tt>.
</p>
<p>
<i>Effects</i>: Inserts a <tt>T</tt> object <tt>t</tt> constructed with
<tt>std::forward&lt;Args&gt;(args)...</tt> if and only if there is no element
in the container with key equivalent to the key of <tt>t</tt>.  The <tt>bool</tt>
component of the returned <tt>pair</tt> is <tt>true</tt> if and only if the
insertion takes place, and the iterator component of the <tt>pair</tt>
points to the element with key equivalent to the key of <tt>t</tt>.
</p>
</blockquote>
</p>
<p>
There is similar language in Table 100 for unordered associative containers.
</p>
<p>
The first issue is editorial: <tt>T</tt> should be <tt>value_type</tt> throughout
both tables.
</p>
<p>
The major issue is that, if the container is <tt>map</tt>, <tt>multimap</tt>,
<tt>unordered_map</tt>, or <tt>unordered_multimap</tt>, then the only way to
construct an object of <tt>value_type</tt> is to supply exactly two arguments
for <tt>Key</tt> and <tt>Value</tt>, a <tt>pair&lt;Key,Value&gt;</tt>, or a
<tt>piecewise_construct_t</tt> followed by two <tt>tuple</tt>s.  The original
<tt>emplace()</tt> proposal would have allowed you to specify a <tt>Key</tt>
value followed by any number of constructor arguments for <tt>Value</tt>.
When we removed the variadic constructor to <tt>pair</tt>, this ability went
away.  I don't think that was deliberate.
</p>
<p>
Fixing this is non-trivial, I think. I think that <tt>emplace()</tt> for <tt>map</tt>
and <tt>multimap</tt> need several overloads: one for each overloaded constructor in
<tt>pair&lt;Key,Value&gt;</tt>, and one for the <tt>emplace(Key, valueargs...)</tt> case.
And it probably needs some SFINAE meta-programming to ensure that the last case
doesn't override any of the other ones.  Alternatively, one could say that
there are exactly two cases: <tt>emplace(args)</tt> where <tt>pair&lt;Key,Value&gt;</tt>
is constructible from <tt>args</tt>, and <tt>emplace(args)</tt> where <tt>Key</tt> is
constructible form the first <tt>arg</tt> and <tt>Value</tt> is constructible from the
rest.
</p>
<p>
Alternatively, the status quo is to use <tt>piecewise_construct_t</tt> if you want to
construct an object.
</p>

<p><i>[
2010 Batavia:
]</i></p>


<p>
N3178 was looked at in session and moved to NAD.
</p>


<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2007"></a>2007. Incorrect specification of return value for <tt>map&lt;&gt;::at()</tt></h3>
<p><b>Section:</b> 23.6.1.2 [map.access] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Matt Austern <b>Opened:</b> 2010-11-01 <b>Last modified:</b> 2010-11-13</p>
<p><b>View all other</b> <a href="lwg-index.html#map.access">issues</a> in [map.access].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In [map.access]/9, the <i>Returns</i> clause for <tt>map&lt;Key, T&gt;::at(x)</tt> says 
that it returns "a reference to the element whose key is equivalent to <tt>x</tt>." That can't be right. 
The signature for <tt>at()</tt> says that its return type is <tt>T</tt>, but the elements 
of <tt>map&lt;Key, T&gt;</tt> have type <tt>pair&lt;const K, T&gt;</tt>.  (I checked [unord.map.elem] 
and found that its specification of <tt>at()</tt> is correct. This is a problem for <tt>map</tt> only.)
</p>


<p><b>Proposed resolution:</b></p>
<p>
Change the wording in [map.access]/9 so it's identical to what we already say for <tt>operator[]</tt>, 
which is unambiguous and correct.
</p>
<blockquote>
<i>Returns</i>: A reference to the <del>element whose key is equivalent</del><ins><tt>mapped_type</tt> 
corresponding</ins> to <tt>x</tt><ins> in <tt>*this</tt></ins>.
</blockquote>





<hr>
<h3><a name="2014"></a>2014. More restrictions on macro names</h3>
<p><b>Section:</b> 17.6.3.3.1 [macro.names] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Alberto Ganesh Barbati <b>Opened:</b> 2010-11-16 <b>Last modified:</b> 2011-02-11</p>
<p><b>View all other</b> <a href="lwg-index.html#macro.names">issues</a> in [macro.names].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
A program is currently forbidden to use keywords as macro names. This restriction should be strengthened to include all identifiers 
that could be used by the library as attribute-tokens (for example <tt>noreturn</tt>, which is used by header <tt>&lt;cstdlib&gt;</tt>) 
and the special identifiers introduced recently for override control (these are not currently used in the library public interface,
but could potentially be used by the implementation or in future revisions of the library).

<p><i>[2011-02-10 Reflector discussion]</i></p>

<p>
Moved to Tentatively Ready after 5 votes.
</p>


<p><b>Proposed resolution:</b></p>
<p>Modify 17.6.3.3.1 [macro.names] paragraph 2 as follows:</p>

<blockquote>
A translation unit shall not <tt>#define</tt> or <tt>#undef</tt> names
lexically identical to keywords<ins>, to the identifiers listed in Table
X [Identifiers with special meaning], or to the <i>attribute-tokens</i>
described in clause 7.6 [dcl.attr]</ins>.
</blockquote>






<hr>
<h3><a name="2024"></a>2024. Inconsistent implementation requirements for <tt>atomic&lt;<i>integral</i>&gt;</tt> and <tt>atomic&lt;T*&gt;</tt></h3>
<p><b>Section:</b> 29.5 [atomics.types.generic] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2010-12-08 <b>Last modified:</b> 2011-02-11</p>
<p><b>View all other</b> <a href="lwg-index.html#atomics.types.generic">issues</a> in [atomics.types.generic].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
Paragraph 5 and 6 of 29.5 [atomics.types.generic] impose different requirements on implementations for
specializations of the <tt>atomic</tt> class template for integral types and for pointer types:

<blockquote>
5 The atomic integral specializations and the specialization <tt>atomic&lt;bool&gt;</tt> shall have standard layout. 
They shall each have a trivial default constructor and a trivial destructor. They shall each support aggregate
initialization syntax.
</blockquote>
<p/>
<blockquote>
6 There are pointer partial specializations on the <tt>atomic</tt> class template. These specializations shall have 
trivial default constructors and trivial destructors.
</blockquote>

<p>
It looks like an oversight to me, that for pointer specializations the requirements for standard layout and
support for aggregate initialization syntax are omitted. In fact, this been confirmed by the 
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3193.htm">N3193</a> proposal author. I suggest
to impose the same implementation requirements for pointer types as for integral types, this should not impose 
unrealistic requirements on implementations.
</p>

<p><i>[2011-02-10 Reflector discussion]</i></p>

<p>
Moved to Tentatively Ready after 5 votes.
</p>


<p><b>Proposed resolution:</b></p>
<p>
The suggested wording changes are against the working draft N3225.
</p>

<ol>
<li>
<p>Change 29.5 [atomics.types.generic] p. 6 as indicated:</p>

<blockquote>
6 There are pointer partial specializations on the <tt>atomic</tt> class template. These specializations shall have 
<ins>standard layout,</ins> trivial default constructors<ins>,</ins> and trivial destructors. <ins> They shall each 
support aggregate initialization syntax.</ins>
</blockquote>

</li>
</ol>





</body>
</html>
