<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>C++ Standard Library Tentative Issues</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
</style>
</head>
<body>
<p>Revised 2013-06-30 at 21:06:08 UTC</p>
<h2>Tentative Issues</h2>
<hr>
<h3><a name="2078"></a>2078. Throw specification of <tt>async()</tt> incomplete</h3>
<p><b>Section:</b> 30.6.8 [futures.async] <b>Status:</b> <a href="lwg-active.html#NAD Editorial">Tentatively NAD Editorial</a>
 <b>Submitter:</b> Nicolai Josuttis <b>Opened:</b> 2011-08-29 <b>Last modified:</b> 2012-11-03</p>
<p><b>View other</b> <a href="lwg-index-open.html#futures.async">active issues</a> in [futures.async].</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.async">issues</a> in [futures.async].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD Editorial">Tentatively NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The current throw specification of <tt>async()</tt> does state:
</p>
<blockquote><p>
-6- <i>Throws</i>: <tt>system_error</tt> if policy is <tt>launch::async</tt> and 
the implementation is unable to start a new thread.
</p></blockquote>
<p>
First it seems not clear whether this only applies if policy equals 
<tt>launch::async</tt> of if the <tt>async</tt> launch mode flag is set 
(if <tt>policy|launch::async!=0</tt>)
<p/>
In the discussion Lawrence Crowl also wrote:
</p>
<blockquote><p>
    More generally, I think what we want to say is that if the
    implementation cannot successfully execute on one of the policies
    allowed, then it must choose another. The principle would apply
    to implementation-defined policies as well.
</p></blockquote>

<p>
Peter Sommerlad:
</p>
<blockquote><p>
Should not throw. That was the intent. "is async" meat exactly.
</p></blockquote>

<p><i>[2012, Portland: move to Tentatively NAD Editorial]</i></p>

<p>
If no launch policy, it is undefined behavior.
</p>
<p>
Agree with Lawrence, should try all the allowed policies. We will rephrase so that
the policy argument should be <tt>lauch::async</tt>. Current wording seems good enough.
</p>
<p>
We believe this choice of policy statement is really an editorial issue.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2085"></a>2085. Wrong description of effect 1 of <tt>basic_istream::ignore</tt></h3>
<p><b>Section:</b> 27.7.2.3 [istream.unformatted] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Krzysztof Zelechowski <b>Opened:</b> 2011-09-11 <b>Last modified:</b> 2013-05-20</p>
<p><b>View other</b> <a href="lwg-index-open.html#istream.unformatted">active issues</a> in [istream.unformatted].</p>
<p><b>View all other</b> <a href="lwg-index.html#istream.unformatted">issues</a> in [istream.unformatted].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p>
27.7.2.3 [istream.unformatted] in N3242 currently has the following to say about the
semantics of <tt>basic_istream::ignore</tt>:
</p>

<blockquote><p>
[..]. Characters are extracted until any of the following occurs:
</p>
<ul>
<li>if <tt>n != numeric_limits&lt;streamsize&gt;::max()</tt> (18.3.2), <tt>n</tt> characters are extracted
</li>
</ul>
</blockquote>

<p>
This statement, apart from being slightly ungrammatical, indicates that if
(<tt>n == numeric_limits&lt;streamsize&gt;::max()</tt>), the method returns without
extracting any characters.
<p/>
The description intends to describe the observable behaviour of an
implementation in terms of logical assertions.  Logical assertions are not
"bullets" that can be "entered" but need not; they are predicates that can
evaluate to true or false.
<p/>
The description contains two predicates, either of them causes extraction to
terminate.  In the incriminated case, the first predicate is evaluates to
true because its premise is false, therefore no characters will be
extracted.
<p/>
The intended semantics would be described by the following statement:
</p>

<blockquote><p>
[..]. Characters are extracted until any of the following occurs:
</p>
<ul>
<li><tt>(n != numeric_limits&lt;streamsize&gt;::max())</tt> (18.3.2) and (<tt>n</tt>) characters
have been extracted so far.
</li>
</ul>
</blockquote>

<p><i>[2013-04-20, Bristol]</i></p>


<p>
Resolution: Ready. 
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS.</p>

<p>Change 27.7.2.3 [istream.unformatted] p25 as indicated:</p>

<blockquote><pre>
basic_istream&lt;charT,traits&gt;&amp;
  ignore(streamsize n = 1, int_type delim = traits::eof());
</pre><blockquote><p>
-25- <i>Effects</i>: Behaves as an unformatted input function (as described in 27.7.2.3 [istream.unformatted], paragraph 1). After
constructing a <tt>sentry</tt> object, extracts characters and discards them. Characters are extracted until
any of the following occurs:
</p>
<ul>
<li><del>if</del> <tt>n != numeric_limits&lt;streamsize&gt;::max()</tt> (18.3.2.1 [limits.numeric])<del>,</del><ins>and</ins> 
<tt>n</tt> characters <del>are</del><ins>have been</ins> extracted <ins>so far</ins>
</li>
<li>end-of-file occurs on the input sequence (in which case the function calls <tt>setstate(eofbit)</tt>,
which may throw <tt>ios_base::failure</tt> (27.5.5.4 [iostate.flags]));
</li>
<li><tt>traits::eq_int_type(traits::to_int_type(c), delim)</tt> for the next available input character <tt>c</tt> 
(in which case <tt>c</tt> is extracted).
</li>
</ul>
</blockquote></blockquote>





<hr>
<h3><a name="2087"></a>2087. <tt>iostream_category()</tt> and <tt>noexcept</tt></h3>
<p><b>Section:</b> 27.5 [iostreams.base] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Nicolai Josuttis <b>Opened:</b> 2011-09-22 <b>Last modified:</b> 2013-05-20</p>
<p><b>View all other</b> <a href="lwg-index.html#iostreams.base">issues</a> in [iostreams.base].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p>
In <tt>&lt;system_error&gt;</tt> we have:
</p>

<blockquote><pre>
const error_category&amp; generic_category() noexcept;
const error_category&amp; system_category() noexcept;
</pre></blockquote>

<p>
In <tt>&lt;future&gt;</tt> we have:
</p>

<blockquote><pre>
const error_category&amp; future_category() noexcept;
</pre></blockquote>

<p>
But in <tt>&lt;ios&gt;</tt> we have:
</p>

<blockquote><pre>
const error_category&amp; iostream_category();
</pre></blockquote>

<p>
Is there any reason that <tt>iostream_category()</tt> is not declared with 
<tt>noexcept</tt> or is this an oversight?
</p>

<p>
Daniel:
<p/>
This looks like an oversight to me. We made the above
mentioned changes as part of noexcept-ifying the thread
library but <tt>iostream_category()</tt> was skipped, so it seems
to be forgotten. There should be no reason, why it cannot
be <tt>noexcept</tt>. When doing so, we should also make these functions
<tt>noexcept</tt> (similar to corresponding overloads):
</p>
<blockquote><pre>
error_code make_error_code(io_errc e);
error_condition make_error_condition(io_errc e);
</pre></blockquote>

<p>
Suggested wording provided by Daniel.
</p>

<p><i>[2013-04-20, Bristol]</i></p>


<p>
Unanimous.
<p/>
Resolution: move to tentatively ready. 
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS.</p>

<ol><li>
<p>Change 27.5.1 [iostreams.base.overview], header <tt>&lt;ios&gt;</tt> synopsis 
as indicated:
</p>
<blockquote><pre>
#include &lt;iosfwd&gt;
namespace std {
  [&hellip;]
  error_code make_error_code(io_errc e) <ins>noexcept</ins>;
  error_condition make_error_condition(io_errc e) <ins>noexcept</ins>;
  const error_category&amp; iostream_category() <ins>noexcept</ins>;
}
</pre></blockquote>

</li>
<li>
<p>Change the prototype declarations in 27.5.6.5 [error.reporting] as indicated:
</p>
<blockquote><pre>
error_code make_error_code(io_errc e) <ins>noexcept</ins>;
</pre></blockquote><blockquote>
<p>
-1- <i>Returns</i>: <tt>error_code(static_cast&lt;int&gt;(e), iostream_category())</tt>.
</p>
</blockquote><blockquote><pre>
error_condition make_error_condition(io_errc e) <ins>noexcept</ins>;
</pre></blockquote><blockquote>
<p>
-2- <i>Returns</i>: <tt>error_condition(static_cast&lt;int&gt;(e), iostream_category())</tt>.
</p>
</blockquote><blockquote><pre>
const error_category&amp; iostream_category() <ins>noexcept</ins>;
</pre></blockquote><blockquote>
<p>
-3- <i>Returns</i>: A reference to an object of a type derived from class <tt>error_category</tt>.
<p/>
-4- The object’s <tt>default_error_condition</tt> and <tt>equivalent</tt> virtual functions shall behave as specified
for the class <tt>error_category</tt>. The object’s <tt>name</tt> virtual function shall return a pointer to the string
<tt>"iostream"</tt>.
</p>
</blockquote>
</li>
</ol>






<hr>
<h3><a name="2125"></a>2125. <tt>TimedMutex</tt> specification problem</h3>
<p><b>Section:</b> 30.4.1.3 [thread.timedmutex.requirements], 30.4.1.3.1 [thread.timedmutex.class] <b>Status:</b> <a href="lwg-active.html#NAD Editorial">Tentatively NAD Editorial</a>
 <b>Submitter:</b> Vicente J. Botet Escriba <b>Opened:</b> 2012-01-01 <b>Last modified:</b> 2012-11-03</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.timedmutex.requirements">issues</a> in [thread.timedmutex.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD Editorial">Tentatively NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p>
30.4.1.3.1 [thread.timedmutex.class] says:
</p>
<blockquote><p>
The class <tt>timed_mutex</tt> shall satisfy all of the <tt>TimedMutex</tt> requirements (30.4.1.3 [thread.timedmutex.requirements]). 
It shall be a standardlayout class (Clause 9 [class]).
</p></blockquote>
<p>
Problem here is that 30.4.1.3 [thread.timedmutex.requirements] does not define a requirement set named &quot;<tt>TimedMutex</tt>&quot;,
it only refers to &quot;<i>timed mutex types</i>&quot;
</p>

<p><i>[See also issue <a href="lwg-active.html#2126">2126</a>]</i></p>


<p><i>[2012, Portland: move to Tentatively NAD Editorial]</i></p>

<p>
We have timed mutex type, but it is labeled timed mutex requirements
</p>
<p>
We can make a suggestion, but will send to the editor as it seems purely editorial.
There is a typo, and we don't have the timed mutex but 30.4.1.3 [thread.timedmutex.requirements] already
says timed mutex type, and we need to reuse that term down in the class to fulfil the mutex requirement.
</p>
<p><i>[To Editor:]</i></p>

<p>
Replace this one with timed mutex type.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2126"></a>2126. Several specification problems in regard to mutex requirements</h3>
<p><b>Section:</b> 30.4.1 [thread.mutex.requirements], 30.4.1.2.1 [thread.mutex.class], 30.4.1.2 [thread.mutex.requirements.mutex], 30.4.1.2.2 [thread.mutex.recursive], 30.4.1.3 [thread.timedmutex.requirements], 30.4.1.3.1 [thread.timedmutex.class], 30.4.1.3.2 [thread.timedmutex.recursive] <b>Status:</b> <a href="lwg-active.html#NAD Editorial">Tentatively NAD Editorial</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2012-01-16 <b>Last modified:</b> 2012-11-03</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.mutex.requirements">issues</a> in [thread.mutex.requirements].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD Editorial">Tentatively NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p>
 30.4.1.2.1 [thread.mutex.class]&#47;3 says that the class mutex "shall satisfy all the <tt>Mutex</tt> requirements (30.4.1 [thread.mutex.requirements])". 
 30.4.1.2.1 [thread.mutex.class] is part of 30.4.1 [thread.mutex.requirements], so at the very least, this 
 requirement is recursive. But worse, there is nothing that says what "the <tt>Mutex</tt> requirements" refers to. For example, 
 the "<tt>Lockable</tt> requirements" section starts with "A type <tt>L</tt> meets the <tt>Lockable</tt> requirements if &hellip;". There is no such 
 statement for "the <tt>Mutex</tt> requirements".
<p/>
Organizationally, paragraphs 1-26 in 30.4.1.2 [thread.mutex.requirements.mutex] should probably be in a subclause with a name. 
(This is actually an ISO requirement, to avoid exactly this kind of ambiguous referencing) Then the first sentence of 
30.4.1.2.1 [thread.mutex.class]&#47;3 can become a note: "The class mutex meets the requirements of (whatever)", since that 
subclause already says that the mutex types "shall meet the requirements set out in this section."
<p/>
And similarly for 30.4.1.2.2 [thread.mutex.recursive]&#47;2 (<tt>recursive_mutex</tt>).
<p/>
30.4.1.3 [thread.timedmutex.requirements], Timed mutex types, also needs the same rearrangement: its introductory 
requirements should be moved into a subclause, and the first sentences of 30.4.1.3.1 [thread.timedmutex.class]&#47;2 
and 30.4.1.3.2 [thread.timedmutex.recursive]&#47;2 should be turned into notes that refer to this new subclause and 
to the new subclause in 30.4.1.2 [thread.mutex.requirements.mutex].
</p>

<p><i>[See also issue <a href="lwg-active.html#2125">2125</a>]</i></p>


<p><i>[2012, Portland: move to Tentatively NAD Editorial]</i></p>

<p>
Seems no real ambiguity. May need some reorg of text rather then changing the wording.
</p>
<p>
Is there much that needs to be changed? But Pete's suggestion of putting requirement in separate sub section is good.
Should be the direction to editor.
</p>
<p>
Suggest this is an editorial change. Happy with Pete's comments.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2131"></a>2131. Member function getline taking a string as parameter</h3>
<p><b>Section:</b> 27.7.2.3 [istream.unformatted] <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Lo&iuml;c Joly <b>Opened:</b> 2012-03-05 <b>Last modified:</b> 2013-05-20</p>
<p><b>View other</b> <a href="lwg-index-open.html#istream.unformatted">active issues</a> in [istream.unformatted].</p>
<p><b>View all other</b> <a href="lwg-index.html#istream.unformatted">issues</a> in [istream.unformatted].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>
<p>
I think the following code should be legal:
</p>
<blockquote><pre>
void f(std::istream&amp; is)
{
  std::string s;
  is.getline(s); // Would be equivalent to std::getline(is, s)
}
</pre></blockquote>

<p><i>[2013-04-20, Bristol]</i></p>


<p>
Unanimous that this is a new feature request and not a issue. 
<p/>
Resolution: Tentatively NAD 
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3376.</p>

<ol>
<li><p>Change the class template <tt>basic_istream</tt> synopsis, 27.7.2.1 [istream], as indicated</p>
<blockquote><pre>
namespace std {
  template &lt;class charT, class traits = char_traits&lt;charT&gt; &gt;
  class basic_istream : virtual public basic_ios&lt;charT,traits&gt; {
  public:
    [&hellip;]
    <i>// 27.7.2.3 Unformatted input:</i>
    [&hellip;]
    basic_istream&lt;charT,traits&gt;&amp; getline(char_type* s, streamsize n);
    basic_istream&lt;charT,traits&gt;&amp; getline(char_type* s, streamsize n,
      char_type delim);
    <ins>template&lt;class Allocator&gt;
    basic_istream&lt;charT,traits&gt;&amp; getline(basic_string&lt;charT,traits,Allocator&gt;&amp; str);
    template&lt;class Allocator&gt;
    basic_istream&lt;charT,traits&gt;&amp; getline(basic_string&lt;charT,traits,Allocator&gt;&amp; str,
      char_type delim);</ins>
    [&hellip;]
  };
}
</pre></blockquote>
</li>

<li><p>Insert the following two new prototype descriptions after 27.7.2.3 [istream.unformatted] paragraph 24:</p>

<blockquote>
<pre>
basic_istream&lt;charT,traits&gt;&amp; getline(char_type* s, streamsize n);
</pre>
<blockquote><p>
-24- <i>Returns</i>: <tt>getline(s,n,widen('\n'))</tt>
</p>
</blockquote>

<pre>
<ins>template&lt;class Allocator&gt;
basic_istream&lt;charT,traits&gt;&amp; getline(basic_string&lt;charT,traits,Allocator&gt;&amp; str);</ins>
</pre>
<blockquote><p>
<ins>-??- <i>Returns</i>: <tt>std::getline(*this, str)</tt></ins>
</p>
</blockquote>

<pre>
<ins>template&lt;class Allocator&gt;
basic_istream&lt;charT,traits&gt;&amp; getline(basic_string&lt;charT,traits,Allocator&gt;&amp; str, char_type delim);</ins>
</pre>
<blockquote><p>
<ins>-??- <i>Returns</i>: <tt>std::getline(*this, str, delim)</tt></ins>
</p>
</blockquote>

</blockquote>
</li>
</ol>






<hr>
<h3><a name="2134"></a>2134. Redundant Mutex requirement?</h3>
<p><b>Section:</b> 30.4.1.2 [thread.mutex.requirements.mutex] <b>Status:</b> <a href="lwg-active.html#NAD Editorial">Tentatively NAD Editorial</a>
 <b>Submitter:</b> Pete Becker <b>Opened:</b> 2012-03-05 <b>Last modified:</b> 2012-11-03</p>
<p><b>View all other</b> <a href="lwg-index.html#thread.mutex.requirements.mutex">issues</a> in [thread.mutex.requirements.mutex].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD Editorial">Tentatively NAD Editorial</a> status.</p>
<p><b>Discussion:</b></p>

<p>
30.4.1.2 [thread.mutex.requirements.mutex]&#47;11 says that prior unlock operations <em>synchronize with</em> <tt>m.lock()</tt>.
<p/>
30.4.1.2 [thread.mutex.requirements.mutex]&#47;19 says that if <tt>m.try_lock()</tt> succeeds, prior unlock operations 
<em>synchronize with</em> the operation. 
<p/>
30.4.1.2 [thread.mutex.requirements.mutex]&#47;25 says that <tt>m.unlock()</tt> <em>synchronizes with</em> subsequent 
successful lock operations. 
<p/>
Does the third requirement add anything to the first two? If not, it should probably be a non-normative note.
</p>

<p><i>[2012, Portland: move to Tentatively NAD Editorial]</i></p>

<p>
Agree that third note should be non-normative and adds nothing.
</p>
<p>
Seems An Editorial change, but does changing a normative to non-normative wording makes it a non-editorial change?
</p>
<p>
Ask the editor. If not editorial, then we will agree on the fix as removal of the third point,
then we will put it in ready state for Bristol.
</p>



<p><b>Proposed resolution:</b></p>





<hr>
<h3><a name="2143"></a>2143. <tt>ios_base::xalloc</tt> should be thread-safe</h3>
<p><b>Section:</b> 27.5.3 [ios.base] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Alberto Ganesh Barbati <b>Opened:</b> 2012-03-14 <b>Last modified:</b> 2013-05-20</p>
<p><b>View all other</b> <a href="lwg-index.html#ios.base">issues</a> in [ios.base].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The static function <tt>ios_base::xalloc()</tt> could be called from multiple threads and is not covered by 
17.6.4.10 [res.on.objects] and 17.6.5.9 [res.on.data.races]. Adding a thread-safety requirement 
should not impose a significant burden on implementations, as the function can be easily implemented with 
hopefully lock-free atomics.
</p>

<p><i>[2013-04-20, Bristol]</i></p>


<p>
Unanimous.
<p/>
Resolution: move tentatively ready. (Inform Bill about this issue.)  
</p>


<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3376.</p>

<ol>
<li><p>In 27.5.3.5 [ios.base.storage] add a new paragraph after paragraph 1:</p>

<blockquote><pre>
static int xalloc();
</pre><blockquote>
<p>
-1- <i>Returns</i>: <tt>index ++</tt>.
<p/>
<ins>-?- <i>Remarks</i>: Concurrent access to this function by multiple threads shall not result in a data 
race (1.10 [intro.multithread]).</ins>
</p>
</blockquote></blockquote>
</li>
</ol>






<hr>
<h3><a name="2150"></a>2150. Unclear specification of <tt>find_end</tt></h3>
<p><b>Section:</b> 25.2.6 [alg.find.end] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Andrew Koenig <b>Opened:</b> 2012-03-28 <b>Last modified:</b> 2013-05-20</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p>
25.2.6 [alg.find.end] describes the behavior of find_end as returning:
</p>
<blockquote><p>
The last iterator <tt>i</tt> in the range <tt>[first1,last1 - (last2 - first2))</tt> such that for any 
nonnegative integer <tt>n &lt; (last2 - first2)</tt>, the following corresponding conditions hold: 
<tt>*(i + n) == *(first2 + n), pred(*(i + n), *(first2 + n)) != false</tt>.
</p></blockquote>
<p>
Does "for any" here mean "for every" or "there exists a"?  I think it means the former, but it could be 
interpreted either way.
<p/>
Daniel: The same problem exists for the following specifications from Clause 25 [algorithms]:
</p>
<ol>
<li>25.2.13 [alg.search] p2 and p6</li>
<li>25.3.10 [alg.reverse] p4</li>
<li>25.3.13 [alg.partitions] p5 and p9</li>
<li>25.4 [alg.sorting] p5</li>
<li>25.4.2 [alg.nth.element] p1</li>
<li>25.4.3.1 [lower.bound] p2</li>
<li>25.4.3.2 [upper.bound] p2</li>
<li>25.4.7 [alg.min.max] p21 and p23</li>
</ol>

<p><i>[2013-04-20, Bristol]</i></p>


<p>
Unanimous agreement on the wording.
<p/>
Resolution: move to tentatively ready 
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3376.</p>

<ol>
<li>
<p>Change 25.2.6 [alg.find.end] p2 as indicated:</p>

<blockquote><pre>
template&lt;class ForwardIterator1, class ForwardIterator2&gt;
ForwardIterator1 
find_end(ForwardIterator1 first1, ForwardIterator1 last1,
         ForwardIterator2 first2, ForwardIterator2 last2);
template&lt;class ForwardIterator1, class ForwardIterator2,
         class BinaryPredicate&gt;
ForwardIterator1
find_end(ForwardIterator1 first1, ForwardIterator1 last1,
         ForwardIterator2 first2, ForwardIterator2 last2,
         BinaryPredicate pred);
</pre><blockquote><p>
[&hellip;]
<p/>
-2- <i>Returns</i>: The last iterator <tt>i</tt> in the range <tt>[first1,last1 - (last2 - first2))</tt> such 
that for <del>any</del><ins>every</ins> nonnegative integer <tt>n &lt; (last2 - first2)</tt>, the following 
corresponding conditions hold: <tt>*(i + n) == *(first2 + n), pred(*(i + n), *(first2 + n)) != false</tt>.
Returns <tt>last1</tt> if <tt>[first2,last2)</tt> is empty or if no such iterator is found.
</p></blockquote></blockquote>
</li>

<li>
<p>Change 25.2.13 [alg.search] p2 and p6 as indicated:</p>

<blockquote><pre>
template&lt;class ForwardIterator1, class ForwardIterator2&gt;
ForwardIterator1
search(ForwardIterator1 first1, ForwardIterator1 last1,
       ForwardIterator2 first2, ForwardIterator2 last2);
template&lt;class ForwardIterator1, class ForwardIterator2,
         class BinaryPredicate&gt;
ForwardIterator1
search(ForwardIterator1 first1, ForwardIterator1 last1,
       ForwardIterator2 first2, ForwardIterator2 last2,
       BinaryPredicate pred);
</pre><blockquote><p>
[&hellip;]
<p/>
-2- <i>Returns</i>: The first iterator <tt>i</tt> in the range <tt>[first1,last1 - (last2-first2))</tt> 
such that for <del>any</del><ins>every</ins> nonnegative integer <tt>n</tt> less than <tt>last2 - first2</tt> 
the following corresponding conditions hold: <tt>*(i + n) == *(first2 + n), pred(*(i + n), *(first2 + n)) != false</tt>. 
Returns <tt>first1</tt> if <tt>[first2,last2)</tt> is empty, otherwise returns <tt>last1</tt> if no such iterator 
is found.
</p></blockquote></blockquote>
<p>
[&hellip;]
</p>
<blockquote><pre>
template&lt;class ForwardIterator, class Size, class T&gt;
ForwardIterator
search_n(ForwardIterator first, ForwardIterator last, Size count,
         const T&amp; value);
template&lt;class ForwardIterator, class Size, class T,
         class BinaryPredicate&gt;
ForwardIterator
search_n(ForwardIterator first, ForwardIterator last, Size count,
         const T&amp; value, BinaryPredicate pred);
</pre><blockquote><p>
[&hellip;]
<p/>
-6- <i>Returns</i>: The first iterator <tt>i</tt> in the range <tt>[first,last-count)</tt> such that 
for <del>any</del><ins>every</ins> non-negative integer <tt>n</tt> less than <tt>count</tt> the following 
corresponding conditions hold: <tt>*(i + n) == value, pred(*(i + n),value) != false</tt>. Returns <tt>last</tt> 
if no such iterator is found.
</p></blockquote></blockquote>
</li>

<li>
<p>Change 25.3.10 [alg.reverse] p4 as indicated:</p>

<blockquote><pre>
template&lt;class BidirectionalIterator, class OutputIterator&gt;
OutputIterator
reverse_copy(BidirectionalIterator first,
             BidirectionalIterator last, OutputIterator result);
</pre><blockquote><p>
[&hellip;]
<p/>
-4- <i>Effects</i>: Copies the range <tt>[first,last)</tt> to the range <tt>[result,result+(last-first))</tt> 
such that for <del>any</del><ins>every</ins> non-negative integer <tt>i &lt; (last - first)</tt> the following 
assignment takes place: <tt>*(result + (last - first) - i) = *(first + i)</tt>.
</p></blockquote></blockquote>
</li>

<li>
<p>Change 25.3.13 [alg.partitions] p5 and p9 as indicated:</p>

<blockquote><pre>
template&lt;class ForwardIterator, class Predicate&gt;
ForwardIterator
partition(ForwardIterator first,
          ForwardIterator last, Predicate pred);
</pre><blockquote><p>
[&hellip;]
<p/>
-5- <i>Returns</i>: An iterator <tt>i</tt> such that for <del>any</del><ins>every</ins> iterator <tt>j</tt> 
in the range <tt>[first,i) pred(*j) != false</tt>, and for <del>any</del><ins>every</ins> iterator <tt>k</tt> 
in the range <tt>[i,last), pred(*k) == false</tt>.
</p></blockquote></blockquote>
<p>
[&hellip;]
</p>
<blockquote><pre>
template&lt;class BidirectionalIterator, class Predicate&gt;
BidirectionalIterator
stable_partition(BidirectionalIterator first,
                 BidirectionalIterator last, Predicate pred);
</pre><blockquote><p>
[&hellip;]
<p/>
-9- <i>Returns</i>: An iterator <tt>i</tt> such that for <del>any</del><ins>every</ins> iterator <tt>j</tt> 
in the range <tt>[first,i), pred(*j) != false</tt>, and for <del>any</del><ins>every</ins> iterator <tt>k</tt> 
in the range <tt>[i,last), pred(*k) == false</tt>. The relative order of the elements in both groups is preserved.
</p></blockquote></blockquote>
</li>

<li>
<p>Change 25.4 [alg.sorting] p5 as indicated:</p>

<blockquote><p>
-5- A sequence is sorted with respect to a comparator <tt>comp</tt> if for <del>any</del><ins>every</ins> iterator 
<tt>i</tt> pointing to the sequence and <del>any</del><ins>every</ins> non-negative integer <tt>n</tt> such that 
<tt>i + n</tt> is a valid iterator pointing to an element of the sequence, <tt>comp(*(i + n), *i) == false</tt>.
</p></blockquote>
</li>

<li>
<p>Change 25.4.2 [alg.nth.element] p1 as indicated:</p>

<blockquote><pre>
template&lt;class RandomAccessIterator&gt;
void nth_element(RandomAccessIterator first, RandomAccessIterator nth,
                 RandomAccessIterator last);
template&lt;class RandomAccessIterator, class Compare&gt;
void nth_element(RandomAccessIterator first, RandomAccessIterator nth,
                 RandomAccessIterator last, Compare comp);
</pre><blockquote><p>
-1- After <tt>nth_element</tt> the element in the position pointed to by <tt>nth</tt> is the element that would 
be in that position if the whole range were sorted. Also for <del>any</del><ins>every</ins> iterator <tt>i</tt> 
in the range <tt>[first,nth)</tt> and <del>any</del><ins>every</ins> iterator <tt>j</tt> in the range 
<tt>[nth,last)</tt> it holds that: <tt>!(*i &gt; *j)</tt> or <tt>comp(*j, *i) == false</tt>. 
</p></blockquote></blockquote>
</li>

<li>
<p>Change 25.4.3.1 [lower.bound] p2 as indicated:</p>

<blockquote><pre>
template&lt;lass ForwardIterator, class T&gt;
ForwardIterator
lower_bound(ForwardIterator first, ForwardIterator last,
            const T&amp; value);
template&lt;class ForwardIterator, class T, class Compare&gt;
ForwardIterator
lower_bound(ForwardIterator first, ForwardIterator last,
            const T&amp; value, Compare comp);
</pre><blockquote><p>
[&hellip;]
<p/>
-2- <i>Returns</i>: The furthermost iterator <tt>i</tt> in the range <tt>[first,last]</tt> such that for 
<del>any</del><ins>every</ins> iterator <tt>j</tt> in the range <tt>[first,i)</tt> the following corresponding 
conditions hold: <tt>*j &lt; value</tt> or <tt>comp(*j, value) != false</tt>.
</p></blockquote></blockquote>
</li>

<li>
<p>Change 25.4.3.2 [upper.bound] p2 as indicated:</p>

<blockquote><pre>
template&lt;lass ForwardIterator, class T&gt;
ForwardIterator
upper_bound(ForwardIterator first, ForwardIterator last,
            const T&amp; value);
template&lt;class ForwardIterator, class T, class Compare&gt;
ForwardIterator
upper_bound(ForwardIterator first, ForwardIterator last,
            const T&amp; value, Compare comp);
</pre><blockquote><p>
[&hellip;]
<p/>
-2- <i>Returns</i>: The furthermost iterator <tt>i</tt> in the range <tt>[first,last]</tt> such that for 
<del>any</del><ins>every</ins> iterator <tt>j</tt> in the range <tt>[first,i)</tt> the following corresponding 
conditions hold: <tt>!(value &lt; *j)</tt> or <tt>comp(value, *j) == false</tt>.
</p></blockquote></blockquote>
</li>

<li>
<p>Change 25.4.7 [alg.min.max] p21 and p23 as indicated:</p>

<blockquote><pre>
template&lt;class ForwardIterator&gt;
ForwardIterator min_element(ForwardIterator first, ForwardIterator last);
template&lt;class ForwardIterator, class Compare&gt;
ForwardIterator min_element(ForwardIterator first, ForwardIterator last,
                            Compare comp);
</pre><blockquote><p>
-21- <i>Returns</i>: The first iterator <tt>i</tt> in the range <tt>[first,last)</tt> such that for 
<del>any</del><ins>every</ins> iterator <tt>j</tt> in the range <tt>[first,last)</tt> the following 
corresponding conditions hold: <tt>!(*j &lt; *i)</tt> or <tt>comp(*j, *i) == false</tt>. Returns 
<tt>last</tt> if <tt>first == last</tt>.
</p></blockquote></blockquote>
<p>
[&hellip;]
</p>
<blockquote><pre>
template&lt;class ForwardIterator&gt;
ForwardIterator max_element(ForwardIterator first, ForwardIterator last);
template&lt;class ForwardIterator, class Compare&gt;
ForwardIterator max_element(ForwardIterator first, ForwardIterator last,
                            Compare comp);
</pre><blockquote><p>
-23- <i>Returns</i>: The first iterator <tt>i</tt> in the range <tt>[first,last)</tt> such that for 
<del>any</del><ins>every</ins> iterator <tt>j</tt> in the range <tt>[first,last)</tt> the following 
corresponding conditions hold: <tt>!(*i &lt; *j)</tt> or <tt>comp(*i, *j) == false</tt>. Returns 
<tt>last</tt> if <tt>first == last</tt>.
</p></blockquote></blockquote>
</li>

</ol>






<hr>
<h3><a name="2167"></a>2167. Copy assignment requirements of Containers</h3>
<p><b>Section:</b> 23.2.1 [container.requirements.general] <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Dean Michael Berris <b>Opened:</b> 2012-07-13 <b>Last modified:</b> 2012-10-20</p>
<p><b>View other</b> <a href="lwg-index-open.html#container.requirements.general">active issues</a> in [container.requirements.general].</p>
<p><b>View all other</b> <a href="lwg-index.html#container.requirements.general">issues</a> in [container.requirements.general].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>
Table 96 defines the general requirement for copy assignment (row 23, page 704) as:
</p>

<table border="1">
<caption>Table 96 &mdash; Container requirements</caption>

<tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Assertion&#47;note pre-&#47;post-condition</th>
<th>Complexity</th>
</tr> 

<tr>
<td>
<tt>r = a</tt>
</td>
<td>
<tt>X&amp;</tt>
</td>
<td>
<tt></tt>
</td>
<td>
post: <tt>r == a.</tt>
</td>
<td>
linear
</td>
</tr>

</table>

<p>
However there is no requirement that <tt>T</tt> is <tt>CopyInsertable</tt> into <tt>X</tt>.
</p>

<p><i>[2012, Portland: Move to Tentatively NAD]</i></p>

<p>
Howard notes that this may be a difficult requirement for <tt>std::array</tt>
</p>

<p>
We already have this requirement for allocator aware containers, and
<tt>std::array</tt> already adds the appropriate extra requirement.
</p>

<p>
We say the necessary things in the necessary places, but the container requirements
continue to cause confusion in where we sometimes say things.  Consensus is that
this issue remains NAD though.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3376.</p>

<ol>
<li><p>Change Table 96 &mdash; "Container requirements" in 23.2.1 [container.requirements.general]:</p>

<table border="1">
<caption>Table 96 &mdash; Container requirements</caption>

<tr>
<th>Expression</th>
<th>Return type</th>
<th>Operational semantics</th>
<th>Assertion&#47;note pre-&#47;post-condition</th>
<th>Complexity</th>
</tr> 

<tr>
<td>
<tt>r = a</tt>
</td>
<td>
<tt>X&amp;</tt>
</td>
<td>
<tt></tt>
</td>
<td>
<ins><i>Requires</i>: <tt>T</tt> is <tt>CopyInsertable</tt> into <tt>X</tt>.</ins><br/>
post: <tt>r == a.</tt>
</td>
<td>
linear
</td>
</tr>

</table>

</li>
</ol>







<hr>
<h3><a name="2180"></a>2180. Exceptions from <tt>std::seed_seq</tt> operations</h3>
<p><b>Section:</b> 26.5.7.1 [rand.util.seedseq] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2012-08-18 <b>Last modified:</b> 2013-05-20</p>
<p><b>View all other</b> <a href="lwg-index.html#rand.util.seedseq">issues</a> in [rand.util.seedseq].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p>
26.5.7.1 [rand.util.seedseq] p1 says upfront:
</p>
<blockquote><p>
No function described in this section 26.5.7.1 [rand.util.seedseq] throws an exception.
</p></blockquote>
<p>
This constraint seems non-implementable to me when looking especially at the members
</p>
<blockquote><pre>
template&lt;class T&gt;
seed_seq(initializer_list&lt;T&gt; il);

template&lt;class InputIterator&gt;
seed_seq(InputIterator begin, InputIterator end);
</pre></blockquote>
<p>
which have the effect of invoking <tt>v.push_back()</tt> for the exposition-only member of
type <tt>std::vector</tt> (or its equivalent) over all elements of the provided range, so
out-of-memory exceptions are always possible and the <tt>seed_seq</tt> object doesn't seem
to be constructible this way.
<p/>
In addition to the potential lack-of-resources problem, the operations of <tt>InputIterator</tt>
might also throw exceptions.
<p/>
Aside to that it should me mentioned, that a default constructor of <tt>vector&lt;uint_least32_t&gt;</tt> 
in theory can also throw exceptions, even though this seems less of a problem to me in this context, because 
such an implementation could easily use a different internal container in <tt>seed_seq</tt> that can hold 
this no-throw exception guarantee.
<p/>
Secondly, a slightly different problem category related to exceptions occurs for the member templates
</p>
<blockquote><pre>
template&lt;class RandomAccessIterator&gt;
void generate(RandomAccessIterator begin, RandomAccessIterator end);

template&lt;class OutputIterator&gt;
void param(OutputIterator dest) const;
</pre></blockquote>
<p>
where the actual operations performed by the implementation would never need to throw, but since they invoke
operations of a user-provided customization point, the overall operation, like for example
</p>
<blockquote><pre>
copy(v.begin(), v.end(), dest);
</pre></blockquote>
<p>
could also throw exceptions. In this particular example we can just think of a <tt>std::back_insert_iterator</tt>
applied to a container that needs to allocate its elements used as the type for <tt>OutputIterator</tt>.
<p/>
Even though Clause 26 [numerics] has mostly stronger exception constraints than other parts of the
library the here discussed are overrestrictive, especially since no operation of <tt>std::seed_seq</tt> 
except the template <tt>generate</tt> is actually needed within the library implementation, as mentioned in the 
discussion of LWG <a href="lwg-closed.html#2124">2124</a>.
<p/>
I suggest to remove the general no-exception constraints for operations of <tt>std::seed_seq</tt> except for
member <tt>size()</tt> and the default constructor and to provide specific wording for <tt>generate()</tt> and
<tt>param()</tt> to ensure that the algorithm itself is a nothrow operation, which is especially for
<tt>generate()</tt> important, because the templates specified in 26.5.3 [rand.eng] and 
26.5.4 [rand.adapt] also depend on this property indirectly, which is further discussed in LWG 
<a href="lwg-active.html#2181">2181</a>.
<p/>
<u>Howard</u>:
<p/>
I suggest to use a different form for the exception specification, something similar to 
20.10.9.1.3 [func.bind.bind] p4:
</p>
<blockquote><p>
<i>Throws</i>: Nothing unless an operation on <tt>RandomAccessIterator</tt> throws an exception.
</p></blockquote>
<p>
<u>Daniel</u>:
<p/>
The currently suggested "what and when" form seems a bit more specific and harmonizes with the form used for
function template <tt>generate_canonical</tt> from 26.5.7.2 [rand.util.canonical].
</p>

<p><i>[2013-04-20, Bristol]</i></p>


<p>
Open an editorial issue on the exception wording ("Throws: What and when"). 
<p/>
Solution: move to tentatively ready. 
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3376.</p>

<ol>
<li><p>Edit 26.5.7.1 [rand.util.seedseq] p1 as indicated:</p>

<blockquote>
<p>
<del>-1- No function described in this section 26.5.7.1 [rand.util.seedseq] throws an exception.</del>
</p>
</blockquote>
</li>

<li><p>Edit 26.5.7.1 [rand.util.seedseq] around p2 as indicated:</p>

<blockquote><pre>
seed_seq();
</pre><blockquote>
<p>
-2- <i>Effects</i>: Constructs a <tt>seed_seq</tt> object as if by default-constructing its member <tt>v</tt>.
<p/>
<ins>-?- <i>Throws</i>: Nothing.</ins>
</p>
</blockquote></blockquote>
</li>

<li><p>Edit 26.5.7.1 [rand.util.seedseq] around p7 as indicated:</p>

<blockquote><pre>
template&lt;class RandomAccessIterator&gt;
  void generate(RandomAccessIterator begin, RandomAccessIterator end);
</pre><blockquote>
<p>
-7- <i>Requires</i>: <tt>RandomAccessIterator</tt> shall meet the requirements of a mutable random access iterator
(Table 111) type. Moreover, <tt>iterator_traits&lt;class RandomAccessIterator&gt;::value_type</tt> shall denote
an unsigned integer type capable of accommodating 32-bit quantities.
<p/>
-8- <i>Effects</i>: Does nothing if <tt>begin == end</tt>. Otherwise, with <tt>s = v.size()</tt> and 
<tt>n = end - begin</tt>, fills the supplied range <tt>[begin, end)</tt> according to the following algorithm [&hellip;]
<p/>
<ins>-?- <i>Throws</i>: What and when <tt>RandomAccessIterator</tt> operations of <tt>begin</tt> and <tt>end</tt> throw.</ins>
</p>
</blockquote></blockquote>
</li>

<li><p>Edit 26.5.7.1 [rand.util.seedseq] around p9 as indicated:</p>

<blockquote><pre>
size_t size() const;
</pre><blockquote>
<p>
-9- <i>Returns</i>: The number of 32-bit units that would be returned by a call to <tt>param()</tt>.
<p/>
<ins>-??- <i>Throws</i>: Nothing.</ins>
<p/>
-10- <i>Complexity</i>: constant time.
</p>
</blockquote></blockquote>
</li>

<li><p>Edit 26.5.7.1 [rand.util.seedseq] around p11 as indicated:</p>

<blockquote><pre>
template&lt;class OutputIterator&gt;
  void param(OutputIterator dest) const;
</pre><blockquote>
<p>
-11- <i>Requires</i>: <tt>OutputIterator</tt> shall satisfy the requirements of an output iterator (Table 108) type. 
Moreover, the expression <tt>*dest = rt</tt> shall be valid for a value <tt>rt</tt> of type <tt>result_type</tt>.
<p/>
-12- <i>Effects</i>: Copies the sequence of prepared 32-bit units to the given destination, as if by executing the
following statement:
</p>
<blockquote><pre>
copy(v.begin(), v.end(), dest);
</pre></blockquote>
<p>
<ins>-??- <i>Throws</i>: What and when <tt>OutputIterator</tt> operations of <tt>dest</tt> throw.</ins>
</p>
</blockquote></blockquote>
</li>

</ol>






<hr>
<h3><a name="2194"></a>2194. Impossible container requirements for adaptor types</h3>
<p><b>Section:</b> 23.6 [container.adaptors] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Sebastian Mach <b>Opened:</b> 2012-10-05 <b>Last modified:</b> 2013-05-20</p>
<p><b>View all other</b> <a href="lwg-index.html#container.adaptors">issues</a> in [container.adaptors].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>

<p>
The <tt>stack</tt> class template does not have an member type <tt>iterator</tt>, and therefore instantiations do not 
meet the general container requirements as described in 23.2.1 [container.requirements.general]. But 
23.6.1 [container.adaptors.general] p1 says:
</p>
<blockquote><p>
The headers <tt>&lt;queue&gt;</tt> and <tt>&lt;stack&gt;</tt> define the container adaptors <tt>queue</tt>, 
<tt>priority_queue</tt>, and <tt>stack</tt>. These container adaptors meet the requirements for sequence containers.
</p></blockquote>
<p>
Since sequence containers is a subset of general containers, this imposes requirements on the container adaptors that
are not satisfied.
</p>
<p>
<u>Daniel Kr&uuml;gler</u>: The wording change was performed as an editorial reorganization as requested
by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3296.html#GB116">GB 116</a> occuring first in
<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf">N3242</a>, as a side-effect it 
does now make the previous implicit C++03 classification to [lib.sequences]/1 more obvious. As the NB comment
noticed, the adaptors really are not sequences nor containers, so this wording needs to be fixed.
The most simple way to realize that is to strike the offending sentence.
</p>

<p><i>[
Daniel adds concrete wording.
]</i></p>


<p><i>[2013-04-20, Bristol]</i></p>


<p>
Unanimous consensus that <tt>queue</tt> and <tt>stack</tt> are not meant to be sequences.
<p/>
Decision: move to tentatively ready 
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to N3376.</p>

<ol>
<li><p>Change 23.6.1 [container.adaptors.general] p1 as indicated:</p>
<blockquote><p>
-1- The headers <tt>&lt;queue&gt;</tt> and <tt>&lt;stack&gt;</tt> define the container adaptors <tt>queue</tt>, 
<tt>priority_queue</tt>, and <tt>stack</tt>. <del>These container adaptors meet the requirements for sequence containers.</del>
</p></blockquote>
</li>
</ol>






<hr>
<h3><a name="2204"></a>2204. <tt>reverse_iterator</tt> should not require a second copy of the base iterator</h3>
<p><b>Section:</b> 24.5.1.3.4 [reverse.iter.op.star] <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> David Abrahams <b>Opened:</b> 2012-10-30 <b>Last modified:</b> 2013-05-20</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively NAD">Tentatively NAD</a> status.</p>
<p><b>Discussion:</b></p>

<p>
This note in 24.5.1.3.4 [reverse.iter.op.star]/2:
</p>
<blockquote>
 [ <i>Note</i>: This operation must use an auxiliary member variable rather than a
 temporary variable to avoid returning a reference that persists beyond the
 lifetime of its associated iterator. (See 24.2.) &mdash;<i>end note</i> ]
</blockquote>
<p>
is incorrect because such iterator implementations are ruled out by
24.2.5 [forward.iterators]/6, where it says:
</p>
<blockquote>
 If <tt>a</tt> and <tt>b</tt> are both dereferenceable, then <tt>a == b</tt> if and only if <tt>*a</tt> and
 <tt>*b</tt> are bound to the same object.
</blockquote>

<p><i>[[2013-04-20, Bristol]]</i></p>


<p>
Alisdair: sugested to strike the "exposition only" member.
<p/>
Daniel: we must check that it wouldn't conflict with a previous solution to another issue.
<p/>
Dietmar: This is an issue but the proposing word is not correct. When we have proxies inside the sequence.
<p/>
Solution: NAD thanks to a contrieved example by Dietmar. 
</p>


<p><b>Proposed resolution:</b></p>
<p>
Strike the note, 24.5.1.3.4 [reverse.iter.op.star]/2:
</p>

<blockquote>
 <del>[ <i>Note</i>: This operation must use an auxiliary member variable rather than a
 temporary variable to avoid returning a reference that persists beyond the
 lifetime of its associated iterator. (See 24.2.) &mdash;<i>end note</i> ]</del>
</blockquote>






</body>
</html>
