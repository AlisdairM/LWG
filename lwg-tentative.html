<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
    "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>C++ Standard Library Tentative Issues</title>
<style type="text/css">
  p {text-align:justify}
  li {text-align:justify}
  blockquote.note
  {
    background-color:#E0E0E0;
    padding-left: 15px;
    padding-right: 15px;
    padding-top: 1px;
    padding-bottom: 1px;
  }
  ins {background-color:#A0FFA0}
  del {background-color:#FFA0A0}
</style>
</head>
<body>
<p>Revised 2012-08-05 at 20:08:42 UTC</p>
<h2>Tentative Issues</h2>
<hr>
<h3><a name="2005"></a>2005. <tt>unordered_map::insert(T&amp;&amp;)</tt> protection should apply to <tt>map</tt> too</h3>
<p><b>Section:</b> 23.4.4.4 [map.modifiers], 23.4.5.3 [multimap.modifiers], X [unord.map.modifiers], X [unord.multimap.modifiers] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> P.J. Plauger <b>Opened:</b> 2010-10-14 <b>Last modified:</b> 2012-03-10</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In [unord.map.modifiers], the signature:
</p>
<blockquote><pre>
template &lt;class P&gt;
    pair&lt;iterator, bool&gt; insert(P&amp;&amp; obj);
</pre></blockquote>
<p>
now has an added Remarks paragraph:
</p>
<blockquote><p>
<i>Remarks</i>: This signature shall not participate in overload resolution unless <tt>P</tt>
is implicitly convertible to <tt>value_type</tt>.
</p></blockquote>
<p>
The same is true for <tt>unordered_multimap</tt>.
<p/>
But neither <tt>map</tt> nor <tt>multimap</tt> have this constraint, even though it is a
Good Thing(TM) in those cases as well.
</p>

<p><i>[
The submitter suggests: Add the same Remarks clause to [map.modifiers] and [multimap.modifiers].
]</i></p>


<p><i>[
2010-10-29 Daniel comments:
]</i></p>


<p>
I believe both paragraphs need more cleanup: First, the current Requires element conflict with the Remark; 
second, it seems to me that the whole single Requires element is intended to be split into a Requires
and an Effects element; third, the reference to <tt>tuple</tt> is incorrect (noticed by Paolo Carlini);
fourth, it refers to some non-existing <tt>InputIterator</tt> parameter relevant for a completely different
overload; sixth, the return type of the overload with hint is wrong.
The following proposed resolution tries to solve these issues as well and uses similar wording as for
the corresponding unordered containers. Unfortunately it has some redundancy over Table&nbsp;99, but I did
not remove the specification because of the more general template parameter <tt>P</tt> - the Table&nbsp;99 
requirements apply only for an argument <em>identical</em> to <tt>value_type</tt>.
<p/>
Daniel's Proposed resolution (not current):
</p>

<blockquote class="note">
<ol>
<li>Change 23.4.4.4 [map.modifiers] around p. 1 as indicated:
<blockquote><pre>
template &lt;class P&gt; pair&lt;iterator, bool&gt; insert(P&amp;&amp; x);
template &lt;class P&gt; <del>pair&lt;</del>iterator<del>, bool&gt;</del> insert(const_iterator position, P&amp;&amp; x);
</pre><blockquote><p>
1 <em>Requires</em>: <del><tt>P</tt> shall be convertible to </del><tt>value_type</tt><ins> is constructible 
from <tt>std::forward&lt;P&gt;(x)</tt>.</ins>.
<p/>
<del>If <tt>P</tt> is instantiated as a reference type, then the argument <tt>x</tt> is copied from. Otherwise <tt>x</tt> is considered
to be an rvalue as it is converted to <tt>value_type</tt> and inserted into the map. Specifically, in
such cases <tt>CopyConstructible</tt> is not required of <tt>key_type</tt> or <tt>mapped_type</tt> unless the conversion
from <tt>P</tt> specifically requires it (e.g., if <tt>P</tt> is a <tt>tuple&lt;const key_type, mapped_type&gt;</tt>, then <tt>key_type</tt>
must be <tt>CopyConstructible</tt>). The signature taking <tt>InputIterator</tt> parameters does not require
<tt>CopyConstructible</tt> of either <tt>key_type</tt> or <tt>mapped_type</tt> if the dereferenced <tt>InputIterator</tt> returns a
non-const rvalue <tt>pair&lt;key_type,mapped_type&gt;</tt>. Otherwise <tt>CopyConstructible</tt> is required for both
<tt>key_type</tt> and <tt>mapped_type</tt>.</del><br/>
<ins>? <em>Effects</em>: Inserts <tt>x</tt> converted to <tt>value_type</tt> if and only if there is no element in the container with
key equivalent to the key of <tt>value_type(x)</tt>. For the second form, the iterator <tt>position</tt> is a hint pointing to where the
search should start.</ins>
<p/>
<ins>? <em>Returns</em>: For the first form, the <tt>bool</tt> component of the returned <tt>pair</tt> object indicates whether the 
insertion took place and the iterator component - or for the second form the returned iterator - points to the element with key equivalent 
to the key of <tt>value_type(x)</tt>.</ins>
<p/>
<ins>? <em>Complexity</em>: Logarithmic in general, but amortized constant if <tt>x</tt> is inserted right before <tt>position</tt>.</ins>
<p/>
<ins>? <em>Remarks</em>: These signatures shall not participate in overload resolution unless <tt>P</tt> 
is implicitly convertible to <tt>value_type</tt>.</ins>
</p>
</blockquote></blockquote>
</li>
<li>Change 23.4.5.3 [multimap.modifiers] around p. 1 as indicated:
<blockquote><pre>
template &lt;class P&gt; iterator insert(P&amp;&amp; x);
template &lt;class P&gt; iterator insert(const_iterator position, P&amp;&amp; x);
</pre><blockquote><p>
1 <em>Requires</em>: <del><tt>P</tt> shall be convertible to </del><tt>value_type</tt> <ins>is constructible from 
<tt>std::forward&lt;P&gt;(x)</tt></ins>.
<p/>
<del>If <tt>P</tt> is instantiated as a reference type, then the argument <tt>x</tt> is copied from. Otherwise 
<tt>x</tt> is considered to be an rvalue as it is converted to <tt>value_type</tt> and inserted into the map. 
Specifically, in such cases <tt>CopyConstructible</tt> is not required of <tt>key_type</tt> or <tt>mapped_type</tt> 
unless the conversion from <tt>P</tt> specifically requires it (e.g., if <tt>P</tt> is a <tt>tuple&lt;const key_type, mapped_type&gt;</tt>, 
then <tt>key_type</tt> must be <tt>CopyConstructible</tt>). The signature taking <tt>InputIterator</tt> parameters 
does not require <tt>CopyConstructible</tt> of either <tt>key_type</tt> or <tt>mapped_type</tt> if the dereferenced 
<tt>InputIterator</tt> returns a non-const rvalue <tt>pair&lt;key_type, mapped_type&gt;</tt>. Otherwise <tt>CopyConstructible</tt> 
is required for both <tt>key_type</tt> and <tt>mapped_type</tt>.</del><br/>
<ins>? <em>Effects</em>: Inserts <tt>x</tt> converted to <tt>value_type</tt>. For the second form, the iterator <tt>position</tt> 
is a hint pointing to where the search should start.</ins>
<p/>
<ins>? <em>Returns</em>: An iterator that points to the element with key equivalent to the key of <tt>value_type(x)</tt>.</ins>
<p/>
<ins>? <em>Complexity</em>: Logarithmic in general, but amortized constant if <tt>x</tt> is inserted right before <tt>position</tt>.</ins>
<p/>
<ins>? <em>Remarks</em>: These signatures shall not participate in overload resolution unless <tt>P</tt> 
is implicitly convertible to <tt>value_type</tt>.</ins>
</p>
</blockquote></blockquote>
</li>
</ol>

</blockquote>

<p><i>[
2010 Batavia:
]</i></p>


<p>
We need <tt>is_convertible</tt>, not <tt>is_constructible</tt>, both in ordered and unordered containers. 
</p>

<p><i>[
2011 Bloomington
]</i></p>


<p>
The effects of these inserts can be concisely stated in terms of emplace().
Also, the correct term is "EmplaceConstructible", not "constructible".
</p>

<p>
New wording by Pablo, eliminating duplicate requirements already implied by the effects clause.  Move to Review.
</p>

<p><i>[
2011-10-02 Daniel comments and refines the proposed wording
]</i></p>


<blockquote><p>
Unfortunately the template constraints expressed as "<tt>P</tt> is implicitly convertible to <tt>value_type</tt>"
reject the intended effect to support move-only key types, which was the original intention when
the library became move-enabled through the rvalue-reference proposals by Howard (This can clearly be deduced
from existing carefully selected wording that emphasizes that <tt>CopyConstructible</tt> is only required
for special situations involving lvalues or const rvalues as arguments). The root of the problem is based
on current core rules, where an "implicitly converted" value has copy-initialization semantics. Consider
a move-only key type <tt>KM</tt>, some mapped type <tt>T</tt>, and a source value <tt>p</tt> of type <tt>P</tt> 
equal to <tt>std::pair&lt;KM, T&gt;</tt>, this is equivalent to:
</p>
<blockquote><pre>
std::pair&lt;const KM, T&gt; dest = std::move(p);
</pre></blockquote>
<p>
Now 8.5 [dcl.init] p16 b6 sb2 says that the effects of this heterogeneous copy-initialization (<tt>p</tt>
has a different type than <tt>dest</tt>) are as-if a temporary of the target type <tt>std::pair&lt;const KM, T&gt;</tt>
is produced from the rvalue <tt>p</tt> of type <tt>P</tt> (which is fine), and this temporary is used to initialize 
<tt>dest</tt>. This second step cannot succeed, because we cannot move from <tt>const KM</tt> to <tt>const KM</tt>. This 
means that <tt>std::is_convertible&lt;P, std::pair&lt;const KM, T&gt;&gt;::value</tt> is false.
<p/>
But the actual code that is required (with the default allocator) is simply a direct-initialization
from <tt>P</tt> to <tt>value_type</tt>, so imposing an implicit conversion is more than necessary. Therefore
I strongly recommend to reduce the "overload participation" constraint to  
<tt>std::is_constructible&lt;std::pair&lt;const KM, T&gt;, P&gt;::value</tt> instead. This change is the
only change that has been performed to the previous proposed wording from Pablo shown below. 
</p></blockquote>

<p><i>[2012, Kona]</i></p>

<p>
Moved to Tentatively Ready by the post-Kona issues processing subgroup, after much discussion
on Daniel's analysis of Copy Initialization and move semantics, which we ultimately agreed with.
</p>



<p><b>Proposed resolution:</b></p>

<ol>
<li>Change 23.4.4.4 [map.modifiers] around p. 1 as indicated:
<blockquote><pre>
template &lt;class P&gt; pair&lt;iterator, bool&gt; insert(P&amp;&amp; x);
template &lt;class P&gt; <del>pair&lt;</del>iterator<del>, bool&gt;</del> insert(const_iterator position, P&amp;&amp; x);
</pre><blockquote>
<del>1 <em>Requires</em>: <tt>P</tt> shall be convertible to <tt>value_type</tt>.</del>
<p/>
<del>If <tt>P</tt> is instantiated as a reference type, then the argument <tt>x</tt> is copied from. Otherwise <tt>x</tt> is considered
to be an rvalue as it is converted to <tt>value_type</tt> and inserted into the map. Specifically, in
such cases <tt>CopyConstructible</tt> is not required of <tt>key_type</tt> or <tt>mapped_type</tt> unless the conversion
from <tt>P</tt> specifically requires it (e.g., if <tt>P</tt> is a <tt>tuple&lt;const key_type, mapped_type&gt;</tt>, then <tt>key_type</tt>
must be <tt>CopyConstructible</tt>). The signature taking <tt>InputIterator</tt> parameters does not require
<tt>CopyConstructible</tt> of either <tt>key_type</tt> or <tt>mapped_type</tt> if the dereferenced <tt>InputIterator</tt> returns a
non-const rvalue <tt>pair&lt;key_type,mapped_type&gt;</tt>. Otherwise <tt>CopyConstructible</tt> is required for both
<tt>key_type</tt> and <tt>mapped_type</tt>.</del><br/>
<ins>? <em>Effects</em>: The first form is equivalent to
<tt>return emplace(std::forward&lt;P&gt;(x))</tt>.
The second form is equivalent to
<tt>return emplace_hint(position, std::forward&lt;P&gt;(x))</tt>.</ins>
<p/>
<ins>? <em>Remarks</em>: These signatures shall not participate in overload resolution unless 
<tt>std::is_constructible&lt;value_type, P&amp;&amp;&gt;::value</tt> is true.</ins>
<p/>
</blockquote></blockquote>
</li>
<li>Change 23.4.5.3 [multimap.modifiers] around p. 1 as indicated:
<blockquote><pre>
template &lt;class P&gt; iterator insert(P&amp;&amp; x);
template &lt;class P&gt; iterator insert(const_iterator position, P&amp;&amp; x);
</pre><blockquote>
<del>1 <em>Requires</em>: <tt>P</tt> shall be convertible to <tt>value_type</tt>.</del>
<p/>
<del>If <tt>P</tt> is instantiated as a reference type, then the argument <tt>x</tt> is copied from. Otherwise 
<tt>x</tt> is considered to be an rvalue as it is converted to <tt>value_type</tt> and inserted into the map. 
Specifically, in such cases <tt>CopyConstructible</tt> is not required of <tt>key_type</tt> or <tt>mapped_type</tt> 
unless the conversion from <tt>P</tt> specifically requires it (e.g., if <tt>P</tt> is a <tt>tuple&lt;const key_type, mapped_type&gt;</tt>, 
then <tt>key_type</tt> must be <tt>CopyConstructible</tt>). The signature taking <tt>InputIterator</tt> parameters 
does not require <tt>CopyConstructible</tt> of either <tt>key_type</tt> or <tt>mapped_type</tt> if the dereferenced 
<tt>InputIterator</tt> returns a non-const rvalue <tt>pair&lt;key_type, mapped_type&gt;</tt>. Otherwise <tt>CopyConstructible</tt> 
is required for both <tt>key_type</tt> and <tt>mapped_type</tt>.</del><br/>
<ins>? <em>Effects</em>: The first form is equivalent to
<tt>return emplace(std::forward&lt;P&gt;(x))</tt>.
The second form is equivalent to
<tt>return emplace_hint(position, std::forward&lt;P&gt;(x))</tt>.</ins>
<p/>
<ins>? <em>Remarks</em>: These signatures shall not participate in overload resolution unless 
<tt>std::is_constructible&lt;value_type, P&amp;&amp;&gt;::value</tt> is true.</ins>
<p/>
</blockquote></blockquote>
</li>
<li>Change 23.5.4.4 [unord.map.modifers] around p. 1 as indicated:
<blockquote><pre>
template &lt;class P&gt;
pair&lt;iterator, bool&gt; insert(P&amp;&amp; obj);
</pre>
<blockquote>
<del>1 <em>Requires</em>: <tt>value_type</tt> is constructible from <tt>std::forward&lt;P&gt;(obj)</tt>.</del>
<p/>
2 <em>Effects</em>:
<ins>equivalent to <tt>return emplace(std::forward&lt;P&gt;(obj))</tt>.</ins>
<del>Inserts obj converted to <tt>value_type</tt> if and only if there is no element in the container with
key equivalent to the key of <tt>value_type(obj)</tt>.</del>
<p/>
<del>3 <em>Returns</em>: The bool component of the returned pair object indicates whether the insertion took place
and the iterator component points to the element with key equivalent to the key of <tt>value_type(obj)</tt>.</del>
<p/>
<del>4 <em>Complexity</em>: Average case O(1), worst case O(size()).</del>
<p/>
<del>5</del><ins>3</ins> <em>Remarks</em>: This signature shall not participate in overload resolution unless 
<del><tt>P</tt> is implicitly convertible to <tt>value_type</tt></del><ins><tt>std::is_constructible&lt;value_type, 
P&amp;&amp;&gt;::value</tt> is true</ins>.
<p/>
</blockquote>
<pre>template &lt;class P&gt;
iterator insert(const_iterator hint, P&amp;&amp; obj);
</pre>
<blockquote>
<del>6 <em>Requires</em>: <tt>value_type</tt> is constructible from <tt>std::forward&lt;P&gt;(obj)</tt>.</del>
<p/>
<del>7</del><em>?</em> <em>Effects</em>:
<ins>equivalent to <tt>return emplace_hint(hint, std::forward&lt;P&gt;(obj))</tt>.</ins>
<del>Inserts obj converted to <tt>value_type</tt> if and only if there is no element in the container with
key equivalent to the key of <tt>value_type(obj)</tt>. The iterator hint is a hint pointing to where the
search should start.</del>
<p/>
<del>8 <em>Returns</em>: An iterator that points to the element with key equivalent to the key of 
<tt>value_type(obj)</tt>.</del>
<p/>
<del>9 <em>Complexity</em>: Average case O(1), worst case O(size()).</del>
<p/>
<del>10</del><em>?</em> <em>Remarks</em>: This signature shall not participate in overload resolution unless 
<del><tt>P</tt> is implicitly convertible to <tt>value_type</tt></del><ins><tt>std::is_constructible&lt;value_type, 
P&amp;&amp;&gt;::value</tt> is true</ins>.
</blockquote></blockquote>
</li>
<li>Change 23.5.5.3 [unord.multimap.modifers] around p. 1 as indicated:
<blockquote><pre>
template &lt;class P&gt;
iterator insert(P&amp;&amp; obj);
</pre>
<blockquote>
<del>1 <em>Requires</em>: <tt>value_type</tt> is constructible from <tt>std::forward&lt;P&gt;(obj)</tt>.</del>
<p/>
2 <em>Effects</em>:
<ins>equivalent to <tt>return emplace(std::forward&lt;P&gt;(obj))</tt>.</ins>
<del>Inserts obj converted to <tt>value_type</tt>.</del>
<p/>
<del>3 <em>Returns</em>: An iterator that points to the element with key equivalent to the key of <tt>value_type(obj)</tt>.</del>
<p/>
<del>4 <em>Complexity</em>: Average case O(1), worst case O(size()).</del>
<p/>
<del>5</del><ins>3</ins> <em>Remarks</em>: This signature shall not participate in overload resolution 
unless <del><tt>P</tt> is implicitly convertible to <tt>value_type</tt></del><ins><tt>std::is_constructible&lt;value_type, 
P&amp;&amp;&gt;::value</tt> is true</ins>.
</blockquote>
<pre>
template &lt;class P&gt;
iterator insert(const_iterator hint, P&amp;&amp; obj);
</pre>
<blockquote>
<del>6 <em>Requires</em>: <tt>value_type</tt> is constructible from <tt>std::forward&lt;P&gt;(obj)</tt>.</del>
<p/>
<del>7</del><em>?</em> <em>Effects</em>:
<ins>equivalent to <tt>return emplace_hint(hint, std::forward&lt;P&gt;(obj))</tt>.</ins>
<del>Inserts obj converted to <tt>value_type</tt>. The iterator hint is a hint pointing to where the search
should start.</del>
<p/>
<del>8 <em>Returns</em>: An iterator that points to the element with key equivalent to the key of <tt>value_type</tt>(obj).</del>
<p/>
<del>9 <em>Complexity</em>: Average case O(1), worst case O(size()).</del>
<p/>
<del>10</del><ins><em>?</em></ins> <em>Remarks</em>: This signature shall not participate in overload resolution 
unless <del><tt>P</tt> is implicitly convertible to <tt>value_type</tt></del><ins><tt>std::is_constructible&lt;value_type, 
P&amp;&amp;&gt;::value</tt> is true</ins>.
</blockquote></blockquote>
</li>
</ol>






<hr>
<h3><a name="2011"></a>2011. Unexpected output required of strings</h3>
<p><b>Section:</b> 21.4.8.9 [string.io] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> James Kanze <b>Opened:</b> 2010-07-23 <b>Last modified:</b> 2012-03-10</p>
<p><b>View all other</b> <a href="lwg-index.html#string.io">issues</a> in [string.io].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
What should the following code output? 
</p>

<blockquote><pre>
#include &lt;string&gt;
#include &lt;iostream&gt;
#include &lt;iomanip&gt;

int main() 
{ 
   std::string test("0X1Y2Z"); 
   std::cout.fill('*'); 
   std::cout.setf(std::ios::internal, std::ios::adjustfield); 
   std::cout &lt;&lt; std::setw(8) &lt;&lt; test &lt;&lt; std::endl; 
} 
</pre></blockquote>

<p>
I would expect "<tt>**0X1Y2Z</tt>", and this is what the compilers I have access
to (VC++, g++ and Sun CC) do.  But according to the standard, it should be
"<tt>0X**1Y2Z</tt>":
</p>

<p>
21.4.8.9 [string.io]&#47;5: 
</p>

<blockquote><pre>
template&lt;class charT, class traits, class Allocator&gt;
  basic_ostream&lt;charT, traits&gt;&amp;
    operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os, const basic_string&lt;charT,traits,Allocator&gt;&amp; str);
</pre><blockquote><p>
<i>Effects:</i> Behaves as a formatted output function (27.7.3.6.1 [ostream.formatted.reqmts]). After constructing 
a <tt>sentry</tt> object, if this object returns <tt>true</tt> when converted to a value of type <tt>bool</tt>, 
determines padding as described in 22.4.2.2.2 [facet.num.put.virtuals], then inserts the resulting sequence of
characters seq as if by calling <tt>os.rdbuf()-&gt;sputn(seq, n)</tt>, where <tt>n</tt> is the larger of 
<tt>os.width()</tt> and <tt>str.size()</tt>; then calls <tt>os.width(0)</tt>.
</p></blockquote>
</blockquote>

<p>
22.4.2.2.2 [facet.num.put.virtuals]&#47;5: 
</p>

<blockquote>
<p>
[&hellip;] 
</p>

<p>
<b>Stage 3:</b> A local variable is initialized as
</p>

<blockquote><pre>
fmtflags adjustfield= (flags &amp; (ios_base::adjustfield));
</pre></blockquote>

<p>
The location of any padding is determined according to Table 88. 
</p>

<p>
If <tt>str.width()</tt> is nonzero and the number of <tt>charT</tt>'s in the
sequence after stage 2 is less than <tt>str.width()</tt>, then enough fill
characters are added to the sequence at the position indicated for padding to
bring the length of the sequence to <tt>str.width()</tt>. <tt>str.width(0)</tt>
is called.
</p>

<table border="1">
<caption>Table 88 &mdash; Fill padding</caption>
<tr>
<th>State</th>
<th>Location</th>
</tr>

<tr>
<td><tt>adjustfield == ios_base::left</tt></td>
<td>pad after</td>
</tr>

<tr>
<td><tt>adjustfield == ios_base::right</tt></td>
<td>pad before</td>
</tr>

<tr>
<td><tt>adjustfield == internal</tt> and a sign occurs in the representation</td>
<td>pad after the sign</td>
</tr>

<tr>
<td><tt>adjustfield == internal</tt> and representation after stage 1 began with 0x or 0X</td>
<td>pad after x or X</td>
</tr>

<tr>
<td><i>otherwise</i></td>
<td>pad before</td>
</tr>
</table>

</blockquote>

<p>
Although it's not 100% clear what "the sequence after stage 2" should mean here,
when there is no stage 2, the only reasonable assumption is that it is the
contents of the string being output.  In the above code, the string being output
is "<tt>0X1Y2Z</tt>", which starts with "<tt>0X</tt>", so the padding should be
inserted "after x or X", and not before the string. I believe that this is a
defect in the standard, and not in the three compilers I tried.
</p>

<p><i>[
2010 Batavia (post meeting session)
]</i></p>

<p>
Consensus that all known implementations are consistent, and disagree with the
standard. Preference is to fix the standard before implementations start trying
to conform to the current spec, as the current implementations have the preferred
form. Howard volunteered to drught for Madrid, move to Open.
</p>

<p><i>[2011-03-24 Madrid meeting]</i></p>


<p>
Daniel Kr&uuml;gler volunteered to provide wording, interacting with Dietmar and
Bill. 
</p>

<p><i>[2011-06-24 Daniel comments and provides wording]</i></p>


<p>
The same problem applies to the output provided by <tt>const char*</tt> and similar
character sequences as of 27.7.3.6.4 [ostream.inserters.character] p. 5. and even for
single character output (!) as described in 27.7.3.6.4 [ostream.inserters.character] p. 1,
just consider the character value '-' where '-' is the sign character. In this case
Table 91 &mdash; "Fill padding" requires to pad after the sign, i.e. the output
for the program
</p>
<blockquote><pre>
#include &lt;iostream&gt;
#include &lt;iomanip&gt;

int main() 
{ 
   char c = '-'; 
   std::cout.fill('*'); 
   std::cout.setf(std::ios::internal, std::ios::adjustfield); 
   std::cout &lt;&lt; std::setw(2) &lt;&lt; c &lt;&lt; std::endl; 
} 
</pre></blockquote>

<p>
According to the current wording this program should output "<tt>-*</tt>", but
all tested implementations output "<tt>*-</tt>" instead.

<p/>
I suggest to replace the reference to 22.4.2.2.2 [facet.num.put.virtuals] in all three places. 
It is not very complicated to describe the padding rules for simple character sequences "inline". 
A similar approach is used as for the <tt>money_put</tt> functions.
</p>

<p><i>[
2011 Bloomington
]</i></p>


<p>
Move to Review, the resolution seems correct but it would be nice if some factoring of the
common words were proposed.
</p>

<p><i>[2012, Kona]</i></p>

<p>
Moved to Tentatively Ready by the post-Kona issues processing subgroup.
</p>
<p>
While better factoring of the common words is desirable, it is also editorial and
should not hold up the progress of this issue.  As the edits impact two distinct
clauses, it is not entirely clear what a better factoring should look like.
</p>



<p><b>Proposed resolution:</b></p>
<p>
The new wording refers to the FDIS numbering.
</p>
<ol>
<li><p>Change 21.4.8.9 [string.io]&#47;5 as indicated:</p>
<blockquote><pre>
template&lt;class charT, class traits, class Allocator&gt;
  basic_ostream&lt;charT, traits&gt;&amp;
    operator&lt;&lt;(basic_ostream&lt;charT, traits&gt;&amp; os,
               const basic_string&lt;charT,traits,Allocator&gt;&amp; str);
</pre><blockquote><p>
-5- <i>Effects</i>: Behaves as a formatted output function ([ostream.formatted.reqmts]). After constructing a sentry object,
if this object returns <tt>true</tt> when converted to a value of type <tt>bool</tt>, determines padding as <del>described
in [facet.num.put.virtuals],</del><ins>follows: A <tt>charT</tt> character sequence is produced, initially consisting of 
the elements defined by the range <tt>[str.begin(), str.end())</tt>. If <tt>str.size()</tt> is less than <tt>os.width()</tt>, 
then enough copies of <tt>os.fill()</tt> are added to this sequence as necessary to pad to a width of <tt>os.width()</tt> 
characters. If <tt>(os.flags() &amp; ios_base::adjustfield) == ios_base::left</tt> is <tt>true</tt>, the fill characters 
are placed after the character sequence; otherwise, they are placed before the character sequence. T</ins><del>t</del>hen 
inserts the resulting sequence of characters <tt>seq</tt> as if by calling <tt>os.rdbuf()-&gt;sputn(seq, n)</tt>, where 
<tt>n</tt> is the larger of <tt>os.width()</tt> and <tt>str.size()</tt>; then calls <tt>os.width(0)</tt>.
</p></blockquote></blockquote>
</li>

<li><p>Change 27.7.3.6.4 [ostream.inserters.character]&#47;1 as indicated (An additional editorial
fix is suggested for the first prototype declaration):</p>
<blockquote><pre>
template&lt;class charT, class traits&gt;
  basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;charT,traits&gt;&amp; out,
                                          charT c<del>}</del><ins>)</ins>;
template&lt;class charT, class traits&gt;
  basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;charT,traits&gt;&amp; out,
                                          char c);
<i>// specialization</i>
template&lt;class traits&gt;
  basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp; out,
                                         char c);
<i>// signed and unsigned</i>
template&lt;class traits&gt;
  basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp; out,
                                         signed char c);
template&lt;class traits&gt;
  basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp; out,
                                         unsigned char c);
</pre><blockquote><p>
-1- <i>Effects</i>: Behaves like a formatted inserter (as described in [ostream.formatted.reqmts]) of <tt>out</tt>. 
After a sentry object is constructed it inserts characters. In case <tt>c</tt> has type <tt>char</tt> and the 
character type of the stream is not <tt>char</tt>, then the character to be inserted is <tt>out.widen(c)</tt>; 
otherwise the character is <tt>c</tt>. Padding is determined as <del>described in [facet.num.put.virtuals]</del><ins>follows: 
A character sequence is produced, initially consisting of the insertion character. If <tt>out.width()</tt> is greater
than one, then enough copies of <tt>out.fill()</tt> are added to this sequence as necessary to pad to a width of 
<tt>out.width()</tt> characters. If <tt>(out.flags() &amp; ios_base::adjustfield) == ios_base::left</tt> is <tt>true</tt>, 
the fill characters are placed after the insertion character; otherwise, they are placed before the insertion 
character</ins>. <del><tt>width(0)</tt> is called.</del> The insertion character and any required padding are 
inserted into <tt>out</tt><ins>; then calls <tt>os.width(0)</tt></ins>.
</p></blockquote></blockquote>
</li>

<li><p>Change 27.7.3.6.4 [ostream.inserters.character]&#47;5 as indicated:</p>
<blockquote><pre>
template&lt;class charT, class traits&gt;
  basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;charT,traits&gt;&amp; out,
                                          const charT* s);
template&lt;class charT, class traits&gt;
  basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;charT,traits&gt;&amp; out,
                                          const char* s);
template&lt;class traits&gt;
  basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp; out,
                                         const char* s);
template&lt;class traits&gt;
  basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp; out,
                                         const signed char* s);
template&lt;class traits&gt;
  basic_ostream&lt;char,traits&gt;&amp; operator&lt;&lt;(basic_ostream&lt;char,traits&gt;&amp; out,
                                         const unsigned char* s);
</pre><blockquote><p>
[&hellip;]
<p/>
-5- Padding is determined as <del>described in [facet.num.put.virtuals]. The <tt>n</tt> characters starting at <tt>s</tt> 
are widened using <tt>out.widen</tt> ([basic.ios.members])</del><ins>follows: A character sequence is produced, initially 
consisting of the elements defined by the <tt>n</tt> characters starting at <tt>s</tt> widened using 
<tt>out.widen</tt> ([basic.ios.members]). If <tt>n</tt> is less than <tt>out.width()</tt>, then enough copies of 
<tt>out.fill()</tt> are added to this sequence as necessary to pad to a width of <tt>out.width()</tt> characters. 
If <tt>(out.flags() &amp; ios_base::adjustfield) == ios_base::left</tt> is <tt>true</tt>, the fill characters are 
placed after the character sequence; otherwise, they are placed before the character sequence</ins>. The 
widened characters and any required padding are inserted into <tt>out</tt>. Calls <tt>width(0)</tt>.
</p></blockquote></blockquote>
</li>
</ol>






<hr>
<h3><a name="2048"></a>2048. Unnecessary <tt>mem_fn</tt> overloads</h3>
<p><b>Section:</b> 20.8 [function.objects], 20.8.10 [func.memfn] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Jonathan Wakely <b>Opened:</b> 2011-04-18 <b>Last modified:</b> 2012-03-10</p>
<p><b>View other</b> <a href="lwg-index-open.html#function.objects">active issues</a> in [function.objects].</p>
<p><b>View all other</b> <a href="lwg-index.html#function.objects">issues</a> in [function.objects].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
The <tt>mem_fn</tt> overloads for member functions are redundant and misleading
and should be removed from the post-C++11 WP.
<p/>
I believe the history of the overloads is as follows:
<p/>
In TR1 and in C++0x prior to the N2798 draft, <tt>mem_fn</tt> was specified by
a single signature:
</p>
<blockquote><pre>
template&lt;class R, class T&gt; <i>unspecified</i> mem_fn(R T::* pm);
</pre></blockquote>
<p>
and was accompanied by the remark "Implementations may implement <tt>mem_fn</tt> 
as a set of overloaded function templates." This remark predates variadic templates 
and was presumably to allow implementations to provide overloads for a limited 
number of function parameters, to meet the implementation-defined limit on numbers of
template parameters.
<p/>
N2770 "Concepts for the C++0x Standard Library: Utilities" added
separate overloads for pointers to member functions, apparently so
that function parameters would require the <tt>CopyConstructible</tt> concept
(those overloads first appeared in N2322.) The overloads failed to
account for varargs member functions (i.e. those declared with an
ellipsis in the parameter-declaration-clause) e.g.
</p>
<blockquote><pre>
struct S {
 int f(int, ...);
};
</pre></blockquote>
<p>
Syntactically such a function would be handled by the original
<tt>mem_fn(R T::* pm)</tt> signature, the only minor drawback being that there
would be no <tt>CopyConstructible</tt> requirement on the parameter list. (Core
DR 547 clarifies that partial specializations can be written to match
cv-qualified and ref-qualified functions to support the case where <tt>R T::*</tt> 
matches a pointer to member function type.)
<p/>
LWG issue <a href="lwg-defects.html#920">920</a> pointed out that additional overloads were missing for
member functions with ref-qualifiers. These were not strictly
necessary, because such functions are covered by the <tt>mem_fn(R T::* pm)</tt> signature.
<p/>
Concepts were removed from the draft and N3000 restored the original
single signature and accompanying remark.
<p/>
LWG <a href="lwg-closed.html#1230">1230</a> was opened to strike the remark again and to add an overload
for member functions (this overload was unnecessary for syntactic reasons and 
insufficient as it didn't handle member functions with cv-qualifiers and&#47;or 
ref-qualifiers.)
<p/>
<a href="lwg-defects.html#920">920</a> (and <a href="lwg-closed.html#1230">1230</a>) were resolved by restoring a full set of
(non-concept-enabled) overloads for member functions with cv-qualifiers and ref-qualifiers,
but as in the concept-enabled draft there were no overloads for member functions with 
an ellipsis in the parameter-declaration-clause. This is what is present in the FDIS.
<p/>
Following the thread beginning with message c++std-lib-30675, it is my
understanding that all the <tt>mem_fn</tt> overloads for member functions are
unnecessary and were only ever added to allow concept requirements.
I'm not aware of any reason implementations cannot implement <tt>mem_fn</tt> as
a single function template. Without concepts the overloads are
redundant, and the absence of overloads for varargs functions can be
interpreted to imply that varargs functions are not intended to work
with <tt>mem_fn</tt>. Clarifying the intent by adding overloads for varargs
functions would expand the list of 12 redundant overloads to 24, it
would be much simpler to remove the 12 redundant overloads entirely.
</p>

<p><i>[Bloomington, 2011]</i></p>

<p>
Move to Review.
</p>

<p>
The issue and resolution appear to be correct, but there is some concern that the wording of INVOKE may be different depending on whether you pass a pointer-to-member-data or pointer-to-member-function.  That might make the current wording necessary after all, and then we might need to add the missing elipsis overloads.
</p>

<p>
There was some concern that the Remark confirming implementors had freedom to implement this as a set of overloaded functions may need to be restored if we delete the specification for these overloads.
</p>

<p><i>[2012, Kona]</i></p>

<p>
Moved to Tentatively Ready by the post-Kona issues processing subgroup.
</p>



<p><b>Proposed resolution:</b></p>

<p>This wording is relative to the FDIS.</p>

<ol>
<li><p>Change the <tt>&lt;functional&gt;</tt> synopsis 20.8 [function.objects] p. 2 as follows:</p>

<blockquote><pre>
namespace std {
  [&hellip;]
  // <i>[func.memfn], member function adaptors:</i>
  template&lt;class R, class T&gt; <i>unspecified</i> mem_fn(R T::*);
<del>  template&lt;class R, class T, class... Args&gt;
  <i>unspecified</i> mem_fn(R (T::*)(Args...));
  template&lt;class R, class T, class... Args&gt;
  <i>unspecified</i> mem_fn(R (T::*)(Args...) const);
  template&lt;class R, class T, class... Args&gt;
  <i>unspecified</i> mem_fn(R (T::*)(Args...) volatile);
  template&lt;class R, class T, class... Args&gt;
  <i>unspecified</i> mem_fn(R (T::*)(Args...) const volatile);
  template&lt;class R, class T, class... Args&gt;
  <i>unspecified</i> mem_fn(R (T::*)(Args...) &amp;);
  template&lt;class R, class T, class... Args&gt;
  <i>unspecified</i> mem_fn(R (T::*)(Args...) const &amp;);
  template&lt;class R, class T, class... Args&gt;
  <i>unspecified</i> mem_fn(R (T::*)(Args...) volatile &amp;);
  template&lt;class R, class T, class... Args&gt;
  <i>unspecified</i> mem_fn(R (T::*)(Args...) const volatile &amp;);
  template&lt;class R, class T, class... Args&gt;
  <i>unspecified</i> mem_fn(R (T::*)(Args...) &amp;&amp;);
  template&lt;class R, class T, class... Args&gt;
  <i>unspecified</i> mem_fn(R (T::*)(Args...) const &amp;&amp;);
  template&lt;class R, class T, class... Args&gt;
  <i>unspecified</i> mem_fn(R (T::*)(Args...) volatile &amp;&amp;);
  template&lt;class R, class T, class... Args&gt;
  <i>unspecified</i> mem_fn(R (T::*)(Args...) const volatile &amp;&amp;);</del>

  [&hellip;]
}
</pre></blockquote>
</li>

<li><p>Change 20.8.10 [func.memfn] as follows:</p>

<blockquote><pre>
template&lt;class R, class T&gt; <i>unspecified</i> mem_fn(R T::*);
<del>template&lt;class R, class T, class... Args&gt;
<i>unspecified</i> mem_fn(R (T::*)(Args...));
template&lt;class R, class T, class... Args&gt;
<i>unspecified</i> mem_fn(R (T::*)(Args...) const);
template&lt;class R, class T, class... Args&gt;
<i>unspecified</i> mem_fn(R (T::*)(Args...) volatile);
template&lt;class R, class T, class... Args&gt;
<i>unspecified</i> mem_fn(R (T::*)(Args...) const volatile);
template&lt;class R, class T, class... Args&gt;
<i>unspecified</i> mem_fn(R (T::*)(Args...) &amp;);
template&lt;class R, class T, class... Args&gt;
<i>unspecified</i> mem_fn(R (T::*)(Args...) const &amp;);
template&lt;class R, class T, class... Args&gt;
<i>unspecified</i> mem_fn(R (T::*)(Args...) volatile &amp;);
template&lt;class R, class T, class... Args&gt;
<i>unspecified</i> mem_fn(R (T::*)(Args...) const volatile &amp;);
template&lt;class R, class T, class... Args&gt;
<i>unspecified</i> mem_fn(R (T::*)(Args...) &amp;&amp;);
template&lt;class R, class T, class... Args&gt;
<i>unspecified</i> mem_fn(R (T::*)(Args...) const &amp;&amp;);
template&lt;class R, class T, class... Args&gt;
<i>unspecified</i> mem_fn(R (T::*)(Args...) volatile &amp;&amp;);
template&lt;class R, class T, class... Args&gt;
<i>unspecified</i> mem_fn(R (T::*)(Args...) const volatile &amp;&amp;);</del>
</pre></blockquote>
</li>

</ol>






<hr>
<h3><a name="2049"></a>2049. <tt>is_destructible</tt> is underspecified</h3>
<p><b>Section:</b> 20.9.4.3 [meta.unary.prop] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Daniel Kr&uuml;gler <b>Opened:</b> 2011-04-18 <b>Last modified:</b> 2012-03-10</p>
<p><b>View other</b> <a href="lwg-index-open.html#meta.unary.prop">active issues</a> in [meta.unary.prop].</p>
<p><b>View all other</b> <a href="lwg-index.html#meta.unary.prop">issues</a> in [meta.unary.prop].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>The conditions for the type trait <tt>is_destructible</tt> to be true
are described in Table 49 &mdash; Type property predicates:</p>
<blockquote><p>
For a complete type <tt>T</tt> and given<br/>
<tt>template &lt;class U&gt;
struct test { U u; };</tt>,<br/>
<tt>test&lt;T&gt;::~test()</tt> is not deleted.
</p></blockquote>

<p>This specification does not say what the result would be for function
types or for abstract types:</p>
<ol>
<li>For an abstract type <tt>X</tt> the instantiation <tt>test&lt;X&gt;</tt>
is already ill-formed, so we cannot say anything about whether the destructor
would be deleted or not.</li>
<li>In regard to function types, there exists a special rule in the core language, 14.3.1 [temp.arg.type] p. 3,
which excludes member functions to be declared via the type of the template parameter:
<blockquote><p>
If a declaration acquires a function type through a type dependent on a <i>template-parameter</i>
and this causes a declaration that does not use the syntactic form of a function declarator 
to have function type, the program is ill-formed. 
<p/>
[ <i>Example</i>:</p>
<blockquote><pre>
template&lt;class T&gt; struct A {
  static T t;
};
typedef int function();
A&lt;function&gt; a; // ill-formed: would declare A&lt;function&gt;::t
               // as a static member function
</pre></blockquote>
<p>
&mdash; <i>end example</i> ]
</p></blockquote>
which has the same consequence as for abstract types, namely that the corresponding
instantiation of <tt>test</tt> is already ill-formed and we cannot say anything
about the destructor.
</li>
</ol>
<p>To solve this problem, I suggest to specify function types as trivially and nothrowing
destructible, because above mentioned rule is very special for templates. For non-templates,
a typedef can be used to introduce a member as member function as clarified in 8.3.5 [dcl.fct]
p. 10.</p>
<p>For abstract types, two different suggestions have been brought to my attention:
Either declare them as unconditionally non-destructible or check whether the expression
</p>
<blockquote><pre>
std::declval&lt;T&amp;&gt;().~T()
</pre></blockquote>
<p>is well-formed in an unevaluated context. The first solution is very easy to specify,
but the second version has the advantage for providing more information to user-code. This 
information could be quite useful, if generic code is supposed to invoke the destructor
of a reference to a base class indirectly via a delete expression, as suggested by
Howard Hinnant:</p>
<blockquote><pre>
template &lt;class T&gt;
my_pointer&lt;T&gt;::~my_pointer() noexcept(is_nothrow_destructible&lt;T&gt;::value)
{
   delete ptr_;
}
</pre></blockquote>
<p>Additional to the <tt>is_destructible</tt> traits, its derived forms <tt>is_trivially_destructible</tt>
and <tt>is_nothrow_destructible</tt> are similarly affected, because their wording refers to "the indicated
destructor" and probably need to be adapted as well.</p>

<p><i>[
2011 Bloomington
]</i></p>


<p>
After discussion about to to handle the exceptional cases of reference types, function types (available by defererencing a function pointer)
and <tt>void</tt> types, Howard supplied proposed wording.
</p>

<p><i>[
2011-08-20 Daniel comments and provides alternatives wording
]</i></p>


<p>
The currently proposed wording would have the consequence that 
<em>every</em> array type is not destructible, because the pseudo-destructor
requires a scalar type with the effect that the expression
</p><blockquote><pre>
std::declval&lt;T&amp;&gt;().~T()
</pre></blockquote><p>
is not well-formed for e.g. <tt>T</tt> equal to <tt>int[3]</tt>. The intuitive
solution to fix this problem would be to adapt the object type case to refer to 
the expression
</p><blockquote><pre>
std::declval&lt;U&amp;&gt;().~U()
</pre></blockquote><p>
with <tt>U</tt> equal to <tt>remove_all_extents&lt;T&gt;::type</tt>, but that
would have the effect that arrays of unknown bounds would be destructible, if 
the element type is destructible, which was not the case before (This was 
intentionally covered by the special "For a complete type T" rule in
the FDIS).
<p/>
Suggestion: Use the following definition instead:
</p>
<blockquote><p>
Let <tt>U</tt> be <tt>remove_all_extents&lt;T&gt;::type</tt>.<br/>
For incomplete types and function types, <tt>is_destructible&lt;T&gt;::value</tt> is <tt>false</tt>.<br/>
For object types, if the expression <tt>std::declval&lt;U&amp;&gt;().~U()</tt> is well-formed<br/>
when treated as an unevaluated operand (Clause 5), then <tt>is_destructible&lt;T&gt;::value</tt><br/>
is <tt>true</tt>, otherwise it is <tt>false</tt>.<br/>
For reference types, <tt>is_destructible&lt;T&gt;::value</tt> is <tt>true</tt>.
</p></blockquote>
<p>
This wording also harmonizes with the "unevaluated operand" phrase
used in other places, there does not exist the definition of an
"unevaluated context"
<p/>
<em>Note:</em> In the actually proposed wording this wording has been slightly reordered with the same effects. 
</p>

<p><strong>Howard's (old) proposed resolution:</strong></p>
<blockquote class="note">
<p>
Update 20.9.4.3 [meta.unary.prop], table 49:
</p>

<table border="1">
<tr>
<td><tt>template &lt;class T&gt;
struct is_destructible;</tt></td>
<td>
<del>For a complete type <tt>T</tt> and given <tt>template &lt;class U&gt; struct test { U u; };</tt>, <tt>test&lt;T&gt;::~test()</tt> is not deleted.
</del>
<br/>
<ins>
For object types, if the expression: <tt>std::declval&lt;T&amp;>().~T()</tt> is well-formed in an unevaluated context then
<tt>is_destructible&lt;T>::value</tt> is <tt>true</tt>, otherwise it is <tt>false</tt>.
<br/>
For <tt>void</tt> types, <tt>is_destructible&lt;T>::value</tt> is <tt>false</tt>.
<br/>
For reference types, <tt>is_destructible&lt;T>::value</tt> is <tt>true</tt>.
<br/>
For function types, <tt>is_destructible&lt;T>::value</tt> is <tt>false</tt>.
</ins>
</td>
<td><tt>T</tt> shall be a complete type, (possibly cv-qualified) <tt>void</tt>, or an array of unknown bound.</td>
</tr>
</table>
</blockquote>
<p>
</p>

<p><i>[2012, Kona]</i></p>

<p>
Moved to Tentatively Ready by the post-Kona issues processing subgroup.
</p>



<p><b>Proposed resolution:</b></p>

<p>
Update 20.9.4.3 [meta.unary.prop], table 49:
</p>

<table border="1">
<tr>
<td><tt>template &lt;class T&gt;
struct is_destructible;</tt></td>
<td>
<del>For a complete type <tt>T</tt> and given <tt>template &lt;class U&gt; struct test { U u; };</tt>, <tt>test&lt;T&gt;::~test()</tt> is not deleted.
</del>
<br/>
<ins>
For reference types, <tt>is_destructible&lt;T&gt;::value</tt> is <tt>true</tt>.<br/>
For incomplete types and function types, <tt>is_destructible&lt;T&gt;::value</tt> is <tt>false</tt>.<br/>
For object types and given <tt>U</tt> equal to <tt>remove_all_extents&lt;T&gt;::type</tt>,<br/> 
if the expression <tt>std::declval&lt;U&amp;&gt;().~U()</tt> is well-formed when treated as an<br/>
unevaluated operand (Clause 5 [expr]), then <tt>is_destructible&lt;T&gt;::value</tt> is <tt>true</tt>,<br/>
otherwise it is <tt>false</tt>.<br/>
</ins>
</td>
<td><tt>T</tt> shall be a complete type, (possibly cv-qualified) <tt>void</tt>, or an array of unknown bound.</td>
</tr>
</table>






<hr>
<h3><a name="2056"></a>2056. <tt>future_errc</tt> enums start with value 0 (invalid value for <tt>broken_promise</tt>)</h3>
<p><b>Section:</b> 30.6.1 [futures.overview] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Nicolai Josuttis <b>Opened:</b> 2011-05-18 <b>Last modified:</b> 2012-03-10</p>
<p><b>View all other</b> <a href="lwg-index.html#futures.overview">issues</a> in [futures.overview].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
In 30.6.1 [futures.overview] <tt>enum class future_errc</tt> is defined as follows:
</p><blockquote><pre>
enum class future_errc {
  broken_promise,
  future_already_retrieved,
  promise_already_satisfied,
  no_state
};
</pre></blockquote><p>
With this declaration <tt>broken_promise</tt> has value 0, which means that
for a <tt>future_error f</tt> with this code
</p><blockquote><pre>
f.code().operator bool()
</pre></blockquote><p>
yields false, which makes no sense. 0 has to be reserved for "no error".
So, the enums defined here have to start with 1.
<p/>
Howard, Anthony, and Jonathan have no objections.
</p>
<p>[Discussion in Bloomington 2011-08-16]
</p>
<p>
Previous resolution:
</p>
<blockquote class="note">
<p>This wording is relative to the FDIS.</p>
<ol>
<li><p>In 30.6.1 [futures.overview], header <tt>&lt;future&gt;</tt> synopsis, fix 
the declaration of <tt>future_errc</tt> as follows:</p>
<blockquote><pre>
namespace std {
  enum class future_errc {
    <del>broken_promise,</del>
    future_already_retrieved<ins> = 1</ins>,
    promise_already_satisfied,
    no_state<ins>,
    broken_promise</ins>
  };
  [&hellip;]
}
</pre></blockquote>
</li>
</ol>
</blockquote>
<p>
Is this resolution overspecified? These seem to be all implementation-defined. How do users add new values and not conflict with established error codes?
</p><p>
PJP proxy says: over-specified. boo.
</p><p>
Other error codes: look for <tt>is_error_code_enum</tt> specializations. Only one exists <tt>io_errc</tt>
</p><p>
Peter: I don't see any other parts of the standard that specify error codes where we have to do something similar.
</p><p>
Suggest that for every place where we add an error code, the following:
</p>
<ol>
   <li> no zero values
   </li><li> all implementation defined values, so future_already_retrieved = implementation_defined
   </li><li> values are distinct
</li></ol>

<p><i>[2012, Kona]</i></p>

<p>
Moved to Tentatively Ready by the post-Kona issues processing subgroup.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS.</p>
<p>In 30.6.1 [futures.overview], header <tt>&lt;future&gt;</tt> synopsis, fix 
the declaration of <tt>future_errc</tt> as follows:</p>

<blockquote><pre>
namespace std {
  enum class future_errc {
    broken_promise<ins> = <var>implementation defined</var></ins>,
    future_already_retrieved<ins> = <var>implementation defined</var></ins>,
    promise_already_satisfied<ins> = <var>implementation defined</var></ins>,
    no_state<ins> = <var>implementation defined</var></ins>
  };
  [&hellip;]
}
</pre></blockquote>
<p>In 30.6.1 [futures.overview], header <tt>&lt;future&gt;</tt> synopsis, add a paragraph after paragraph 2 as follows:</p>

<ins>The enum values of <tt>future_errc</tt> are distinct and not zero.</ins>




<hr>
<h3><a name="2058"></a>2058. <tt>valarray</tt> and <tt>begin&#47;end</tt></h3>
<p><b>Section:</b> 26.6 [numarray] <b>Status:</b> <a href="lwg-active.html#Ready">Tentatively Ready</a>
 <b>Submitter:</b> Gabriel Dos Reis <b>Opened:</b> 2011-05-17 <b>Last modified:</b> 2012-03-10</p>
<p><b>View all other</b> <a href="lwg-index.html#numarray">issues</a> in [numarray].</p>
<p><b>View all issues with</b> <a href="lwg-status.html#Tentatively Ready">Tentatively Ready</a> status.</p>
<p><b>Discussion:</b></p>
<p>
It was just brought to my attention that the pair of functions
<tt>begin&#47;end</tt> were added to <tt>valarray</tt> component.
Those additions strike me as counter to the long standing agreement
that <tt>valarray&lt;T&gt;</tt> is not yet another container. Valarray values
are in general supposed to be treated as a whole, and as such
has a loose specification allowing expression template techniques.
<p/>
The addition of these functions sound to me as making it much harder
(or close to impossible) to effectively use expression templates
as implementation techniques, for no clear benefits.
<p/>
My recommendation would be to drop <tt>begin&#47;end</tt> - or at least for the
<tt>const valarray&lt;T&gt;&amp;</tt> version. I strongly believe those 
are defects.
</p>
<p><i>[This issue was discussed on the library reflector starting from c++std-lib-30761.
Some of the key conclusions of this discussion were:]</i></p>

<ol>
<li>The <tt>begin&#47;end</tt> members were added to allow <tt>valarray</tt> to participate
in the new range-based for-loop by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2930.html">n2930</a>
and not to make them container-like.</li>
<li>It is currently underspecified when the iterator values returned from
<tt>begin&#47;end</tt> become invalidated. To fix this, these invalidation rules need at
least to reflect the invalidation rules of the references returned by the
<tt>operator[]</tt> overloads of <tt>valarray</tt> (26.6.2.4 [valarray.access]).
</li>
<li>A further problem is that the requirements expressed in 26.6.1 [valarray.syn] p.3-5
enforce an implementation to provide further overloads of <tt>begin&#47;end</tt>, if the
replacement type technique is used (which was clearly part of the design of <tt>valarray</tt>).
Providing such additional overloads would also lead to life-time problems in examples like 
<tt>begin(x + y)</tt> where <tt>x</tt> and <tt>y</tt> are expressions involving <tt>valarray</tt> 
objects. To fix this, the <tt>begin&#47;end</tt> overloads could be explicitly excluded from the 
general statements of 26.6.1 [valarray.syn] p.3-5. This would make it unspecified
whether the expression <tt>begin(x + y)</tt> would be well-formed, portable code would
need to write this as <tt>begin(std::valarray&lt;T&gt;(x + y))</tt>.</li>
</ol>

<p><i>[
2011 Bloomington
]</i></p>


<p>
The intent of these overloads is entirely to support the new for syntax, and not to create
new containers.
</p>

<p>
Stefanus provides suggested wording.
</p>


<p><i>[2012, Kona]</i></p>

<p>
Moved to Tenatively Ready by post-meeting issues processing group, after confirmation
from Gaby.
</p>



<p><b>Proposed resolution:</b></p>
<p>
In 26.6.1 [valarray.syn]&#47;4, make the following <ins>insertion</ins>:
</p>

<p>
4 Implementations introducing such replacement types shall provide additional functions and operators as
follows:
</p>
<ul>
<li>for every function taking a <tt>const valarray&lt;T&gt;&amp;</tt> <ins>other than <tt>begin</tt> and <tt>end</tt>
(26.6.10 [valarray.range])</ins>, identical functions taking the replacement types shall be added;
</li>
<li>
for every function taking two <tt>const valarray&lt;T&gt;&amp;</tt> arguments, identical functions taking every combination
of <tt>const valarray&lt;T&gt;&amp;</tt> and replacement types shall be added.
</li>
</ul>

<p>
In 26.6.10 [valarray.range], make the following <ins>insertion</ins>:
</p>
<p> 
1 In the <tt>begin</tt> and <tt>end</tt> function templates that follow, <i>unspecified</i>1 is a type that meets
the requirements of a mutable random access iterator (24.2.7) whose <tt>value_type</tt> is the template parameter
<tt>T</tt> and whose <tt>reference</tt> type is <tt>T&amp;</tt>. <i>unspecified</i>2 is a type that meets the
requirements of a constant random access iterator (24.2.7) whose <tt>value_type</tt> is the template parameter
<tt>T</tt> and whose <tt>reference</tt> type is <tt>const T&amp;</tt>.
</p>
<p><ins>
2 The iterators  returned by <tt>begin</tt> and <tt>end</tt> for an array are guaranteed to be valid until the
member function <tt>resize(size_t, T)</tt> (26.6.2.8 [valarray.members]) is called for that array or until
the lifetime of that array ends, whichever happens first.
</ins></p>





<hr>
<h3><a name="2124"></a>2124. Seed sequence over-specified</h3>
<p><b>Section:</b> 26.5.1.2 [rand.req.seedseq] <b>Status:</b> <a href="lwg-active.html#NAD">Tentatively NAD</a>
 <b>Submitter:</b> Alberto Ganesh Barbati <b>Opened:</b> 2012-01-16 <b>Last modified:</b> 2012-03-10</p>
<p><b>Discussion:</b></p>

<p>
The seed sequence requirements described in 26.5.1.2 [rand.req.seedseq] appear to be over-specified. 
All seed sequence types are required to have a <tt>result_type</tt> nested type, a specific set of 
constructors, function members <tt>size()</tt> and <tt>param()</tt>, which are never used by the library. 
In fact, the only library components that actively use seed sequences are the random engines and all the 
engines need is the <tt>generate()</tt> member function. In particular, library components never attempts 
to construct seed sequence objects. These extraneous requirements are clearly written to describe the 
library provided type <tt>seed_seq</tt> type; while it's good that seed_seq has all those constructors and 
members, it's not a compelling reason to require a user-provided seed sequence type to implement all of 
them.
<p/>
Suppose I want to write my own seed sequence class, this should do fine (and actually works as expected with libc++):
</p>
<blockquote><pre>
class my_seed_seq
{
  /* internals */
public:
  my_seed_seq(/* my own parameters */);

  template &lt;class It&gt;
  void generate(It first, It last);
};

my_seed_seq s(/* params */);
std::default_random_engine e(s);
</pre></blockquote>
<p>
The only reason to have these extra members would be to provide some support for generic serializability&#47;persistence 
of seed sequence objects. I believe that would be out of the scope of the random library, so I doubt we will ever need 
those requirements in the future.
<p/>
I therefore propose to remove all requirements from 26.5.1.2 [rand.req.seedseq] except for the presence of the 
<tt>generate()</tt> function.
</p>

<p><i>[2012, Kona]</i></p>

<p>
Move to Tenatively NAD.  (Tentative as issue was not in pre-meeting mailing)
</p>
<p>
The 'overspecification', as such, was a deliberate intent to provide guarantees consumers of the whole
random number framework may rely upon, especially in generic code.  While the standard engines may be
built without relying on these guarantees, this specification is part of a commitment to a broader
framework, and Walter indicated future proposals in preparation for parallel generation of random
numbers that may depend more inimately on these existing requirements.
</p>
<p>
Alisdair noted that the <tt>result_type</tt> typedef was a call-back to how we used to specify
adaptable functors before TR1 <tt>result_of</tt> and the addition of <tt>std::bind</tt> and is
probably not something we should be actively promoting in future libraries.  However, it is too
late to remove this requirement from seed sequences unless we are doing further surgery, as
recommended by this issue.
</p>
<p>
Walter notes that the <tt>result_type</tt> protocol has not been formally deprecated by the
standard.  Alisdair replies that was the intent of deprecating the <tt>bind_1st</tt>/
<tt>unary_function</tt> set of templates in C++11, although we did not say anything about
<tt>result_type</tt> in general.
</p>



<p><b>Proposed resolution:</b></p>
<p>This wording is relative to the FDIS.</p>

<ol>
<li>
<p>Edit 26.5.1.2 [rand.req.seedseq] p2 as indicated:</p>

<blockquote><p>
A class <tt>S</tt> satisfies the requirements of a seed sequence if the expressions shown in Table 115 are valid and
have the indicated semantics, and if <tt>S</tt> also satisfies all other requirements of this section 26.5.1.2 [rand.req.seedseq]. 
In that Table and throughout this section:
</p>
<ol style="list-style-type:lower-alpha">
<li>
<del><tt>T</tt> is the type named by <tt>S</tt>'s associated <tt>result_type</tt>;</del>
</li>
<li>
<tt>q</tt> is a value of <tt>S</tt><del> and <tt>r</tt> is a possibly const value of <tt>S</tt></del>; <ins>and</ins>
</li>
<li>
<del><tt>ib</tt> and <tt>ie</tt> are input iterators with an unsigned integer <tt>value_type</tt> of at least 32 bits;</del>
</li>
<li><tt>rb</tt> and <tt>re</tt> are mutable random access iterators with an unsigned integer <tt>value_type</tt> of at least 32 bits;</li>
<li>
<del><tt>ob</tt> is an output iterator; and</del>
</li>
<li>
<del><tt>il</tt> is a value of <tt>initializer_list&lt;T&gt;</tt>.</del>
</li>
</ol>
</blockquote>
</li>

<li>
<p>Ditto, in Table 115, remove all rows except the one describing <tt>q.generate(rb, re)</tt>:</p>

<table border="1">
<caption>Table 115 &mdash; Seed sequence requirements</caption>
<tr align="center">
<th>Expression</th>
<th>Return type</th>
<th>Pre&#47;Post-condition</th>
<th>Complexity</th>
</tr> 

<tr>
<td>
<del><tt>S::result_type</tt></del>
</td>
<td>
<del><tt>T</tt></del>
</td>
<td>
<del><tt>T</tt> is an unsigned integer<br/>
type (3.9.1 [basic.fundamental]) of at least 32 bits.</del>
</td>
<td>
<del>compile-time</del>
</td>
</tr>

<tr>
<td>
<del><tt>S()</tt></del>
</td>
<td>
&nbsp;
</td>
<td>
<del>Creates a seed sequence with<br/>
the same initial state as all<br/>
other default-constructed seed<br/>
sequences of type <tt>S</tt>.</del>
</td>
<td>
<del>constant</del>
</td>
</tr>

<tr>
<td>
<del><tt>S(ib,ie)</tt></del>
</td>
<td>
&nbsp;
</td>
<td>
<del>Creates a seed sequence having<br/>
internal state that depends on<br/>
some or all of the bits of the<br/>
supplied sequence <tt>[ib, ie)</tt>.</del>
</td>
<td>
<del><tt>&#x1d4aa;(ie - ib)</tt></del>
</td>
</tr>

<tr>
<td>
<del><tt>S(il)</tt></del>
</td>
<td>
&nbsp;
</td>
<td>
<del>Same as <tt>S(il.begin(),<br/>
il.end())</tt>.</del>
</td>
<td>
<del>same as<br/>
<tt>S(il.begin(),<br/>
il.end())</tt></del>
</td>
</tr>

<tr>
<td>
<tt>q.generate(rb,re)</tt>
</td>
<td>
<tt>void</tt>
</td>
<td>
Does nothing if <tt>rb == re</tt>.<br/>
Otherwise, fills the supplied<br/>
sequence <tt>[rb, re)</tt> with 32-bit<br/>
quantities that depend on the<br/>
sequence supplied to the<br/>
constructor and possibly also<br/>
depend on the history of<br/>
<tt>generate</tt>'s previous<br/>
invocations.
</td>
<td>
<tt>&#x1d4aa;(re - rb)</tt>
</td>
</tr>

<tr>
<td>
<del><tt>r.size()</tt></del>
</td>
<td>
<del><tt>size_t</tt></del>
</td>
<td>
<del>The number of 32-bit units that<br/>
would be copied by a call to<br/>
<tt>r.param</tt>.</del>
</td>
<td>
<del>constant</del>
</td>
</tr>

<tr>
<td>
<del><tt>r.param(ob)</tt></del>
</td>
<td>
<del><tt>void</tt></del>
</td>
<td>
<del>Copies to the given destination
a sequence of 32-bit units that<br/>
can be provided to the<br/>
constructor of a second object<br/>
of type <tt>S</tt>, and that would<br/>
reproduce in that second object<br/>
a state indistinguishable from<br/>
the state of the first object.</del>
</td>
<td>
<del><tt>&#x1d4aa;(r.size())</tt></del>
</td>
</tr>

</table>
 </li>

</ol>






</body>
</html>
